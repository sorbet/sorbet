#!/usr/bin/env ruby

class Sorbet; end
module Sorbet::Private; end

require_relative '../lib/sorbet'
require_relative '../lib/step_interface'
require_relative '../lib/create-config'
require_relative '../lib/gem-generator-tracepoint'
require_relative '../lib/hidden-definition-finder'
require_relative '../lib/fetch-rbis'
require_relative '../lib/suggest-typed'
require_relative '../lib/todo-rbi'

module Sorbet::Private::Main
  def self.emojify(emoji, msg)
    if STDOUT.isatty && RUBY_PLATFORM =~ /darwin/
      "#{emoji} #{msg}"
    else
      msg
    end
  end

  def self.yellow(msg)
    if STDOUT.isatty
      "\u001b[0;33m#{msg}\u001b[0m"
    else
      msg
    end
  end

  def self.cyan(msg)
    if STDOUT.isatty
      "\u001b[0;36m#{msg}\u001b[0m"
    else
      msg
    end
  end

  def self.main(argv)
    command = parse_command(argv)
    return command.call if command

    puts "
#{emojify("üëã", "Hey there!")}

This script will get this project ready to use with Sorbet by creating a
sorbet/ folder for your project. It will contain:

- a config file
- a bunch of 'RBI files'

RBI stands for 'Ruby Interface'; these files define classes, methods, and
constants that exist, but which Sorbet doesn't always know about.

#{emojify("‚ö†Ô∏è ", "Heads up:")}

To set up your project, this script will take two potentially destructive
actions:

1.  It will #{yellow("require every file in your project")}. Specifically, every script in
    your project will be run, unless that script checks #{cyan("if __FILE__ == $0")} (or
    #{cyan("if __FILE__ == $PROGRAM_NAME")}) before running any code.

2.  It will add a #{yellow("comment to the top of every file")} (like #{cyan("# typed: false")} or
    #{cyan("# typed: true")}, depending on how many errors were found in that file.)

"
    STDOUT.write(emojify("‚ùî", "Would you like to continue? [Y/n] "))
    if STDIN.isatty
      begin
        input = Kernel.gets&.strip
        if input.nil? || (input != '' && input != 'y' && input != 'Y')
          puts "\nAborting"
          Kernel.exit(1)
        end
      rescue Interrupt
        puts "\nAborting"
        Kernel.exit(1)
      end
    elsif ENV['SRB_YES']
      puts "\nSRB_YES set, proceeding"
    else
      puts "\nNot running interactivly. Set SRB_YES=1 environment variable to proceed"
      Kernel.exit(1)
    end

    # Create sorbet/config file
    make_step(Sorbet::Private::CreateConfig).call

    # Pull in the hand-written RBIs
    make_step(Sorbet::Private::FetchRBIs).call

    # Generate the RBIs from bundler
    make_step(Sorbet::Private::GemGeneratorTracepoint).call

    # Find the hidden methods
    make_step(Sorbet::Private::HiddenMethodFinder).call

    # Run sorbet and make constants to fix errors
    make_step(Sorbet::Private::TodoRBI).call

    # Run type suggestion once, and then generate the todo.rbi again.
    #
    # The first time we suggest typed sigils, a few files may be ignored if they
    # use Ruby features Sorbet does not support. However, since we ran the
    # todo.rbi generation before they were ignored, we discovered the constants
    # that they defined and did not add the constants to todo.rbi file.
    #
    # Regenerating after one run of sigil suggestion will put those constants
    # into the todo.rbi file.
    make_step(Sorbet::Private::SuggestTyped).call
    make_step(Sorbet::Private::TodoRBI).call

    # Put some `typed:` sigils
    make_step(Sorbet::Private::SuggestTyped).call

    puts "
#{emojify("‚úÖ", "Done!")}

This project is now set up for use with Sorbet. The sorbet/ folder should exist
and look something like this:

    sorbet/
    ‚îú‚îÄ‚îÄ config                      # Default options to passed to sorbet on every run
    ‚îî‚îÄ‚îÄ rbi/
        ‚îú‚îÄ‚îÄ sorbet-typed/           # Community writen type definition files for your gems
        ‚îú‚îÄ‚îÄ gems/                   # Autogenerated type definitions for your gems (from reflection)
        ‚îú‚îÄ‚îÄ hidden-definitions/     # All definitions that exist at runtime, but Sorbet couldn't see statically
        ‚îî‚îÄ‚îÄ todo.rbi                # Constants which were still missing, even after the three steps above.

Please check this whole folder into version control.

#{emojify("‚û°Ô∏è ", "What's next?")}

Up to you! First things first, you'll probably want to typecheck your project:

    #{cyan("srb tc")}

Other than that, it's up to you!
We recommend skimming these docs to get a feel for how to use Sorbet:

- Gradual Type Checking
  (#{cyan("https://stripe.dev/sorbet/super-secret-private-beta/docs/gradual")})
- Enabling Static Checks
  (#{cyan("https://stripe.dev/sorbet/super-secret-private-beta/docs/static")})
- RBI Files
  (#{cyan("https://stripe.dev/sorbet/super-secret-private-beta/docs/rbi")})

If instead you like to throw caution to the wind, here are some things to try:

- Upgrade a file marked # typed: false to # typed: true.
  Then, run #{cyan("srb tc")} and try to fix any errors.
- Add signatures to your methods with `sig`.
  For how, read: #{cyan("https://stripe.dev/sorbet/super-secret-private-beta/docs/sigs")}
- Check whether things that show up in the TODO RBI file actually exist in your project.
  It's possible that definitions in the TODO RBI file don't actually exist!
- Upgrade a file marked #{cyan("# typed: ignore")} to #{cyan("# typed: false")}.
  Then, run #{cyan("srb tc")} and try to fix any errors.

#{emojify("üôå", "Please don't hesitate to give us your feedback!")}
    "
  end

  def self.parse_command(argv)
    return nil if argv.length == 0

    banner = "Usage: srb rbi <command>
  This script gets your current directory ready for using Sorbet by making all sorts of files in ./sorbet/. You should commit them to version control.

  We recommend running it without any options which will execute all the commands in order. If you only need a certain piece, you can pass a command to just run that part.

  You should re-run this script if your program ever stops typechecking due to dynamic code in your project."
    commands = "
  Common Commands:
    help                Print this message
    <empty> | update    Run all initialization commands

  Specific Commands:
    config              Recreate sorbet/config
    sorbet-typed        Download community maintained type definitions for gems
    gems                Generate arity-only type definitions by requiring the gem
    hidden-definitions  Load all your code and generate type definitions for any dynamic code
    todo                Run Sorbet and generate constants which Sorbet errors on
    suggest-typed       Put the highest `typed:` sigil in each of your files
    "

    command = case (argv[0])
    when 'help', '--help'
      puts banner
      puts commands
      exit(1)
    when 'config', Sorbet::Private::CreateConfig.output_file
      make_step(Sorbet::Private::CreateConfig.main)
    when 'sorbet-typed', Sorbet::Private::FetchRBIs.output_file, Sorbet::Private::FetchRBIs::SORBET_RBI_LIST
      make_step(Sorbet::Private::FetchRBIs.main)
    when 'gems', Sorbet::Private::GemGeneratorTracepoint.output_file
      make_step(Sorbet::Private::GemGeneratorTracepoint.main)
    when 'hidden-definitions', Sorbet::Private::HiddenMethodFinder.output_file
      make_step(Sorbet::Private::HiddenMethodFinder.main)
    when 'todo', Sorbet::Private::TodoRBI.output_file
      make_step(Sorbet::Private::TodoRBI.main)
    when 'suggest-typed'
      make_step(Sorbet::Private::SuggestTyped.main)

    when 'update'
      nil

    else
      puts "Unknown comand: #{argv[0]}"
      puts commands
      exit(1)
    end

    puts "Running command: #{argv[0]}"
    command
  end

  Sorbet.sig {params(step: Sorbet::Private::StepInterface).returns(T.proc.void)}
  def self.make_step(step)
    -> do
      puts "Generating: #{step.output_file}" if step.output_file
      step.main
    end
  end
end

Sorbet::Private::Main.main(ARGV)
