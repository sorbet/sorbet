# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.ver(); end
end

class Binding
  def clone(); end
end

module Bundler
  FREEBSD = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  ORIGINAL_ENV = ::T.let(nil, ::T.untyped)
  SUDO_MUTEX = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Bundler::APIResponseMismatchError
  def status_code(); end
end

class Bundler::APIResponseMismatchError
end

module Bundler::BuildMetadata
end

module Bundler::BuildMetadata
  def self.built_at(); end

  def self.git_commit_sha(); end

  def self.release?(); end

  def self.to_h(); end
end

class Bundler::BundlerError
end

class Bundler::BundlerError
  def self.all_errors(); end

  def self.status_code(code); end
end

class Bundler::CurrentRuby
  def jruby?(); end

  def jruby_18?(); end

  def jruby_19?(); end

  def jruby_1?(); end

  def jruby_20?(); end

  def jruby_21?(); end

  def jruby_22?(); end

  def jruby_23?(); end

  def jruby_24?(); end

  def jruby_25?(); end

  def jruby_26?(); end

  def jruby_27?(); end

  def jruby_2?(); end

  def maglev?(); end

  def maglev_18?(); end

  def maglev_19?(); end

  def maglev_1?(); end

  def maglev_20?(); end

  def maglev_21?(); end

  def maglev_22?(); end

  def maglev_23?(); end

  def maglev_24?(); end

  def maglev_25?(); end

  def maglev_26?(); end

  def maglev_27?(); end

  def maglev_2?(); end

  def mingw?(); end

  def mingw_18?(); end

  def mingw_19?(); end

  def mingw_1?(); end

  def mingw_20?(); end

  def mingw_21?(); end

  def mingw_22?(); end

  def mingw_23?(); end

  def mingw_24?(); end

  def mingw_25?(); end

  def mingw_26?(); end

  def mingw_27?(); end

  def mingw_2?(); end

  def mri?(); end

  def mri_18?(); end

  def mri_19?(); end

  def mri_1?(); end

  def mri_20?(); end

  def mri_21?(); end

  def mri_22?(); end

  def mri_23?(); end

  def mri_24?(); end

  def mri_25?(); end

  def mri_26?(); end

  def mri_27?(); end

  def mri_2?(); end

  def mswin64?(); end

  def mswin64_18?(); end

  def mswin64_19?(); end

  def mswin64_1?(); end

  def mswin64_20?(); end

  def mswin64_21?(); end

  def mswin64_22?(); end

  def mswin64_23?(); end

  def mswin64_24?(); end

  def mswin64_25?(); end

  def mswin64_26?(); end

  def mswin64_27?(); end

  def mswin64_2?(); end

  def mswin?(); end

  def mswin_18?(); end

  def mswin_19?(); end

  def mswin_1?(); end

  def mswin_20?(); end

  def mswin_21?(); end

  def mswin_22?(); end

  def mswin_23?(); end

  def mswin_24?(); end

  def mswin_25?(); end

  def mswin_26?(); end

  def mswin_27?(); end

  def mswin_2?(); end

  def on_18?(); end

  def on_19?(); end

  def on_1?(); end

  def on_20?(); end

  def on_21?(); end

  def on_22?(); end

  def on_23?(); end

  def on_24?(); end

  def on_25?(); end

  def on_26?(); end

  def on_27?(); end

  def on_2?(); end

  def rbx?(); end

  def rbx_18?(); end

  def rbx_19?(); end

  def rbx_1?(); end

  def rbx_20?(); end

  def rbx_21?(); end

  def rbx_22?(); end

  def rbx_23?(); end

  def rbx_24?(); end

  def rbx_25?(); end

  def rbx_26?(); end

  def rbx_27?(); end

  def rbx_2?(); end

  def ruby?(); end

  def ruby_18?(); end

  def ruby_19?(); end

  def ruby_1?(); end

  def ruby_20?(); end

  def ruby_21?(); end

  def ruby_22?(); end

  def ruby_23?(); end

  def ruby_24?(); end

  def ruby_25?(); end

  def ruby_26?(); end

  def ruby_27?(); end

  def ruby_2?(); end

  def truffleruby?(); end

  def truffleruby_18?(); end

  def truffleruby_19?(); end

  def truffleruby_1?(); end

  def truffleruby_20?(); end

  def truffleruby_21?(); end

  def truffleruby_22?(); end

  def truffleruby_23?(); end

  def truffleruby_24?(); end

  def truffleruby_25?(); end

  def truffleruby_26?(); end

  def truffleruby_27?(); end

  def truffleruby_2?(); end

  def x64_mingw?(); end

  def x64_mingw_18?(); end

  def x64_mingw_19?(); end

  def x64_mingw_1?(); end

  def x64_mingw_20?(); end

  def x64_mingw_21?(); end

  def x64_mingw_22?(); end

  def x64_mingw_23?(); end

  def x64_mingw_24?(); end

  def x64_mingw_25?(); end

  def x64_mingw_26?(); end

  def x64_mingw_27?(); end

  def x64_mingw_2?(); end
  KNOWN_MAJOR_VERSIONS = ::T.let(nil, ::T.untyped)
  KNOWN_MINOR_VERSIONS = ::T.let(nil, ::T.untyped)
  KNOWN_PLATFORMS = ::T.let(nil, ::T.untyped)
end

class Bundler::CurrentRuby
end

class Bundler::CyclicDependencyError
  def status_code(); end
end

class Bundler::CyclicDependencyError
end

class Bundler::Definition
  include ::Bundler::GemHelpers
  def add_current_platform(); end

  def add_platform(platform); end

  def current_dependencies(); end

  def dependencies(); end

  def ensure_equivalent_gemfile_and_lockfile(explicit_flag=T.unsafe(nil)); end

  def find_indexed_specs(current_spec); end

  def find_resolved_spec(current_spec); end

  def gem_version_promoter(); end

  def gemfiles(); end

  def groups(); end

  def has_local_dependencies?(); end

  def has_rubygems_remotes?(); end

  def index(); end

  def initialize(lockfile, dependencies, sources, unlock, ruby_version=T.unsafe(nil), optional_groups=T.unsafe(nil), gemfiles=T.unsafe(nil)); end

  def lock(file, preserve_unknown_sections=T.unsafe(nil)); end

  def locked_bundler_version(); end

  def locked_deps(); end

  def locked_gems(); end

  def locked_ruby_version(); end

  def locked_ruby_version_object(); end

  def lockfile(); end

  def missing_specs(); end

  def missing_specs?(); end

  def new_platform?(); end

  def new_specs(); end

  def nothing_changed?(); end

  def platforms(); end

  def remove_platform(platform); end

  def removed_specs(); end

  def requested_specs(); end

  def requires(); end

  def resolve(); end

  def resolve_remotely!(); end

  def resolve_with_cache!(); end

  def ruby_version(); end

  def spec_git_paths(); end

  def specs(); end

  def specs_for(groups); end

  def to_lock(); end

  def unlocking?(); end

  def validate_platforms!(); end

  def validate_ruby!(); end

  def validate_runtime!(); end
end

class Bundler::Definition
  def self.build(gemfile, lockfile, unlock); end
end

class Bundler::DepProxy
  def ==(other); end

  def __platform(); end

  def dep(); end

  def eql?(other); end

  def initialize(dep, platform); end

  def name(); end

  def requirement(); end

  def type(); end
end

class Bundler::DepProxy
end

class Bundler::Dependency
  def autorequire(); end

  def branch(); end

  def current_env?(); end

  def current_platform?(); end

  def expanded_platforms(); end

  def gem_platforms(valid_platforms); end

  def gemfile(); end

  def git(); end

  def initialize(name, version, options=T.unsafe(nil), &blk); end

  def platforms(); end

  def should_include?(); end
  PLATFORM_MAP = ::T.let(nil, ::T.untyped)
  REVERSE_PLATFORM_MAP = ::T.let(nil, ::T.untyped)
end

class Bundler::Dependency
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::DeprecatedError
  def status_code(); end
end

class Bundler::DeprecatedError
end

class Bundler::Dsl
  include ::Bundler::RubyDsl
  def dependencies(); end

  def dependencies=(dependencies); end

  def env(name); end

  def eval_gemfile(gemfile, contents=T.unsafe(nil)); end

  def gem(name, *args); end

  def gemspec(opts=T.unsafe(nil)); end

  def gemspecs(); end

  def git(uri, options=T.unsafe(nil), &blk); end

  def git_source(name, &block); end

  def github(repo, options=T.unsafe(nil)); end

  def group(*args, &blk); end

  def install_if(*args); end

  def method_missing(name, *args); end

  def path(path, options=T.unsafe(nil), &blk); end

  def platform(*platforms); end

  def platforms(*platforms); end

  def plugin(*args); end

  def source(source, *args, &blk); end

  def to_definition(lockfile, unlock); end
  VALID_KEYS = ::T.let(nil, ::T.untyped)
  VALID_PLATFORMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Dsl::DSLError
  def contents(); end

  def description(); end

  def dsl_path(); end

  def initialize(description, dsl_path, backtrace, contents=T.unsafe(nil)); end
end

class Bundler::Dsl::DSLError
end

class Bundler::Dsl
  def self.evaluate(gemfile, lockfile, unlock); end
end

class Bundler::EndpointSpecification
  def __swap__(spec); end

  def _local_specification(); end

  def checksum(); end

  def dependencies=(dependencies); end

  def fetch_platform(); end

  def initialize(name, version, platform, dependencies, metadata=T.unsafe(nil)); end
  ILLFORMED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Bundler::EndpointSpecification
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def backup(); end

  def initialize(env, keys); end

  def restore(); end
  BUNDLER_KEYS = ::T.let(nil, ::T.untyped)
  BUNDLER_PREFIX = ::T.let(nil, ::T.untyped)
  INTENTIONALLY_NIL = ::T.let(nil, ::T.untyped)
end

class Bundler::EnvironmentPreserver
end

class Bundler::FeatureFlag
  def allow_bundler_dependency_conflicts?(); end

  def allow_offline_install?(); end

  def auto_clean_without_path?(); end

  def auto_config_jobs?(); end

  def bundler_10_mode?(); end

  def bundler_1_mode?(); end

  def bundler_2_mode?(); end

  def bundler_3_mode?(); end

  def bundler_4_mode?(); end

  def bundler_5_mode?(); end

  def bundler_6_mode?(); end

  def bundler_7_mode?(); end

  def bundler_8_mode?(); end

  def bundler_9_mode?(); end

  def cache_all?(); end

  def default_cli_command(); end

  def default_install_uses_path?(); end

  def deployment_means_frozen?(); end

  def disable_multisource?(); end

  def forget_cli_options?(); end

  def global_gem_cache?(); end

  def initialize(bundler_version); end

  def only_update_to_newer_versions?(); end

  def path_relative_to_cwd?(); end

  def plugins?(); end

  def print_only_version_number?(); end

  def setup_makes_kernel_gem_public?(); end

  def skip_default_git_sources?(); end

  def specific_platform?(); end

  def suppress_install_using_messages?(); end

  def unlock_source_unlocks_spec?(); end

  def update_requires_all_flag?(); end

  def use_gem_version_promoter_for_major_updates?(); end
end

class Bundler::FeatureFlag
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationRequiredError
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CertificateFailureError
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::SSLError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  include ::Bundler::FileUtils::StreamUtils_
  LOW_METHODS = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  OPT_TABLE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Bundler::FileUtils::DryRun
  include ::Bundler::FileUtils
  include ::Bundler::FileUtils::StreamUtils_
  include ::Bundler::FileUtils::LowMethods
end

module Bundler::FileUtils::DryRun
  extend ::Bundler::FileUtils::DryRun
  extend ::Bundler::FileUtils
  extend ::Bundler::FileUtils::StreamUtils_
  extend ::Bundler::FileUtils::LowMethods
end

class Bundler::FileUtils::Entry_
  include ::Bundler::FileUtils::StreamUtils_
  def blockdev?(); end

  def chardev?(); end

  def chmod(mode); end

  def chown(uid, gid); end

  def copy(dest); end

  def copy_file(dest); end

  def copy_metadata(path); end

  def dereference?(); end

  def directory?(); end

  def door?(); end

  def entries(); end

  def exist?(); end

  def file?(); end

  def initialize(a, b=T.unsafe(nil), deref=T.unsafe(nil)); end

  def link(dest); end

  def lstat(); end

  def lstat!(); end

  def path(); end

  def pipe?(); end

  def platform_support(); end

  def postorder_traverse(); end

  def prefix(); end

  def preorder_traverse(); end

  def rel(); end

  def remove(); end

  def remove_dir1(); end

  def remove_file(); end

  def socket?(); end

  def stat(); end

  def stat!(); end

  def symlink?(); end

  def traverse(); end

  def wrap_traverse(pre, post); end
  DIRECTORY_TERM = ::T.let(nil, ::T.untyped)
  S_IF_DOOR = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
end

module Bundler::FileUtils::LowMethods
end

module Bundler::FileUtils::LowMethods
end

module Bundler::FileUtils::NoWrite
  include ::Bundler::FileUtils
  include ::Bundler::FileUtils::StreamUtils_
  include ::Bundler::FileUtils::LowMethods
end

module Bundler::FileUtils::NoWrite
  extend ::Bundler::FileUtils::NoWrite
  extend ::Bundler::FileUtils
  extend ::Bundler::FileUtils::StreamUtils_
  extend ::Bundler::FileUtils::LowMethods
end

module Bundler::FileUtils::StreamUtils_
end

module Bundler::FileUtils::StreamUtils_
end

module Bundler::FileUtils::Verbose
  include ::Bundler::FileUtils
  include ::Bundler::FileUtils::StreamUtils_
end

module Bundler::FileUtils::Verbose
  extend ::Bundler::FileUtils::Verbose
  extend ::Bundler::FileUtils
  extend ::Bundler::FileUtils::StreamUtils_
end

module Bundler::FileUtils
  extend ::Bundler::FileUtils::StreamUtils_
  def self.cd(dir, verbose: T.unsafe(nil), &block); end

  def self.chdir(dir, verbose: T.unsafe(nil), &block); end

  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.cmp(a, b); end

  def self.collect_method(opt); end

  def self.commands(); end

  def self.compare_file(a, b); end

  def self.compare_stream(a, b); end

  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.copy_entry(src, dest, preserve=T.unsafe(nil), dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.copy_file(src, dest, preserve=T.unsafe(nil), dereference=T.unsafe(nil)); end

  def self.copy_stream(src, dest); end

  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.cp_r(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.getwd(); end

  def self.have_option?(mid, opt); end

  def self.identical?(a, b); end

  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkdir_p(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.options(); end

  def self.options_of(mid); end

  def self.private_module_function(name); end

  def self.pwd(); end

  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.remove_dir(path, force=T.unsafe(nil)); end

  def self.remove_entry(path, force=T.unsafe(nil)); end

  def self.remove_entry_secure(path, force=T.unsafe(nil)); end

  def self.remove_file(path, force=T.unsafe(nil)); end

  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_r(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.touch(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), mtime: T.unsafe(nil), nocreate: T.unsafe(nil)); end

  def self.uptodate?(new, old_list); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

module Bundler::GemHelpers
  GENERICS = ::T.let(nil, ::T.untyped)
  GENERIC_CACHE = ::T.let(nil, ::T.untyped)
end

class Bundler::GemHelpers::PlatformMatch
  def cpu_match(); end

  def cpu_match=(_); end

  def os_match(); end

  def os_match=(_); end

  def platform_version_match(); end

  def platform_version_match=(_); end
  EXACT_MATCH = ::T.let(nil, ::T.untyped)
  WORST_MATCH = ::T.let(nil, ::T.untyped)
end

class Bundler::GemHelpers::PlatformMatch
  def self.[](*_); end

  def self.cpu_match(spec_platform, user_platform); end

  def self.members(); end

  def self.os_match(spec_platform, user_platform); end

  def self.platform_version_match(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.generic(p); end

  def self.generic_local_platform(); end

  def self.platform_specificity_match(spec_platform, user_platform); end

  def self.select_best_platform_match(specs, platform); end
end

class Bundler::GemNotFound
  def status_code(); end
end

class Bundler::GemNotFound
end

class Bundler::GemRequireError
  def initialize(orig_exception, msg); end

  def orig_exception(); end

  def status_code(); end
end

class Bundler::GemRequireError
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::GemfileError
  def status_code(); end
end

class Bundler::GemfileError
end

class Bundler::GemfileEvalError
end

class Bundler::GemfileEvalError
end

class Bundler::GemfileLockNotFound
  def status_code(); end
end

class Bundler::GemfileLockNotFound
end

class Bundler::GemfileNotFound
  def status_code(); end
end

class Bundler::GemfileNotFound
end

class Bundler::GemspecError
  def status_code(); end
end

class Bundler::GemspecError
end

class Bundler::GenericSystemCallError
  def initialize(underlying_error, message); end

  def status_code(); end

  def underlying_error(); end
end

class Bundler::GenericSystemCallError
end

class Bundler::GitError
  def status_code(); end
end

class Bundler::GitError
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::HTTPError
  def filter_uri(uri); end

  def status_code(); end
end

class Bundler::HTTPError
end

class Bundler::Index
  include ::Enumerable
  def <<(spec); end

  def ==(other); end

  def [](query, base=T.unsafe(nil)); end

  def add_source(index); end

  def all_specs(); end

  def dependencies_eql?(spec, other_spec); end

  def dependency_names(); end

  def each(&blk); end

  def empty?(); end

  def local_search(query, base=T.unsafe(nil)); end

  def search(query, base=T.unsafe(nil)); end

  def search_all(name); end

  def size(); end

  def sort_specs(specs); end

  def sources(); end

  def spec_names(); end

  def specs(); end

  def unmet_dependency_names(); end

  def unsorted_search(query, base); end

  def use(other, override_dupes=T.unsafe(nil)); end
  EMPTY_SEARCH = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

class Bundler::Index
  def self.build(); end

  def self.sort_specs(specs); end
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::InstallError
  def status_code(); end
end

class Bundler::InstallError
end

class Bundler::InstallHookError
  def status_code(); end
end

class Bundler::InstallHookError
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::InvalidOption
  def status_code(); end
end

class Bundler::InvalidOption
end

class Bundler::LazySpecification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def ==(other); end

  def __materialize__(); end

  def dependencies(); end

  def full_name(); end

  def git_version(); end

  def identifier(); end

  def initialize(name, version, platform, source=T.unsafe(nil)); end

  def name(); end

  def platform(); end

  def remote(); end

  def remote=(remote); end

  def respond_to?(*args); end

  def satisfies?(dependency); end

  def source(); end

  def source=(source); end

  def to_lock(); end

  def version(); end
end

class Bundler::LazySpecification::Identifier
  include ::Comparable
  def dependencies(); end

  def dependencies=(_); end

  def name(); end

  def name=(_); end

  def platform(); end

  def platform=(_); end

  def platform_string(); end

  def source(); end

  def source=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::LazySpecification::Identifier
  def self.[](*_); end

  def self.members(); end
end

class Bundler::LazySpecification
end

class Bundler::LockfileError
  def status_code(); end
end

class Bundler::LockfileError
end

class Bundler::LockfileGenerator
  def definition(); end

  def generate!(); end

  def initialize(definition); end

  def out(); end
end

class Bundler::LockfileGenerator
  def self.generate(definition); end
end

class Bundler::LockfileParser
  def bundler_version(); end

  def dependencies(); end

  def initialize(lockfile); end

  def platforms(); end

  def ruby_version(); end

  def sources(); end

  def specs(); end

  def warn_for_outdated_bundler_version(); end
  BUNDLED = ::T.let(nil, ::T.untyped)
  DEPENDENCIES = ::T.let(nil, ::T.untyped)
  ENVIRONMENT_VERSION_SECTIONS = ::T.let(nil, ::T.untyped)
  GEM = ::T.let(nil, ::T.untyped)
  GIT = ::T.let(nil, ::T.untyped)
  KNOWN_SECTIONS = ::T.let(nil, ::T.untyped)
  NAME_VERSION = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PLATFORMS = ::T.let(nil, ::T.untyped)
  PLUGIN = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
  SECTIONS_BY_VERSION_INTRODUCED = ::T.let(nil, ::T.untyped)
  SOURCE = ::T.let(nil, ::T.untyped)
  SPECS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::LockfileParser
  def self.sections_in_lockfile(lockfile_contents); end

  def self.sections_to_ignore(base_version=T.unsafe(nil)); end

  def self.unknown_sections_in_lockfile(lockfile_contents); end
end

class Bundler::MarshalError
end

class Bundler::MarshalError
end

module Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def match_platform(p); end
end

module Bundler::MatchPlatform
  def self.platforms_match?(gemspec_platform, local_platform); end
end

module Bundler::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(vertices); end
end

class Bundler::Molinillo::CircularDependencyError
end

module Bundler::Molinillo::Compatibility
end

module Bundler::Molinillo::Compatibility
  def self.flat_map(enum, &blk); end
end

module Bundler::Molinillo::Delegates
end

module Bundler::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end

  def unused_unwind_options(); end
end

module Bundler::Molinillo::Delegates::ResolutionState
end

module Bundler::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Bundler::Molinillo::Delegates::SpecificationProvider
end

module Bundler::Molinillo::Delegates
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
  include ::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(&blk); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Bundler::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(_); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Bundler::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Bundler::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Bundler::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Bundler::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Bundler::Molinillo::DependencyGraph::AddVertex
end

class Bundler::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Bundler::Molinillo::DependencyGraph::DeleteEdge
end

class Bundler::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Bundler::Molinillo::DependencyGraph::DetachVertexNamed
end

class Bundler::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Bundler::Molinillo::DependencyGraph::Edge
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Bundler::Molinillo::DependencyGraph::SetPayload
end

class Bundler::Molinillo::DependencyGraph::Tag
  def down(_graph); end

  def initialize(tag); end

  def tag(); end

  def up(_graph); end
end

class Bundler::Molinillo::DependencyGraph::Tag
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def _path_to?(other, visited=T.unsafe(nil)); end

  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Bundler::Molinillo::DependencyGraph::Vertex
end

class Bundler::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Bundler::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Bundler::Molinillo::DependencyState
end

class Bundler::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Bundler::Molinillo::NoSuchDependencyError
end

class Bundler::Molinillo::PossibilityState
end

class Bundler::Molinillo::PossibilityState
end

class Bundler::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end

  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Bundler::Molinillo::ResolutionState
  def self.[](*_); end

  def self.empty(); end

  def self.members(); end
end

class Bundler::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Bundler::Molinillo::Resolver::Resolution
  include ::Bundler::Molinillo::Delegates::ResolutionState
  include ::Bundler::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Bundler::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility_set(); end

  def possibility_set=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Bundler::Molinillo::Resolver::Resolution::Conflict
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Bundler::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Bundler::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Molinillo::Resolver::Resolution
end

class Bundler::Molinillo::Resolver
end

class Bundler::Molinillo::ResolverError
end

class Bundler::Molinillo::ResolverError
end

module Bundler::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Bundler::Molinillo::SpecificationProvider
end

module Bundler::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Bundler::Molinillo::UI
end

class Bundler::Molinillo::VersionConflict
  include ::Bundler::Molinillo::Delegates::SpecificationProvider
  def conflicts(); end

  def initialize(conflicts, specification_provider); end

  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Bundler::Molinillo::VersionConflict
end

module Bundler::Molinillo
end

class Bundler::NoSpaceOnDeviceError
end

class Bundler::NoSpaceOnDeviceError
end

class Bundler::OperationNotSupportedError
end

class Bundler::OperationNotSupportedError
end

class Bundler::PathError
  def status_code(); end
end

class Bundler::PathError
end

class Bundler::PermissionError
  def action(); end

  def initialize(path, permission_type=T.unsafe(nil)); end

  def status_code(); end
end

class Bundler::PermissionError
end

module Bundler::Plugin
  PLUGIN_FILE_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::API
  def cache_dir(); end

  def method_missing(name, *args, &blk); end

  def tmp(*names); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

class Bundler::Plugin::API
  def self.command(command, cls=T.unsafe(nil)); end

  def self.hook(event, &block); end

  def self.source(source, cls=T.unsafe(nil)); end
end

class Bundler::Plugin::DSL
  def _gem(name, *args); end

  def inferred_plugins(); end

  def plugin(name, *args); end
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

module Bundler::Plugin::Events
  def self.defined_event?(event); end
end

class Bundler::Plugin::Index
  def command_plugin(command); end

  def commands(); end

  def global_index_file(); end

  def hook_plugins(event); end

  def index_file(); end

  def installed?(name); end

  def installed_plugins(); end

  def load_paths(name); end

  def local_index_file(); end

  def plugin_commands(plugin); end

  def plugin_path(name); end

  def register_plugin(name, path, load_paths, commands, sources, hooks); end

  def source?(source); end

  def source_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Index
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::MalformattedPlugin
end

class Bundler::Plugin::MalformattedPlugin
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::UndefinedCommandError
end

class Bundler::Plugin::UndefinedCommandError
end

class Bundler::Plugin::UnknownSourceError
end

class Bundler::Plugin::UnknownSourceError
end

module Bundler::Plugin
  def self.add_command(command, cls); end

  def self.add_hook(event, &block); end

  def self.add_source(source, cls); end

  def self.cache(); end

  def self.command?(command); end

  def self.exec_command(command, args); end

  def self.gemfile_install(gemfile=T.unsafe(nil), &inline); end

  def self.global_root(); end

  def self.hook(event, *args, &arg_blk); end

  def self.index(); end

  def self.install(names, options); end

  def self.installed?(plugin); end

  def self.list(); end

  def self.local_root(); end

  def self.reset!(); end

  def self.root(); end

  def self.source(name); end

  def self.source?(name); end

  def self.source_from_lock(locked_opts); end
end

class Bundler::PluginError
  def status_code(); end
end

class Bundler::PluginError
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::ProductionError
  def status_code(); end
end

class Bundler::ProductionError
end

class Bundler::RemoteSpecification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  include ::Comparable
  def __swap__(spec); end

  def dependencies(); end

  def dependencies=(dependencies); end

  def fetch_platform(); end

  def full_name(); end

  def git_version(); end

  def initialize(name, version, platform, spec_fetcher); end

  def name(); end

  def platform(); end

  def remote(); end

  def remote=(remote); end

  def respond_to?(method, include_all=T.unsafe(nil)); end

  def sort_obj(); end

  def source(); end

  def source=(source); end

  def version(); end
end

class Bundler::RemoteSpecification
end

class Bundler::Resolver
  include ::Bundler::Molinillo::UI
  include ::Bundler::Molinillo::SpecificationProvider
  def index_for(dependency); end

  def initialize(index, source_requirements, base, gem_version_promoter, additional_base_requirements, platforms); end

  def relevant_sources_for_vertex(vertex); end

  def start(requirements); end
end

class Bundler::Resolver::SpecGroup
  include ::Bundler::GemHelpers
  def ==(other); end

  def activate_platform!(platform); end

  def dependencies_for_activated_platforms(); end

  def eql?(other); end

  def for?(platform); end

  def ignores_bundler_dependencies(); end

  def ignores_bundler_dependencies=(ignores_bundler_dependencies); end

  def initialize(all_specs); end

  def name(); end

  def name=(name); end

  def source(); end

  def source=(source); end

  def to_specs(); end

  def version(); end

  def version=(version); end
end

class Bundler::Resolver::SpecGroup
end

class Bundler::Resolver
  def self.platform_sort_key(platform); end

  def self.resolve(requirements, index, source_requirements=T.unsafe(nil), base=T.unsafe(nil), gem_version_promoter=T.unsafe(nil), additional_base_requirements=T.unsafe(nil), platforms=T.unsafe(nil)); end

  def self.sort_platforms(platforms); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  def ruby(*ruby_version); end
end

module Bundler::RubyDsl
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyVersion
  def ==(other); end

  def diff(other); end

  def engine(); end

  def engine_gem_version(); end

  def engine_versions(); end

  def exact?(); end

  def gem_version(); end

  def host(); end

  def initialize(versions, patchlevel, engine, engine_version); end

  def patchlevel(); end

  def single_version_string(); end

  def to_gem_version_with_patchlevel(); end

  def to_s(versions=T.unsafe(nil)); end

  def versions(); end

  def versions_string(versions); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class Bundler::RubyVersion
  def self.from_string(string); end

  def self.system(); end
end

class Bundler::RubyVersionMismatch
  def status_code(); end
end

class Bundler::RubyVersionMismatch
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_base_dir(); end

  def backport_cache_file(); end

  def backport_ext_builder_monitor(); end

  def backport_spec_file(); end

  def bin_path(gem, bin, ver); end

  def build(spec, skip_validation=T.unsafe(nil)); end

  def build_args(); end

  def build_args=(args); end

  def build_gem(gem_dir, spec); end

  def clear_paths(); end

  def configuration(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def download_gem(spec, uri, path); end

  def ext_lock(); end

  def fetch_all_remote_specs(remote); end

  def fetch_specs(remote, name); end

  def find_name(name); end

  def gem_bindir(); end

  def gem_cache(); end

  def gem_dir(); end

  def gem_from_path(path, policy=T.unsafe(nil)); end

  def gem_path(); end

  def gem_remote_fetcher(); end

  def inflate(obj); end

  def install_with_build_args(args); end

  def load_plugin_files(files); end

  def load_plugins(); end

  def loaded_gem_paths(); end

  def loaded_specs(name); end

  def mark_loaded(spec); end

  def marshal_spec_dir(); end

  def method_visibility(klass, method); end

  def path(obj); end

  def path_separator(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def platforms(); end

  def post_reset_hooks(); end

  def preserve_paths(); end

  def provides?(req_str); end

  def read_binary(path); end

  def redefine_method(klass, method, unbound_method=T.unsafe(nil), &block); end

  def replace_bin_path(specs_by_name); end

  def replace_entrypoints(specs); end

  def replace_gem(specs, specs_by_name); end

  def repository_subdirectories(); end

  def reset(); end

  def reverse_rubygems_kernel_mixin(); end

  def ruby_engine(); end

  def security_policies(); end

  def security_policy_keys(); end

  def set_installed_by_version(spec, installed_by_version=T.unsafe(nil)); end

  def sources(); end

  def sources=(val); end

  def spec_cache_dirs(); end

  def spec_default_gem?(spec); end

  def spec_extension_dir(spec); end

  def spec_from_gem(path, policy=T.unsafe(nil)); end

  def spec_matches_for_glob(spec, glob); end

  def spec_missing_extensions?(spec, default=T.unsafe(nil)); end

  def stub_rubygems(specs); end

  def stub_set_spec(stub, spec); end

  def suffix_pattern(); end

  def ui=(obj); end

  def undo_replacements(); end

  def use_gemdeps(gemfile); end

  def user_home(); end

  def validate(spec); end

  def version(); end

  def with_build_args(args); end
  EXT_LOCK = ::T.let(nil, ::T.untyped)
end

class Bundler::RubygemsIntegration
  def self.provides?(req_str); end

  def self.version(); end
end

class Bundler::Runtime
  include ::Bundler::SharedHelpers
  def cache(custom_path=T.unsafe(nil)); end

  def clean(dry_run=T.unsafe(nil)); end

  def current_dependencies(); end

  def dependencies(); end

  def gems(); end

  def initialize(root, definition); end

  def lock(opts=T.unsafe(nil)); end

  def prune_cache(cache_path); end

  def requested_specs(); end

  def require(*groups); end

  def requires(); end

  def setup(*groups); end

  def specs(); end
  REQUIRE_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Runtime
end

class Bundler::SecurityError
  def status_code(); end
end

class Bundler::SecurityError
end

class Bundler::Settings
  def [](name); end

  def all(); end

  def allow_sudo?(); end

  def app_cache_path(); end

  def credentials_for(uri); end

  def gem_mirrors(); end

  def ignore_config?(); end

  def initialize(root=T.unsafe(nil)); end

  def key_for(key); end

  def local_overrides(); end

  def locations(key); end

  def mirror_for(uri); end

  def path(); end

  def pretty_values_for(exposed_key); end

  def set_command_option(key, value); end

  def set_command_option_if_given(key, value); end

  def set_global(key, value); end

  def set_local(key, value); end

  def temporary(update); end

  def validate!(); end
  ARRAY_KEYS = ::T.let(nil, ::T.untyped)
  BOOL_KEYS = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  NORMALIZE_URI_OPTIONS_PATTERN = ::T.let(nil, ::T.untyped)
  NUMBER_KEYS = ::T.let(nil, ::T.untyped)
  PER_URI_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def base_path(); end

  def base_path_relative_to_pwd(); end

  def default_install_uses_path(); end

  def default_install_uses_path=(_); end

  def explicit_path(); end

  def explicit_path=(_); end

  def path(); end

  def system_path(); end

  def system_path=(_); end

  def use_system_gems?(); end

  def validate!(); end
end

class Bundler::Settings::Path
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.normalize_uri(uri); end
end

module Bundler::SharedHelpers
  def chdir(dir, &blk); end

  def const_get_safely(constant_name, namespace); end

  def default_bundle_dir(); end

  def default_gemfile(); end

  def default_lockfile(); end

  def digest(name); end

  def ensure_same_dependencies(spec, old_deps, new_deps); end

  def filesystem_access(path, action=T.unsafe(nil), &block); end

  def in_bundle?(); end

  def major_deprecation(major_version, message, print_caller_location: T.unsafe(nil)); end

  def md5_available?(); end

  def pretty_dependency(dep, print_source=T.unsafe(nil)); end

  def print_major_deprecations!(); end

  def pwd(); end

  def root(); end

  def set_bundle_environment(); end

  def set_env(key, value); end

  def trap(signal, override=T.unsafe(nil), &block); end

  def with_clean_git_env(&block); end

  def write_to_gemfile(gemfile_path, contents); end
end

module Bundler::SharedHelpers
  extend ::Bundler::SharedHelpers
end

class Bundler::Source
  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def dependency_names_to_double_check(); end

  def double_check_for(*_); end

  def extension_cache_path(spec); end

  def include?(other); end

  def path?(); end

  def unmet_deps(); end

  def version_message(spec); end
end

class Bundler::Source::Gemspec
  def as_path_source(); end

  def gemspec(); end
end

class Bundler::Source::Gemspec
end

class Bundler::Source::Git
  def allow_git_ops?(); end

  def branch(); end

  def cache_path(); end

  def extension_dir_name(); end

  def glob(); end

  def install_path(); end

  def local_override!(path); end

  def ref(); end

  def revision(); end

  def specs(*_); end

  def submodules(); end

  def unlock!(); end

  def uri(); end
end

class Bundler::Source::Git
end

class Bundler::Source::Metadata
  def ==(other); end

  def cached!(); end

  def eql?(other); end

  def install(spec, _opts=T.unsafe(nil)); end

  def options(); end

  def remote!(); end

  def specs(); end
end

class Bundler::Source::Metadata
end

class Bundler::Source::Path
  def ==(other); end

  def app_cache_dirname(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def eql?(other); end

  def expanded_original_path(); end

  def initialize(options); end

  def install(spec, options=T.unsafe(nil)); end

  def local_specs(*_); end

  def name(); end

  def name=(name); end

  def options(); end

  def original_path(); end

  def path(); end

  def remote!(); end

  def root(); end

  def root_path(); end

  def specs(); end

  def to_lock(); end

  def version(); end

  def version=(version); end
  DEFAULT_GLOB = ::T.let(nil, ::T.untyped)
end

class Bundler::Source::Path
  def self.from_lock(options); end
end

class Bundler::Source::Rubygems
  def ==(other); end

  def add_remote(source); end

  def api_fetchers(); end

  def builtin_gem?(spec); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cache_path(); end

  def cached!(); end

  def cached_built_in_gem(spec); end

  def cached_gem(spec); end

  def cached_path(spec); end

  def cached_specs(); end

  def caches(); end

  def credless_remotes(); end

  def double_check_for(unmet_dependency_names); end

  def eql?(other); end

  def equivalent_remotes?(other_remotes); end

  def fetch_gem(spec); end

  def fetch_names(fetchers, dependency_names, index, override_dupes); end

  def fetchers(); end

  def include?(o); end

  def initialize(options=T.unsafe(nil)); end

  def install(spec, opts=T.unsafe(nil)); end

  def installed?(spec); end

  def installed_specs(); end

  def loaded_from(spec); end

  def name(); end

  def normalize_uri(uri); end

  def options(); end

  def remote!(); end

  def remote_specs(); end

  def remotes(); end

  def remotes_for_spec(spec); end

  def remove_auth(remote); end

  def replace_remotes(other_remotes, allow_equivalent=T.unsafe(nil)); end

  def requires_sudo?(); end

  def rubygems_dir(); end

  def specs(); end

  def suppress_configured_credentials(remote); end

  def to_lock(); end
  API_REQUEST_LIMIT = ::T.let(nil, ::T.untyped)
  API_REQUEST_SIZE = ::T.let(nil, ::T.untyped)
end

class Bundler::Source::Rubygems
  def self.from_lock(options); end
end

class Bundler::Source
end

class Bundler::SourceList
  def add_git_source(options=T.unsafe(nil)); end

  def add_path_source(options=T.unsafe(nil)); end

  def add_plugin_source(source, options=T.unsafe(nil)); end

  def add_rubygems_remote(uri); end

  def add_rubygems_source(options=T.unsafe(nil)); end

  def all_sources(); end

  def cached!(); end

  def default_source(); end

  def get(source); end

  def git_sources(); end

  def global_rubygems_source(); end

  def global_rubygems_source=(uri); end

  def lock_sources(); end

  def metadata_source(); end

  def path_sources(); end

  def plugin_sources(); end

  def remote!(); end

  def replace_sources!(replacement_sources); end

  def rubygems_primary_remotes(); end

  def rubygems_remotes(); end

  def rubygems_sources(); end
end

class Bundler::SourceList
end

class Bundler::SpecSet
  include ::Enumerable
  include ::TSort
  def <<(spec); end

  def [](key); end

  def []=(key, value); end

  def each(&b); end

  def empty?(); end

  def find_by_name_and_platform(name, platform); end

  def for(dependencies, skip=T.unsafe(nil), check=T.unsafe(nil), match_current_platform=T.unsafe(nil), raise_on_missing=T.unsafe(nil)); end

  def initialize(specs); end

  def length(); end

  def materialize(deps, missing_specs=T.unsafe(nil)); end

  def materialized_for_all_platforms(); end

  def merge(set); end

  def size(); end

  def sort!(); end

  def to_a(); end

  def to_hash(); end

  def valid_for?(deps); end

  def what_required(spec); end
end

class Bundler::SpecSet
end

class Bundler::StubSpecification
  def activated(); end

  def activated=(activated); end

  def default_gem(); end

  def full_gem_path(); end

  def full_require_paths(); end

  def ignored(); end

  def ignored=(ignored); end

  def load_paths(); end

  def loaded_from(); end

  def matches_for_glob(glob); end

  def missing_extensions?(); end

  def raw_require_paths(); end

  def source=(source); end

  def stub(); end

  def stub=(stub); end

  def to_yaml(); end
end

class Bundler::StubSpecification
  def self.from_stub(stub); end
end

class Bundler::SudoNotPermittedError
  def status_code(); end
end

class Bundler::SudoNotPermittedError
end

class Bundler::TemporaryResourceError
end

class Bundler::TemporaryResourceError
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::ThreadCreationError
  def status_code(); end
end

class Bundler::ThreadCreationError
end

module Bundler::UI
end

class Bundler::UI::RGProxy
  def initialize(ui); end

  def say(message); end
end

class Bundler::UI::RGProxy
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

class Bundler::UI::Silent
  def add_color(string, color); end

  def ask(message); end

  def confirm(message, newline=T.unsafe(nil)); end

  def debug(message, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(message, newline=T.unsafe(nil)); end

  def info(message, newline=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(name); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(); end

  def trace(message, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(message, newline=T.unsafe(nil)); end

  def yes?(msg); end
end

class Bundler::UI::Silent
end

module Bundler::UI
end

module Bundler::URICredentialsFilter
end

module Bundler::URICredentialsFilter
  def self.credential_filtered_string(str_to_filter, uri); end

  def self.credential_filtered_uri(uri_to_anonymize); end
end

class Bundler::VersionConflict
  def conflicts(); end

  def initialize(conflicts, msg=T.unsafe(nil)); end

  def status_code(); end
end

class Bundler::VersionConflict
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

class Bundler::VirtualProtocolError
  def status_code(); end
end

class Bundler::VirtualProtocolError
end

class Bundler::YamlSyntaxError
  def initialize(orig_exception, msg); end

  def orig_exception(); end

  def status_code(); end
end

class Bundler::YamlSyntaxError
end

module Bundler
  def self.app_cache(custom_path=T.unsafe(nil)); end

  def self.app_config_path(); end

  def self.bin_path(); end

  def self.bundle_path(); end

  def self.bundler_major_version(); end

  def self.clean_env(); end

  def self.clean_exec(*args); end

  def self.clean_system(*args); end

  def self.clear_gemspec_cache(); end

  def self.configure(); end

  def self.configured_bundle_path(); end

  def self.current_ruby(); end

  def self.default_bundle_dir(); end

  def self.default_gemfile(); end

  def self.default_lockfile(); end

  def self.definition(unlock=T.unsafe(nil)); end

  def self.environment(); end

  def self.feature_flag(); end

  def self.frozen_bundle?(); end

  def self.git_present?(); end

  def self.home(); end

  def self.install_path(); end

  def self.load_gemspec(file, validate=T.unsafe(nil)); end

  def self.load_gemspec_uncached(file, validate=T.unsafe(nil)); end

  def self.load_marshal(data); end

  def self.local_platform(); end

  def self.locked_gems(); end

  def self.mkdir_p(path, options=T.unsafe(nil)); end

  def self.original_env(); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.read_file(file); end

  def self.require(*groups); end

  def self.require_thor_actions(); end

  def self.requires_sudo?(); end

  def self.reset!(); end

  def self.reset_paths!(); end

  def self.reset_rubygems!(); end

  def self.rm_rf(path); end

  def self.root(); end

  def self.ruby_scope(); end

  def self.rubygems(); end

  def self.settings(); end

  def self.setup(*groups); end

  def self.specs_path(); end

  def self.sudo(str); end

  def self.system_bindir(); end

  def self.tmp(name=T.unsafe(nil)); end

  def self.ui(); end

  def self.ui=(ui); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.use_system_gems?(); end

  def self.user_bundle_path(dir=T.unsafe(nil)); end

  def self.user_cache(); end

  def self.user_home(); end

  def self.which(executable); end

  def self.with_clean_env(); end

  def self.with_original_env(); end

  def self.with_unbundled_env(); end
end

class Class
  def json_creatable?(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

class DidYouMean::Formatter
  def initialize(corrections=T.unsafe(nil)); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
end

module DidYouMean::NameErrorCheckers
  def self.included(*_); end

  def self.new(exception); end
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
end

class Dir
  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(*_); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end
end

class Enumerator
  def each_with_index(); end
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  def self.exception(*_); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def resume(*_); end
end

class Fiber
  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.empty?(_); end

  def self.exists?(_); end

  def self.mkfifo(*_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

class Foo
  def bar(); end

  def baz(); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
end

class Gem::AvailableSet
  include ::Enumerable
  def <<(o); end

  def add(spec, source); end

  def all_specs(); end

  def each(&blk); end

  def each_spec(); end

  def empty?(); end

  def find_all(req); end

  def inject_into_list(dep_list); end

  def match_platform!(); end

  def pick_best!(); end

  def prefetch(reqs); end

  def remote(); end

  def remote=(remote); end

  def remove_installed!(dep); end

  def set(); end

  def size(); end

  def sorted(); end

  def source_for(spec); end

  def to_request_set(development=T.unsafe(nil)); end
end

class Gem::AvailableSet::Tuple
  def source(); end

  def source=(_); end

  def spec(); end

  def spec=(_); end
end

class Gem::AvailableSet::Tuple
  def self.[](*_); end

  def self.members(); end
end

class Gem::AvailableSet
end

class Gem::BasicSpecification
  def activated?(); end

  def base_dir(); end

  def base_dir=(base_dir); end

  def contains_requirable_file?(file); end

  def datadir(); end

  def default_gem?(); end

  def extension_dir(); end

  def extension_dir=(extension_dir); end

  def extensions_dir(); end

  def full_gem_path(); end

  def full_gem_path=(full_gem_path); end

  def full_name(); end

  def full_require_paths(); end

  def gem_build_complete_path(); end

  def gem_dir(); end

  def gems_dir(); end

  def ignored=(ignored); end

  def internal_init(); end

  def lib_dirs_glob(); end

  def loaded_from(); end

  def loaded_from=(loaded_from); end

  def matches_for_glob(glob); end

  def name(); end

  def platform(); end

  def raw_require_paths(); end

  def require_paths(); end

  def source_paths(); end

  def stubbed?(); end

  def this(); end

  def to_fullpath(path); end

  def to_spec(); end

  def version(); end
end

class Gem::BasicSpecification
  def self.default_specifications_dir(); end
end

class Gem::Command
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def add_extra_args(args); end

  def add_option(*opts, &handler); end

  def arguments(); end

  def begins?(long, short); end

  def command(); end

  def defaults(); end

  def defaults=(defaults); end

  def defaults_str(); end

  def description(); end

  def execute(); end

  def get_all_gem_names(); end

  def get_all_gem_names_and_versions(); end

  def get_one_gem_name(); end

  def get_one_optional_argument(); end

  def handle_options(args); end

  def handles?(args); end

  def initialize(command, summary=T.unsafe(nil), defaults=T.unsafe(nil)); end

  def invoke(*args); end

  def invoke_with_build_args(args, build_args); end

  def merge_options(new_options); end

  def options(); end

  def program_name(); end

  def program_name=(program_name); end

  def remove_option(name); end

  def show_help(); end

  def show_lookup_failure(gem_name, version, errors, domain); end

  def summary(); end

  def summary=(summary); end

  def usage(); end

  def when_invoked(&block); end
  HELP = ::T.let(nil, ::T.untyped)
end

class Gem::Command
  def self.add_common_option(*args, &handler); end

  def self.add_specific_extra_args(cmd, args); end

  def self.build_args(); end

  def self.build_args=(value); end

  def self.common_options(); end

  def self.extra_args(); end

  def self.extra_args=(value); end

  def self.specific_extra_args(cmd); end

  def self.specific_extra_args_hash(); end
end

module Gem::Commands
end

module Gem::Commands
end

class Gem::ConfigFile
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def api_keys(); end

  def args(); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def bulk_threshold(); end

  def bulk_threshold=(bulk_threshold); end

  def check_credentials_permissions(); end

  def config_file_name(); end

  def credentials_path(); end

  def disable_default_gem_server(); end

  def disable_default_gem_server=(disable_default_gem_server); end

  def each(&block); end

  def handle_arguments(arg_list); end

  def home(); end

  def home=(home); end

  def initialize(args); end

  def load_api_keys(); end

  def load_file(filename); end

  def path(); end

  def path=(path); end

  def really_verbose(); end

  def rubygems_api_key(); end

  def rubygems_api_key=(api_key); end

  def set_api_key(host, api_key); end

  def sources(); end

  def sources=(sources); end

  def ssl_ca_cert(); end

  def ssl_ca_cert=(ssl_ca_cert); end

  def ssl_client_cert(); end

  def ssl_verify_mode(); end

  def to_yaml(); end

  def update_sources(); end

  def update_sources=(update_sources); end

  def verbose(); end

  def verbose=(verbose); end

  def write(); end
  DEFAULT_BACKTRACE = ::T.let(nil, ::T.untyped)
  DEFAULT_BULK_THRESHOLD = ::T.let(nil, ::T.untyped)
  DEFAULT_UPDATE_SOURCES = ::T.let(nil, ::T.untyped)
  DEFAULT_VERBOSITY = ::T.let(nil, ::T.untyped)
  OPERATING_SYSTEM_DEFAULTS = ::T.let(nil, ::T.untyped)
  PLATFORM_DEFAULTS = ::T.let(nil, ::T.untyped)
  SYSTEM_CONFIG_PATH = ::T.let(nil, ::T.untyped)
  SYSTEM_WIDE_CONFIG_FILE = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
end

class Gem::ConflictError
  def conflicts(); end

  def initialize(target, conflicts); end

  def target(); end
end

class Gem::ConsoleUI
  def initialize(); end
end

class Gem::ConsoleUI
end

module Gem::DefaultUserInteraction
  def ui(); end

  def ui=(new_ui); end

  def use_ui(new_ui, &block); end
end

module Gem::DefaultUserInteraction
  def self.ui(); end

  def self.ui=(new_ui); end

  def self.use_ui(new_ui); end
end

class Gem::Dependency
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def all_sources(); end

  def all_sources=(all_sources); end

  def encode_with(coder); end

  def eql?(other); end

  def groups(); end

  def groups=(groups); end

  def initialize(name, *requirements); end

  def latest_version?(); end

  def match?(obj, version=T.unsafe(nil), allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def matching_specs(platform_only=T.unsafe(nil)); end

  def merge(other); end

  def name(); end

  def name=(name); end

  def prerelease=(prerelease); end

  def prerelease?(); end

  def pretty_print(q); end

  def requirement(); end

  def requirements_list(); end

  def runtime?(); end

  def source(); end

  def source=(source); end

  def specific?(); end

  def to_lock(); end

  def to_spec(); end

  def to_specs(); end

  def to_yaml_properties(); end

  def type(); end
end

class Gem::DependencyInstaller
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def add_found_dependencies(to_do, dependency_list); end

  def available_set_for(dep_or_name, version); end

  def consider_local?(); end

  def consider_remote?(); end

  def document(); end

  def errors(); end

  def find_gems_with_sources(dep, best_only=T.unsafe(nil)); end

  def find_spec_by_name_and_version(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def gather_dependencies(); end

  def gems_to_install(); end

  def in_background(what); end

  def initialize(options=T.unsafe(nil)); end

  def install(dep_or_name, version=T.unsafe(nil)); end

  def install_development_deps(); end

  def installed_gems(); end

  def resolve_dependencies(dep_or_name, version); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Gem::DependencyInstaller
end

class Gem::DependencyList
  include ::Enumerable
  include ::TSort
  def add(*gemspecs); end

  def clear(); end

  def dependency_order(); end

  def development(); end

  def development=(development); end

  def each(&block); end

  def find_name(full_name); end

  def initialize(development=T.unsafe(nil)); end

  def ok?(); end

  def ok_to_remove?(full_name, check_dev=T.unsafe(nil)); end

  def remove_by_name(full_name); end

  def remove_specs_unsatisfied_by(dependencies); end

  def spec_predecessors(); end

  def specs(); end

  def tsort_each_node(&block); end

  def why_not_ok?(quick=T.unsafe(nil)); end
end

class Gem::DependencyList
  def self.from_specs(); end
end

class Gem::DependencyResolutionError
  def conflict(); end

  def conflicting_dependencies(); end

  def initialize(conflict); end
end

class Gem::Resolver
end

Gem::DependencyResolver::Conflict = Gem::Resolver::Conflict

Gem::DependencyResolver::DependencyConflict = Gem::Resolver::Conflict

module Gem::Resolver::Molinillo
end

Gem::DependencyResolver::Molinillo::SpecificationProvider = Gem::Resolver::Molinillo::SpecificationProvider

Gem::DependencyResolver::Molinillo::UI = Gem::Resolver::Molinillo::UI

module Gem::Resolver::Molinillo
end

class Gem::Resolver
end

module Gem::Deprecate
  def self.deprecate(name, repl, year, month); end

  def self.skip(); end

  def self.skip=(v); end

  def self.skip_during(); end
end

class Gem::Exception
  def source_exception(); end

  def source_exception=(source_exception); end
end

module Gem::Ext
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def build_args(); end

  def build_args=(build_args); end

  def build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def build_extension(extension, dest_path); end

  def build_extensions(); end

  def builder_for(extension); end

  def initialize(spec, build_args=T.unsafe(nil)); end

  def write_gem_make_out(output); end
  CHDIR_MONITOR = ::T.let(nil, ::T.untyped)
  CHDIR_MUTEX = ::T.let(nil, ::T.untyped)
end

class Gem::Ext::Builder
  def self.class_name(); end

  def self.make(dest_path, results); end

  def self.redirector(); end

  def self.run(command, results, command_name=T.unsafe(nil)); end
end

class Gem::Ext::CmakeBuilder
end

class Gem::Ext::CmakeBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ConfigureBuilder
end

class Gem::Ext::ConfigureBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Ext::RakeBuilder
end

class Gem::Ext::RakeBuilder
  def self.build(extension, directory, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

module Gem::Ext
end

class Gem::FilePermissionError
  def directory(); end

  def initialize(directory); end
end

class Gem::FormatException
  def file_path(); end

  def file_path=(file_path); end
end

class Gem::GemNotInHomeException
  def spec(); end

  def spec=(spec); end
end

class Gem::ImpossibleDependenciesError
  def build_message(); end

  def conflicts(); end

  def dependency(); end

  def initialize(request, conflicts); end

  def request(); end
end

class Gem::Installer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def app_script_text(bin_file_name); end

  def bin_dir(); end

  def build_extensions(); end

  def build_root(); end

  def check_executable_overwrite(filename); end

  def check_that_user_bin_dir_is_in_path(); end

  def default_spec_file(); end

  def dir(); end

  def ensure_dependencies_met(); end

  def ensure_dependency(spec, dependency); end

  def ensure_loadable_spec(); end

  def ensure_required_ruby_version_met(); end

  def ensure_required_rubygems_version_met(); end

  def extension_build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def extract_bin(); end

  def extract_files(); end

  def formatted_program_filename(filename); end

  def gem(); end

  def gem_dir(); end

  def gem_home(); end

  def generate_bin(); end

  def generate_bin_script(filename, bindir); end

  def generate_bin_symlink(filename, bindir); end

  def generate_windows_script(filename, bindir); end

  def initialize(package, options=T.unsafe(nil)); end

  def install(); end

  def installation_satisfies_dependency?(dependency); end

  def installed_specs(); end

  def options(); end

  def pre_install_checks(); end

  def process_options(); end

  def run_post_build_hooks(); end

  def run_post_install_hooks(); end

  def run_pre_install_hooks(); end

  def shebang(bin_file_name); end

  def spec(); end

  def spec_file(); end

  def unpack(directory); end

  def verify_gem_home(unpack=T.unsafe(nil)); end

  def verify_spec_name(); end

  def windows_stub_script(bindir, bin_file_name); end

  def write_build_info_file(); end

  def write_cache_file(); end

  def write_default_spec(); end

  def write_spec(); end
  ENV_PATHS = ::T.let(nil, ::T.untyped)
end

class Gem::Installer
  def self.at(path, options=T.unsafe(nil)); end

  def self.exec_format(); end

  def self.exec_format=(exec_format); end

  def self.for_spec(spec, options=T.unsafe(nil)); end

  def self.install_lock(); end

  def self.path_warning(); end

  def self.path_warning=(path_warning); end
end

class Gem::Licenses
  IDENTIFIERS = ::T.let(nil, ::T.untyped)
  NONSTANDARD = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  extend ::Gem::Text
  def self.match?(license); end

  def self.suggestions(license); end
end

class Gem::List
  def each(&blk); end

  def initialize(value=T.unsafe(nil), tail=T.unsafe(nil)); end

  def prepend(value); end

  def pretty_print(q); end

  def tail(); end

  def tail=(tail); end

  def to_a(); end

  def value(); end

  def value=(value); end
end

class Gem::List
  def self.prepend(list, value); end
end

class Gem::LoadError
  def name(); end

  def name=(name); end

  def requirement(); end

  def requirement=(requirement); end
end

class Gem::MissingSpecError
  def initialize(name, requirement); end
end

class Gem::MissingSpecVersionError
  def initialize(name, requirement, specs); end

  def specs(); end
end

class Gem::NameTuple
  include ::Comparable
  def ==(other); end

  def eql?(other); end

  def full_name(); end

  def initialize(name, version, platform=T.unsafe(nil)); end

  def match_platform?(); end

  def name(); end

  def platform(); end

  def prerelease?(); end

  def spec_name(); end

  def to_a(); end

  def version(); end
end

class Gem::NameTuple
  def self.from_list(list); end

  def self.null(); end

  def self.to_basic(list); end
end

class Gem::Package
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def add_checksums(tar); end

  def add_contents(tar); end

  def add_files(tar); end

  def add_metadata(tar); end

  def build(skip_validation=T.unsafe(nil)); end

  def build_time(); end

  def build_time=(build_time); end

  def checksums(); end

  def contents(); end

  def copy_to(path); end

  def digest(entry); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def extract_tar_gz(io, destination_dir, pattern=T.unsafe(nil)); end

  def files(); end

  def gzip_to(io); end

  def initialize(gem, security_policy); end

  def install_location(filename, destination_dir); end

  def load_spec(entry); end

  def open_tar_gz(io); end

  def read_checksums(gem); end

  def security_policy(); end

  def security_policy=(security_policy); end

  def setup_signer(); end

  def spec(); end

  def spec=(spec); end

  def verify(); end

  def verify_checksums(digests, checksums); end

  def verify_entry(entry); end

  def verify_files(gem); end

  def verify_gz(entry); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::Error
end

class Gem::Package::Error
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::FormatError
  def initialize(message, source=T.unsafe(nil)); end

  def path(); end
end

class Gem::Package::FormatError
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::PathError
  def initialize(destination, destination_dir); end
end

class Gem::Package::PathError
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarReader
  include ::Enumerable
  def close(); end

  def each(&blk); end

  def each_entry(); end

  def initialize(io); end

  def rewind(); end

  def seek(name); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(len=T.unsafe(nil)); end

  def rewind(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def add_file(name, mode); end

  def add_file_digest(name, mode, digest_algorithms); end

  def add_file_signed(name, mode, signer); end

  def add_file_simple(name, mode, size); end

  def add_symlink(name, target, mode); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def flush(); end

  def initialize(io); end

  def mkdir(name, mode); end

  def split_name(name); end
end

class Gem::Package::TarWriter::BoundedStream
  def initialize(io, limit); end

  def limit(); end

  def write(data); end

  def written(); end
end

class Gem::Package::TarWriter::BoundedStream
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::RestrictedStream
  def initialize(io); end

  def write(data); end
end

class Gem::Package::TarWriter::RestrictedStream
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package::TooLongFileName
end

class Gem::Package::TooLongFileName
end

class Gem::Package
  def self.build(spec, skip_validation=T.unsafe(nil)); end

  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def cpu(); end

  def cpu=(cpu); end

  def eql?(other); end

  def initialize(arch); end

  def os(); end

  def os=(os); end

  def to_a(); end

  def version(); end

  def version=(version); end
  JAVA = ::T.let(nil, ::T.untyped)
  MINGW = ::T.let(nil, ::T.untyped)
  MSWIN = ::T.let(nil, ::T.untyped)
  MSWIN64 = ::T.let(nil, ::T.untyped)
  X64_MINGW = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  def self.installable?(spec); end

  def self.local(); end

  def self.match(platform); end

  def self.new(arch); end
end

class Gem::PlatformMismatch
  def add_platform(platform); end

  def initialize(name, version); end

  def name(); end

  def platforms(); end

  def version(); end

  def wordy(); end
end

class Gem::RemoteFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def api_endpoint(uri); end

  def cache_update_path(uri, path=T.unsafe(nil), update=T.unsafe(nil)); end

  def close_all(); end

  def correct_for_windows_path(path); end

  def download(spec, source_uri, install_dir=T.unsafe(nil)); end

  def download_to_cache(dependency); end

  def fetch_file(uri, *_); end

  def fetch_http(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_https(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_path(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_s3(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_size(uri); end

  def headers(); end

  def headers=(headers); end

  def https?(uri); end

  def initialize(proxy=T.unsafe(nil), dns=T.unsafe(nil), headers=T.unsafe(nil)); end

  def request(uri, request_class, last_modified=T.unsafe(nil)); end

  def s3_expiration(); end

  def sign_s3_url(uri, expiration=T.unsafe(nil)); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
end

class Gem::RemoteFetcher::FetchError
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher
  def self.fetcher(); end
end

class Gem::Request
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def cert_files(); end

  def connection_for(uri); end

  def fetch(); end

  def initialize(uri, request_class, last_modified, pool); end

  def perform_request(request); end

  def proxy_uri(); end

  def reset(connection); end

  def user_agent(); end
end

class Gem::Request::ConnectionPools
  def close_all(); end

  def initialize(proxy_uri, cert_files); end

  def pool_for(uri); end
end

class Gem::Request::ConnectionPools
  def self.client(); end

  def self.client=(client); end
end

class Gem::Request::HTTPPool
  def cert_files(); end

  def checkin(connection); end

  def checkout(); end

  def close_all(); end

  def initialize(http_args, cert_files, proxy_uri); end

  def proxy_uri(); end
end

class Gem::Request::HTTPPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  def self.configure_connection_for_https(connection, cert_files); end

  def self.create_with_proxy(uri, request_class, last_modified, proxy); end

  def self.get_cert_files(); end

  def self.get_proxy_from_env(scheme=T.unsafe(nil)); end

  def self.proxy_uri(proxy); end

  def self.verify_certificate(store_context); end

  def self.verify_certificate_message(error_number, cert); end
end

class Gem::RequestSet
  include ::TSort
  def always_install(); end

  def always_install=(always_install); end

  def dependencies(); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def errors(); end

  def gem(name, *reqs); end

  def git_set(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def import(deps); end

  def initialize(*deps); end

  def install(options, &block); end

  def install_dir(); end

  def install_from_gemdeps(options, &block); end

  def install_into(dir, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def load_gemdeps(path, without_groups=T.unsafe(nil), installing=T.unsafe(nil)); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def pretty_print(q); end

  def remote(); end

  def remote=(remote); end

  def resolve(set=T.unsafe(nil)); end

  def resolve_current(); end

  def resolver(); end

  def sets(); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def sorted_requests(); end

  def source_set(); end

  def specs(); end

  def specs_in(dir); end

  def tsort_each_node(&block); end

  def vendor_set(); end
end

Gem::RequestSet::GemDepedencyAPI = Gem::RequestSet::GemDependencyAPI

class Gem::RequestSet::GemDependencyAPI
  def dependencies(); end

  def find_gemspec(name, path); end

  def gem(name, *requirements); end

  def gem_deps_file(); end

  def gem_git_reference(options); end

  def gemspec(options=T.unsafe(nil)); end

  def git(repository); end

  def git_set(); end

  def git_source(name, &callback); end

  def group(*groups); end

  def initialize(set, path); end

  def installing=(installing); end

  def load(); end

  def platform(*platforms); end

  def platforms(*platforms); end

  def requires(); end

  def ruby(version, options=T.unsafe(nil)); end

  def source(url); end

  def vendor_set(); end

  def without_groups(); end

  def without_groups=(without_groups); end
  ENGINE_MAP = ::T.let(nil, ::T.untyped)
  PLATFORM_MAP = ::T.let(nil, ::T.untyped)
  VERSION_MAP = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::GemDependencyAPI
end

class Gem::RequestSet::Lockfile
  def add_DEPENDENCIES(out); end

  def add_GEM(out, spec_groups); end

  def add_GIT(out, git_requests); end

  def add_PATH(out, path_requests); end

  def add_PLATFORMS(out); end

  def initialize(request_set, gem_deps_file, dependencies); end

  def platforms(); end

  def relative_path_from(dest, base); end

  def spec_groups(); end

  def write(); end
end

class Gem::RequestSet::Lockfile::ParseError
  def column(); end

  def initialize(message, column, line, path); end

  def line(); end

  def path(); end
end

class Gem::RequestSet::Lockfile::ParseError
end

class Gem::RequestSet::Lockfile::Parser
  def get(expected_types=T.unsafe(nil), expected_value=T.unsafe(nil)); end

  def initialize(tokenizer, set, platforms, filename=T.unsafe(nil)); end

  def parse(); end

  def parse_DEPENDENCIES(); end

  def parse_GEM(); end

  def parse_GIT(); end

  def parse_PATH(); end

  def parse_PLATFORMS(); end

  def parse_dependency(name, op); end
end

class Gem::RequestSet::Lockfile::Parser
end

class Gem::RequestSet::Lockfile::Tokenizer
  def empty?(); end

  def initialize(input, filename=T.unsafe(nil), line=T.unsafe(nil), pos=T.unsafe(nil)); end

  def make_parser(set, platforms); end

  def next_token(); end

  def peek(); end

  def shift(); end

  def skip(type); end

  def to_a(); end

  def token_pos(byte_offset); end

  def unshift(token); end
  EOF = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def column(); end

  def column=(_); end

  def line(); end

  def line=(_); end

  def type(); end

  def type=(_); end

  def value(); end

  def value=(_); end
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.[](*_); end

  def self.members(); end
end

class Gem::RequestSet::Lockfile::Tokenizer
  def self.from_file(file); end
end

class Gem::RequestSet::Lockfile
  def self.build(request_set, gem_deps_file, dependencies=T.unsafe(nil)); end

  def self.requests_to_deps(requests); end
end

class Gem::RequestSet
end

class Gem::Requirement
  def ==(other); end

  def ===(version); end

  def =~(version); end

  def as_list(); end

  def concat(new); end

  def encode_with(coder); end

  def exact?(); end

  def for_lockfile(); end

  def init_with(coder); end

  def initialize(*requirements); end

  def marshal_dump(); end

  def marshal_load(array); end

  def none?(); end

  def prerelease?(); end

  def pretty_print(q); end

  def requirements(); end

  def satisfied_by?(version); end

  def specific?(); end

  def to_yaml_properties(); end

  def yaml_initialize(tag, vals); end
  DefaultRequirement = ::T.let(nil, ::T.untyped)
end

class Gem::Requirement
  def self.create(input); end

  def self.default(); end

  def self.parse(obj); end

  def self.source_set(); end
end

class Gem::Resolver
  include ::Gem::Resolver::Molinillo::UI
  include ::Gem::Resolver::Molinillo::SpecificationProvider
  def activation_request(dep, possible); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def explain(stage, *data); end

  def explain_list(stage); end

  def find_possible(dependency); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def initialize(needed, set=T.unsafe(nil)); end

  def missing(); end

  def requests(s, act, reqs=T.unsafe(nil)); end

  def resolve(); end

  def select_local_platforms(specs); end

  def skip_gems(); end

  def skip_gems=(skip_gems); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def stats(); end
  DEBUG_RESOLVER = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::APISet
  def dep_uri(); end

  def initialize(dep_uri=T.unsafe(nil)); end

  def prefetch_now(); end

  def pretty_print(q); end

  def source(); end

  def uri(); end

  def versions(name); end
end

class Gem::Resolver::APISet
end

class Gem::Resolver::APISpecification
  def ==(other); end

  def initialize(set, api_data); end

  def pretty_print(q); end
end

class Gem::Resolver::APISpecification
end

class Gem::Resolver::ActivationRequest
  def ==(other); end

  def development?(); end

  def download(path); end

  def full_name(); end

  def full_spec(); end

  def initialize(spec, request, others_possible=T.unsafe(nil)); end

  def installed?(); end

  def name(); end

  def others_possible?(); end

  def parent(); end

  def pretty_print(q); end

  def request(); end

  def spec(); end

  def version(); end
end

class Gem::Resolver::ActivationRequest
end

class Gem::Resolver::BestSet
  def initialize(sources=T.unsafe(nil)); end

  def pick_sets(); end

  def pretty_print(q); end

  def replace_failed_api_set(error); end
end

class Gem::Resolver::BestSet
end

class Gem::Resolver::ComposedSet
  def initialize(*sets); end

  def prerelease=(allow_prerelease); end

  def remote=(remote); end

  def sets(); end
end

class Gem::Resolver::ComposedSet
end

class Gem::Resolver::Conflict
  def ==(other); end

  def activated(); end

  def conflicting_dependencies(); end

  def dependency(); end

  def explain(); end

  def explanation(); end

  def failed_dep(); end

  def for_spec?(spec); end

  def initialize(dependency, activated, failed_dep=T.unsafe(nil)); end

  def pretty_print(q); end

  def request_path(current); end

  def requester(); end
end

class Gem::Resolver::Conflict
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::DependencyRequest
  def ==(other); end

  def dependency(); end

  def development?(); end

  def explicit?(); end

  def implicit?(); end

  def initialize(dependency, requester); end

  def match?(spec, allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def name(); end

  def pretty_print(q); end

  def request_context(); end

  def requester(); end

  def requirement(); end

  def type(); end
end

class Gem::Resolver::DependencyRequest
end

class Gem::Resolver::GitSet
  def add_git_gem(name, repository, reference, submodules); end

  def add_git_spec(name, version, repository, reference, submodules); end

  def need_submodules(); end

  def pretty_print(q); end

  def repositories(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end
end

class Gem::Resolver::GitSet
end

class Gem::Resolver::GitSpecification
  def ==(other); end

  def add_dependency(dependency); end

  def pretty_print(q); end
end

class Gem::Resolver::GitSpecification
end

class Gem::Resolver::IndexSet
  def initialize(source=T.unsafe(nil)); end

  def pretty_print(q); end
end

class Gem::Resolver::IndexSet
end

class Gem::Resolver::IndexSpecification
  def initialize(set, name, version, source, platform); end

  def pretty_print(q); end
end

class Gem::Resolver::IndexSpecification
end

class Gem::Resolver::InstalledSpecification
  def ==(other); end

  def pretty_print(q); end
end

class Gem::Resolver::InstalledSpecification
end

class Gem::Resolver::InstallerSet
  def add_always_install(dependency); end

  def add_local(dep_name, spec, source); end

  def always_install(); end

  def consider_local?(); end

  def consider_remote?(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def ignore_installed(); end

  def ignore_installed=(ignore_installed); end

  def initialize(domain); end

  def load_spec(name, ver, platform, source); end

  def local?(dep_name); end

  def prerelease=(allow_prerelease); end

  def pretty_print(q); end

  def remote=(remote); end

  def remote_set(); end
end

class Gem::Resolver::InstallerSet
end

class Gem::Resolver::LocalSpecification
  def pretty_print(q); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LockSet
  def add(name, version, platform); end

  def initialize(sources); end

  def load_spec(name, version, platform, source); end

  def pretty_print(q); end

  def specs(); end
end

class Gem::Resolver::LockSet
end

class Gem::Resolver::LockSpecification
  def add_dependency(dependency); end

  def initialize(set, name, version, sources, platform); end

  def pretty_print(q); end

  def sources(); end
end

class Gem::Resolver::LockSpecification
end

module Gem::Resolver::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(nodes); end
end

class Gem::Resolver::Molinillo::CircularDependencyError
end

module Gem::Resolver::Molinillo::Delegates
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
end

module Gem::Resolver::Molinillo::Delegates
end

class Gem::Resolver::Molinillo::DependencyGraph
  include ::Enumerable
  include ::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(&blk); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(_); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Gem::Resolver::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddVertex
end

class Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge
end

class Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::SetPayload
end

class Gem::Resolver::Molinillo::DependencyGraph::Tag
  def down(_graph); end

  def initialize(tag); end

  def tag(); end

  def up(_graph); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Tag
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
end

class Gem::Resolver::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Gem::Resolver::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Gem::Resolver::Molinillo::DependencyState
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def self.[](*_); end

  def self.empty(); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
  include ::Gem::Resolver::Molinillo::Delegates::ResolutionState
  include ::Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
end

class Gem::Resolver::Molinillo::Resolver
end

class Gem::Resolver::Molinillo::ResolverError
end

class Gem::Resolver::Molinillo::ResolverError
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
end

module Gem::Resolver::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Resolver::Molinillo::UI
end

class Gem::Resolver::Molinillo::VersionConflict
  def conflicts(); end

  def initialize(conflicts); end
end

class Gem::Resolver::Molinillo::VersionConflict
end

module Gem::Resolver::Molinillo
end

class Gem::Resolver::RequirementList
  include ::Enumerable
  def add(req); end

  def each(&blk); end

  def empty?(); end

  def next5(); end

  def remove(); end

  def size(); end
end

class Gem::Resolver::RequirementList
end

class Gem::Resolver::Set
  def errors(); end

  def errors=(errors); end

  def find_all(req); end

  def prefetch(reqs); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def remote(); end

  def remote=(remote); end

  def remote?(); end
end

class Gem::Resolver::Set
end

class Gem::Resolver::SourceSet
  def add_source_gem(name, source); end
end

class Gem::Resolver::SourceSet
end

class Gem::Resolver::SpecSpecification
  def initialize(set, spec, source=T.unsafe(nil)); end
end

class Gem::Resolver::SpecSpecification
end

class Gem::Resolver::Specification
  def dependencies(); end

  def fetch_development_dependencies(); end

  def full_name(); end

  def install(options=T.unsafe(nil)); end

  def installable_platform?(); end

  def local?(); end

  def name(); end

  def platform(); end

  def set(); end

  def source(); end

  def spec(); end

  def version(); end
end

class Gem::Resolver::Specification
end

class Gem::Resolver::Stats
  def backtracking!(); end

  def display(); end

  def iteration!(); end

  def record_depth(stack); end

  def record_requirements(reqs); end

  def requirement!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Stats
end

class Gem::Resolver::VendorSet
  def add_vendor_gem(name, directory); end

  def load_spec(name, version, platform, source); end

  def pretty_print(q); end

  def specs(); end
end

class Gem::Resolver::VendorSet
end

class Gem::Resolver::VendorSpecification
  def ==(other); end
end

class Gem::Resolver::VendorSpecification
end

class Gem::Resolver
  def self.compose_sets(*sets); end

  def self.for_current_gems(needed); end
end

class Gem::SilentUI
  def initialize(); end
end

class Gem::SilentUI
end

class Gem::Source
  include ::Comparable
  def ==(other); end

  def api_uri(); end

  def cache_dir(uri); end

  def dependency_resolver_set(); end

  def download(spec, dir=T.unsafe(nil)); end

  def eql?(other); end

  def fetch_spec(name_tuple); end

  def initialize(uri); end

  def load_specs(type); end

  def pretty_print(q); end

  def update_cache?(); end

  def uri(); end
  FILES = ::T.let(nil, ::T.untyped)
end

class Gem::Source::Git
  def base_dir(); end

  def cache(); end

  def checkout(); end

  def dir_shortref(); end

  def download(full_spec, path); end

  def initialize(name, repository, reference, submodules=T.unsafe(nil)); end

  def install_dir(); end

  def name(); end

  def need_submodules(); end

  def reference(); end

  def remote(); end

  def remote=(remote); end

  def repo_cache_dir(); end

  def repository(); end

  def rev_parse(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end

  def uri_hash(); end
end

class Gem::Source::Git
end

class Gem::Source::Installed
  def download(spec, path); end

  def initialize(); end
end

class Gem::Source::Installed
end

class Gem::Source::Local
  def download(spec, cache_dir=T.unsafe(nil)); end

  def fetch_spec(name); end

  def find_gem(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def initialize(); end
end

class Gem::Source::Local
end

class Gem::Source::Lock
  def initialize(source); end

  def wrapped(); end
end

class Gem::Source::Lock
end

class Gem::Source::SpecificFile
  def fetch_spec(name); end

  def initialize(file); end

  def load_specs(*a); end

  def path(); end

  def spec(); end
end

class Gem::Source::SpecificFile
end

class Gem::Source::Vendor
  def initialize(path); end
end

class Gem::Source::Vendor
end

class Gem::Source
end

class Gem::SourceFetchProblem
  def error(); end

  def exception(); end

  def initialize(source, error); end

  def source(); end

  def wordy(); end
end

class Gem::SourceList
  include ::Enumerable
  def <<(obj); end

  def ==(other); end

  def clear(); end

  def delete(source); end

  def each(&blk); end

  def each_source(&b); end

  def empty?(); end

  def first(); end

  def include?(other); end

  def replace(other); end

  def sources(); end

  def to_a(); end

  def to_ary(); end
end

class Gem::SourceList
  def self.from(ary); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::SpecificGemNotFoundException
  def errors(); end

  def initialize(name, version, errors=T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def ==(other); end

  def _dump(limit); end

  def abbreviate(); end

  def activate(); end

  def activate_dependencies(); end

  def activated(); end

  def activated=(activated); end

  def add_bindir(executables); end

  def add_dependency(gem, *requirements); end

  def add_development_dependency(gem, *requirements); end

  def add_runtime_dependency(gem, *requirements); end

  def add_self_to_load_path(); end

  def author(); end

  def author=(o); end

  def authors(); end

  def authors=(value); end

  def autorequire(); end

  def autorequire=(autorequire); end

  def bin_dir(); end

  def bin_file(name); end

  def bindir(); end

  def bindir=(bindir); end

  def build_args(); end

  def build_extensions(); end

  def build_info_dir(); end

  def build_info_file(); end

  def bundled_gem_in_old_ruby?(); end

  def cache_dir(); end

  def cache_file(); end

  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def conficts_when_loaded_with?(list_of_specs); end

  def conflicts(); end

  def date(); end

  def date=(date); end

  def default_executable(); end

  def default_executable=(default_executable); end

  def default_value(name); end

  def dependencies(); end

  def dependent_gems(); end

  def dependent_specs(); end

  def description(); end

  def description=(str); end

  def development_dependencies(); end

  def doc_dir(type=T.unsafe(nil)); end

  def email(); end

  def email=(email); end

  def encode_with(coder); end

  def eql?(other); end

  def executable(); end

  def executable=(o); end

  def executables(); end

  def executables=(value); end

  def extensions(); end

  def extensions=(extensions); end

  def extra_rdoc_files(); end

  def extra_rdoc_files=(files); end

  def file_name(); end

  def files(); end

  def files=(files); end

  def for_cache(); end

  def git_version(); end

  def groups(); end

  def has_conflicts?(); end

  def has_rdoc(); end

  def has_rdoc=(ignored); end

  def has_rdoc?(); end

  def has_test_suite?(); end

  def has_unit_tests?(); end

  def homepage(); end

  def homepage=(homepage); end

  def init_with(coder); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def installed_by_version(); end

  def installed_by_version=(version); end

  def lib_files(); end

  def license(); end

  def license=(o); end

  def licenses(); end

  def licenses=(licenses); end

  def load_paths(); end

  def location(); end

  def location=(location); end

  def mark_version(); end

  def metadata(); end

  def metadata=(metadata); end

  def method_missing(sym, *a, &b); end

  def missing_extensions?(); end

  def name=(name); end

  def name_tuple(); end

  def nondevelopment_dependencies(); end

  def normalize(); end

  def original_name(); end

  def original_platform(); end

  def original_platform=(original_platform); end

  def platform=(platform); end

  def post_install_message(); end

  def post_install_message=(post_install_message); end

  def pretty_print(q); end

  def raise_if_conflicts(); end

  def rdoc_options(); end

  def rdoc_options=(options); end

  def relative_loaded_from(); end

  def relative_loaded_from=(relative_loaded_from); end

  def remote(); end

  def remote=(remote); end

  def require_path(); end

  def require_path=(path); end

  def require_paths=(val); end

  def required_ruby_version(); end

  def required_ruby_version=(req); end

  def required_rubygems_version(); end

  def required_rubygems_version=(req); end

  def requirements(); end

  def requirements=(req); end

  def reset_nil_attributes_to_default(); end

  def rg_extension_dir(); end

  def rg_full_gem_path(); end

  def rg_loaded_from(); end

  def ri_dir(); end

  def rubyforge_project(); end

  def rubyforge_project=(rubyforge_project); end

  def rubygems_version(); end

  def rubygems_version=(rubygems_version); end

  def runtime_dependencies(); end

  def sanitize(); end

  def sanitize_string(string); end

  def satisfies_requirement?(dependency); end

  def signing_key(); end

  def signing_key=(signing_key); end

  def sort_obj(); end

  def source(); end

  def source=(source); end

  def spec_dir(); end

  def spec_file(); end

  def spec_name(); end

  def specification_version(); end

  def specification_version=(specification_version); end

  def summary(); end

  def summary=(str); end

  def test_file(); end

  def test_file=(file); end

  def test_files(); end

  def test_files=(files); end

  def to_gemfile(path=T.unsafe(nil)); end

  def to_ruby(); end

  def to_ruby_for_cache(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def traverse(trail=T.unsafe(nil), visited=T.unsafe(nil), &block); end

  def validate(packaging=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_permissions(); end

  def version=(version); end

  def warning(statement); end

  def yaml_initialize(tag, vals); end
  DateLike = ::T.let(nil, ::T.untyped)
  DateTimeFormat = ::T.let(nil, ::T.untyped)
  Dupable = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Enumerable
  extend ::Gem::Deprecate
  def self._all(); end

  def self._clear_load_cache(); end

  def self._latest_specs(specs, prerelease=T.unsafe(nil)); end

  def self._load(str); end

  def self._resort!(specs); end

  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.all(); end

  def self.all=(specs); end

  def self.all_names(); end

  def self.array_attributes(); end

  def self.attribute_names(); end

  def self.dirs(); end

  def self.dirs=(dirs); end

  def self.each(&blk); end

  def self.each_gemspec(dirs); end

  def self.each_spec(dirs); end

  def self.find_active_stub_by_path(path); end

  def self.find_all_by_name(name, *requirements); end

  def self.find_by_name(name, *requirements); end

  def self.find_by_path(path); end

  def self.find_in_unresolved(path); end

  def self.find_in_unresolved_tree(path); end

  def self.find_inactive_by_path(path); end

  def self.from_yaml(input); end

  def self.latest_specs(prerelease=T.unsafe(nil)); end

  def self.load(file); end

  def self.load_defaults(); end

  def self.non_nil_attributes(); end

  def self.normalize_yaml_input(input); end

  def self.outdated(); end

  def self.outdated_and_latest_version(); end

  def self.remove_spec(spec); end

  def self.required_attribute?(name); end

  def self.required_attributes(); end

  def self.reset(); end

  def self.stubs(); end

  def self.stubs_for(name); end

  def self.unresolved_deps(); end
end

class Gem::StreamUI
  def _gets_noecho(); end

  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(question); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def backtrace(exception); end

  def choose_from_list(question, list); end

  def close(); end

  def debug(statement); end

  def download_reporter(*args); end

  def errs(); end

  def initialize(in_stream, out_stream, err_stream=T.unsafe(nil), usetty=T.unsafe(nil)); end

  def ins(); end

  def outs(); end

  def progress_reporter(*args); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(status=T.unsafe(nil)); end

  def tty?(); end
end

class Gem::StreamUI
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::SystemExitException
  def exit_code(); end

  def exit_code=(exit_code); end

  def initialize(exit_code); end
end

module Gem::Text
  def clean_text(text); end

  def format_text(text, wrap, indent=T.unsafe(nil)); end

  def levenshtein_distance(str1, str2); end

  def min3(a, b, c); end

  def truncate_text(text, description, max_length=T.unsafe(nil)); end
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

class Gem::UnsatisfiableDependencyError
  def dependency(); end

  def errors(); end

  def errors=(errors); end

  def initialize(dep, platform_mismatch=T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Gem::UriFormatter
  def escape(); end

  def initialize(uri); end

  def normalize(); end

  def unescape(); end

  def uri(); end
end

class Gem::UriFormatter
end

module Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(prompt); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def choose_from_list(question, list); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(exit_code=T.unsafe(nil)); end

  def verbose(msg=T.unsafe(nil)); end
end

module Gem::Util
  NULL_DEVICE = ::T.let(nil, ::T.untyped)
end

module Gem::Util
  def self.gunzip(data); end

  def self.gzip(data); end

  def self.inflate(data); end

  def self.popen(*command); end

  def self.silent_system(*command); end

  def self.traverse_parents(directory); end
end

class Gem::Version
  def _segments(); end

  def _version(); end

  def approximate_recommendation(); end

  def bump(); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def marshal_dump(); end

  def marshal_load(array); end

  def prerelease?(); end

  def pretty_print(q); end

  def release(); end

  def segments(); end

  def to_yaml_properties(); end

  def version(); end

  def yaml_initialize(tag, map); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::Version
  def self.correct?(version); end

  def self.create(input); end

  def self.new(version); end
end

module Gem
  def self.activate_bin_path(name, *args); end

  def self.default_ext_dir_for(base_dir); end

  def self.default_gems_use_full_paths?(); end

  def self.default_spec_cache_dir(); end

  def self.deflate(data); end

  def self.detect_gemdeps(path=T.unsafe(nil)); end

  def self.dir(); end

  def self.done_installing(&hook); end

  def self.done_installing_hooks(); end

  def self.ensure_default_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_subdirectories(dir, mode, subdirs); end

  def self.env_requirement(gem_name); end

  def self.extension_api_version(); end

  def self.find_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_files_from_load_path(glob); end

  def self.find_latest_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_unresolved_default_spec(path); end

  def self.finish_resolve(*_); end

  def self.gemdeps(); end

  def self.gunzip(data); end

  def self.gzip(data); end

  def self.host(); end

  def self.host=(host); end

  def self.inflate(data); end

  def self.install(name, version=T.unsafe(nil), *options); end

  def self.install_extension_in_lib(); end

  def self.latest_rubygems_version(); end

  def self.latest_spec_for(name); end

  def self.latest_version_for(name); end

  def self.load_env_plugins(); end

  def self.load_path_insert_index(); end

  def self.load_plugin_files(plugins); end

  def self.load_plugins(); end

  def self.load_yaml(); end

  def self.loaded_specs(); end

  def self.location_of_caller(); end

  def self.marshal_version(); end

  def self.needs(); end

  def self.path(); end

  def self.path_separator(); end

  def self.paths(); end

  def self.paths=(env); end

  def self.platform_defaults(); end

  def self.platforms(); end

  def self.platforms=(platforms); end

  def self.post_build(&hook); end

  def self.post_build_hooks(); end

  def self.post_install(&hook); end

  def self.post_install_hooks(); end

  def self.post_reset(&hook); end

  def self.post_reset_hooks(); end

  def self.post_uninstall(&hook); end

  def self.post_uninstall_hooks(); end

  def self.pre_install(&hook); end

  def self.pre_install_hooks(); end

  def self.pre_reset(&hook); end

  def self.pre_reset_hooks(); end

  def self.pre_uninstall(&hook); end

  def self.pre_uninstall_hooks(); end

  def self.prefix(); end

  def self.read_binary(path); end

  def self.refresh(); end

  def self.register_default_spec(spec); end

  def self.remove_unresolved_default_spec(spec); end

  def self.ruby(); end

  def self.ruby_api_version(); end

  def self.ruby_engine(); end

  def self.ruby_version(); end

  def self.rubygems_version(); end

  def self.sources(); end

  def self.sources=(new_sources); end

  def self.spec_cache_dir(); end

  def self.suffix_pattern(); end

  def self.suffixes(); end

  def self.time(msg, width=T.unsafe(nil), display=T.unsafe(nil)); end

  def self.try_activate(path); end

  def self.ui(); end

  def self.use_gemdeps(path=T.unsafe(nil)); end

  def self.use_paths(home, *paths); end

  def self.user_dir(); end

  def self.user_home(); end

  def self.vendor_dir(); end

  def self.win_platform?(); end

  def self.write_binary(path, data); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def replace(_); end

  def to_h(); end

  def to_proc(); end

  def transform_values!(); end

  def update(_); end
end

class Hash
  def self.try_convert(_); end
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.foreach(*_); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def digits(*_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end
end

module Kernel
  def self.at_exit(); end
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

module Marshal
  def self.restore(*_); end
end

class Module
  def deprecate_constant(*_); end
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

class NameError
  include ::DidYouMean::Correctable
  def name(); end

  def receiver(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def make_symlink(_); end
end

class Proc
  def ===(*_); end

  def clone(); end

  def yield(*_); end
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.setpgrp(); end
end

class Random
  def self.raw_seed(_); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

class RubyVM
  def self.stat(*_); end
end

class Set
  def ==(other); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SignalException
  def signm(); end

  def signo(); end
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Socket
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def []=(*_); end

  def casecmp?(_); end

  def encode!(*_); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def unicode_normalize(form=T.unsafe(nil)); end

  def unicode_normalize!(form=T.unsafe(nil)); end

  def unicode_normalized?(form=T.unsafe(nil)); end

  def unpack1(_); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def length(); end

  def truncate(_); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

class TracePoint
  def event(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end
