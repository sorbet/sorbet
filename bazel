#!/bin/bash

#
# ./bazel
#
# Reads the .bazelversion_checksums folder to find which version of Bazel to
# run. If not found, downloads and installs it using the contents of the
# `.bazelversion` file.
#

set -euo pipefail

if [ "${LOCAL_BAZEL_OVERRIDE:-}" != "" ]; then
  exec "$LOCAL_BAZEL_OVERRIDE" "$@"
fi

# ccache integration for ~4x faster incremental builds
# This patches the LLVM toolchain's cc_wrapper.sh to use ccache.
# Set DISABLE_CCACHE=1 to disable.
patch_ccache_if_needed() {
    [[ -z "${DISABLE_CCACHE:-}" ]] || return 0
    command -v ccache &> /dev/null || return 0
    [[ -n "${HOME:-}" ]] || return 0
    # Check both common bazel output locations
    local user="${USER:-$(id -un)}"
    for cache_base in "/var/tmp/_bazel_${user}" "${HOME}/.cache/bazel/_bazel_${user}"; do
    for base_dir in "$cache_base"/*/external/llvm_toolchain_*/bin; do
        [[ -f "$base_dir/cc_wrapper.sh" ]] || continue
        grep -q "USE_CCACHE" "$base_dir/cc_wrapper.sh" 2>/dev/null && continue

        # Extract clang path from original wrapper (works on both BSD and GNU sed)
        local clang_path
        clang_path=$(sed -n 's/^if \[\[ -f \(.*\) \]\].*/\1/p' "$base_dir/cc_wrapper.sh" 2>/dev/null | head -1 | tr -d '[:space:]') || continue
        [[ -n "$clang_path" ]] || continue

        # Atomic write to avoid races with parallel builds
        local tmp_wrapper
        tmp_wrapper=$(mktemp "$base_dir/cc_wrapper.sh.XXXXXX")
        cat > "$tmp_wrapper" << CCACHE_WRAPPER
#!/bin/bash
set -euo pipefail

if [[ -z "\${DISABLE_CCACHE:-}" ]] && command -v ccache &> /dev/null && [[ -n "\${HOME:-}" ]]; then
  export CCACHE_DIR="\${CCACHE_DIR:-\$HOME/.ccache}"
  export CCACHE_SLOPPINESS=include_file_ctime,include_file_mtime,time_macros,file_stat_matches,pch_defines
  export CCACHE_MAXSIZE="\${CCACHE_MAXSIZE:-10G}"
  export CCACHE_COMPILERCHECK=content CCACHE_NOHASHDIR=1
  USE_CCACHE=1
else USE_CCACHE=0; fi

clang_path="$clang_path"
llvm_bin_dir="\${clang_path%/*}"

if [[ -f \$clang_path ]]; then
  execroot_path=""
elif [[ \${BASH_SOURCE[0]} == "/"* ]]; then
  execroot_path="\${BASH_SOURCE[0]%/*/*/*/*}/"
else
  echo >&2 "ERROR: could not find clang; PWD=\"\${PWD}\"."
  exit 5
fi

# Add LLVM bin to PATH so linker (ld64.lld) can be found
export PATH="\${execroot_path}\${llvm_bin_dir}:\${PATH:-}"

sanitize_option() {
  local -r opt=\$1
  if [[ \${opt} == */cc_wrapper.sh ]]; then
    printf "%s" "\${execroot_path}\${clang_path}"
  elif [[ \${opt} =~ ^-fsanitize-(ignore|black)list=[^/] ]]; then
    parts=(\${opt/=/ }); printf "%s" "\${parts[0]}=\${execroot_path}\${parts[1]}"
  else
    printf "%s" "\${opt}"
  fi
}

cmd=()
for ((i = 0; i <= \$#; i++)); do
  if [[ \${!i} == @* ]]; then
    while IFS= read -r opt; do cmd+=("\$(set -e; sanitize_option "\${opt}")"); done <"\${!i:1}"
  else cmd+=("\$(set -e; sanitize_option "\${!i}")"); fi
done

if [[ "\$USE_CCACHE" == "1" ]]; then exec ccache "\${cmd[@]}"; else exec "\${cmd[@]}"; fi
CCACHE_WRAPPER
        chmod +x "$tmp_wrapper"
        mv "$tmp_wrapper" "$base_dir/cc_wrapper.sh"
    done
    done
}

run_bazel() {
    case "${1:-}" in
      build|test|run|coverage|cquery|aquery)
        patch_ccache_if_needed;;
    esac
    exec "$bazel_exec_path" "$@"
}

old_pwd="$PWD"
cd "$(dirname "${BASH_SOURCE[0]}")"
if [[ "$PWD" = */tools ]]; then
  cd ..
fi
repo_root="$PWD"
cd "$old_pwd"

kernel_name="$(uname -s | tr 'A-Z' 'a-z')"
processor_name="$(uname -m)"

bazel_installer_platform="${kernel_name}-${processor_name}"
case "$bazel_installer_platform" in
  linux-x86_64) ;;
  linux-aarch64)
    bazel_installer_platform="linux-arm64"
    ;;
  darwin-x86_64) ;;
  darwin-arm64) ;;
esac

expected_sha_file="$repo_root/.bazelversion_checksums/$bazel_installer_platform"
if ! [ -f "$expected_sha_file" ]; then
    echo >&2 "Building on $bazel_installer_platform is not implemented"
    exit 1
fi

expected_sha="$(< "$expected_sha_file")"
if [ "$expected_sha" != "" ]; then
  bazel_bin_loc="${bazel_bin_loc:-$HOME/.bazel_binaries}"
  bazel_exec_path="$bazel_bin_loc/$expected_sha/bin/bazel-real"

  if [ -f "$bazel_exec_path" ]; then
    run_bazel "$@"
  fi
else
  echo >&2 "$expected_sha_file was empty. Falling back to downloading bazel"
fi

# ----- slow path -----

echo >&2 "No cached Bazel found, installing..."

BAZEL_VERSION=$(< "$repo_root/.bazelversion")
export BAZEL_VERSION

BUILD_DIR="$(mktemp -d)"
export BUILD_DIR
mkdir -p "$BUILD_DIR"

(
  set -euo pipefail
  cd "$BUILD_DIR"
  echo "$PWD"

  check_sha () {
    if [ "$actual_sha" != "$expected_sha" ]; then
      echo >&2 "Installer checksum mismatch:"
      echo >&2 "  Expected: $expected_sha"
      echo >&2 "  Actual:   $actual_sha"
      echo >&2 "To accept this mismatch, update $expected_sha_file and re-run."
      exit 1
    fi
  }
  BAZEL_REMOTE_SOURCE="${BAZEL_REMOTE_SOURCE:-https://github.com/bazelbuild/bazel/releases/download}"

  # Bazel for linux-arm64 doesn't have a binary installer
  if [ "$bazel_installer_platform" == "linux-arm64" ]; then
    bazel_name="bazel-${BAZEL_VERSION}-linux-arm64"
    BAZEL_PATH="${BAZEL_PATH:-$BAZEL_REMOTE_SOURCE/${BAZEL_VERSION}/${bazel_name}}"

    curl -O -L "$BAZEL_PATH"

    actual_sha="$(shasum -a 256 "$bazel_name" | awk '{print $1}')"
    check_sha

    mkdir -p "$bazel_bin_loc/${expected_sha}/bin"
    cp "$bazel_name" "$bazel_bin_loc/${expected_sha}/bin/bazel-real"
    chmod +x "$bazel_bin_loc/${expected_sha}/bin/bazel-real"
  else
    installer_name="bazel-${BAZEL_VERSION}-installer-${bazel_installer_platform}.sh"
    BAZEL_INSTALLER_PATH="${BAZEL_INSTALLER_PATH:-$BAZEL_REMOTE_SOURCE/${BAZEL_VERSION}/$installer_name}"

    curl -O -L "$BAZEL_INSTALLER_PATH"

    actual_sha="$(shasum -a 256 "$installer_name" | awk '{print $1}')"
    check_sha

    chmod +x "$installer_name"
    mkdir -p "$bazel_bin_loc"
    "./${installer_name}" --base="${bazel_bin_loc}/${expected_sha}" --bin="${bazel_bin_loc}/${expected_sha}/bin_t"
  fi

)
rm -rf "$BUILD_DIR"

run_bazel "$@"
