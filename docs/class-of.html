<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Types for Class Objects via T.class_of · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;!-- TODO(jez) Need to update this with T::Module documentation --&gt;"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Types for Class Objects via T.class_of · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="&lt;!-- TODO(jez) Need to update this with T::Module documentation --&gt;"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5H7PQ9Z8KF"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'G-5H7PQ9Z8KF');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ↔ Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">CLI Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/cli-ref">CLI Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/why-type-annotations">Why type annotations?</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/unsupported">Unsupported Ruby Features</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">sig</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations (non-sig)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">T.let, T.cast, T.must, T.bind</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types (Integer, String)</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types (T.nilable)</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types (T.any)</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow-Sensitivity (is_a?, nil?)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">T.type_alias</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness (T.absurd)</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/anything">T.anything</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types (T.all)</a></li><li class="navListItem"><a class="navItem" href="/docs/generics">Generics</a></li><li class="navListItem"><a class="navItem" href="/docs/strong">Banning untyped</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Ruby &amp; DSL Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/attr_reader">attr_reader</a></li><li class="navListItem"><a class="navItem" href="/docs/minitest">minitest</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Editor Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/lsp">Language Server (LSP)</a></li><li class="navListItem"><a class="navItem" href="/docs/server-status">Server Status</a></li><li class="navListItem"><a class="navItem" href="/docs/lsp-typed-level">LSP &amp; Typed Level</a></li><li class="navListItem"><a class="navItem" href="/docs/go-to-def">Go to Definition</a></li><li class="navListItem"><a class="navItem" href="/docs/hover">Hover</a></li><li class="navListItem"><a class="navItem" href="/docs/autocompletion">Autocompletion</a></li><li class="navListItem"><a class="navItem" href="/docs/references">Find All References</a></li><li class="navListItem"><a class="navItem" href="/docs/code-actions">Code Actions</a></li><li class="navListItem"><a class="navItem" href="/docs/outline">Outline &amp; Document Symbols</a></li><li class="navListItem"><a class="navItem" href="/docs/doc-comments">Documentation Comments</a></li><li class="navListItem"><a class="navItem" href="/docs/sig-suggestion">Suggesting sigs</a></li><li class="navListItem"><a class="navItem" href="/docs/highlight-untyped">Highlighting untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/sorbet-uris">sorbet: URIs</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/overloads">Overloads</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li><li class="navListItem"><a class="navItem" href="/docs/rbs-support">RBS Comments</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/class-of.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Types for Class Objects via T.class_of</h1></header><article><div><span><!-- TODO(jez) Need to update this with T::Module documentation -->
<p>Classes and modules are also values in Ruby. Sorbet has two ways to describe the type of these class objects: <code>T.class_of(...)</code> and <code>T::Class[...]</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># The type to use in most circumstances:</span>
T.class_of(MyClass)

<span class="hljs-comment"># Other types that have certain specific use cases</span>
<span class="hljs-comment"># (discussed below)</span>
T::Class[AnArbitraryType]
T::Module[AnArbitraryType]
</code></pre>
<p>Prefer <code>T.class_of(...)</code> in most cases: it’s simpler, usually more precise, and leads to fewer surprises. <code>T::Class[...]</code> and <code>T::Module[...]</code> are better for some very specific use cases, discussed below. (These specific cases are less common, which is why we recommend using <code>T.class_of</code> to those who don’t yet know which to pick.)</p>
<h2><a class="anchor" aria-hidden="true" id="what-is-a-tclass_of-type"></a><a href="#what-is-a-tclass_of-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What is a <code>T.class_of</code> type?</h2>
<p><code>T.class_of</code> is used to refer to the type of a class object itself, not values of that class. This difference can be confusing, so here are some examples to make it less confusing:</p>
<table>
<thead>
<tr><th>This expression…</th><th>…has this type</th></tr>
</thead>
<tbody>
<tr><td><code>0</code>, <code>1</code>, <code>2 + 2</code></td><td><code>Integer</code></td></tr>
<tr><td><code>Integer</code></td><td><code>T.class_of(Integer)</code></td></tr>
<tr><td><code>42.class</code></td><td><code>T.class_of(Integer)</code></td></tr>
</tbody>
</table>
<p>Here’s a playground link to confirm these types:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
T.let(<span class="hljs-number">0</span>, Integer)
T.let(<span class="hljs-number">1</span>, Integer)
T.let(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>, Integer)

T.let(Integer, T.class_of(Integer))
T.let(<span class="hljs-number">42</span><span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">T</span>.<span class="hljs-title">class_of</span>(<span class="hljs-title">Integer</span>))</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0AT.let(0%2C%20Integer)%0AT.let(1%2C%20Integer)%0AT.let(2%20%2B%202%2C%20Integer)%0A%0AT.let(Integer%2C%20T.class_of(Integer))%0AT.let(42.class%2C%20T.class_of(Integer))">
→ View on sorbet.run
</a></p>
<h2><a class="anchor" aria-hidden="true" id="tclass_of-and-inheritance"></a><a href="#tclass_of-and-inheritance" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T.class_of</code> and inheritance</h2>
<p>As with plain <a href="/docs/class-types#inheritance">Class Types</a>, <code>T.class_of</code> types respect inheritance, as long as the argument is a <strong>class</strong> name, not a module name:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Grandparent</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &lt; Grandparent;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent;</span> <span class="hljs-keyword">end</span>

sig { params(<span class="hljs-symbol">x:</span> T.class_of(Parent)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(x)</span></span>; <span class="hljs-keyword">end</span>

example(Grandparent)   <span class="hljs-comment"># error</span>
example(Parent)        <span class="hljs-comment"># ok</span>
example(Child)         <span class="hljs-comment"># ok</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Aclass%20Grandparent%3B%20end%0Aclass%20Parent%20%3C%20Grandparent%3B%20end%0Aclass%20Child%20%3C%20Parent%3B%20end%0A%0Asig%20%7Bparams(x%3A%20T.class_of(Parent)).void%7D%0Adef%20example(x)%3B%20end%0A%0Aexample(Grandparent)%20%20%20%23%20error%0Aexample(Parent)%20%20%20%20%20%20%20%20%23%20ok%0Aexample(Child)%20%20%20%20%20%20%20%20%20%23%20ok">
→ View on sorbet.run
</a></p>
<p>In this example, the <code>Child</code> class object passed to the <code>example</code> method on the last line has type <code>T.class_of(Child)</code>. The <code>example</code> takes <code>T.class_of(Parent)</code>. When one class inherits another, it’s singleton class also inherits the other class’s singleton class:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># On the class itself, Child &lt; Parent</span>
Child.ancestors
<span class="hljs-comment"># =&gt; [Child, Parent, Grandparent, Object, Kernel, BasicObject]</span>

<span class="hljs-comment"># On the singleton class, #&lt;Class:Child&gt; &lt; #&lt;Class:Parent&gt;</span>
Child.singleton_class.ancestors
<span class="hljs-comment"># =&gt; [#&lt;Class:Child&gt;, #&lt;Class:Parent&gt;, #&lt;Class:Grandparent&gt;, #&lt;Class:Object&gt;,</span>
      <span class="hljs-comment">#&lt;Class:BasicObject&gt;, Class, Module, Object, Kernel, BasicObject]</span>
</code></pre>
<p>Importantly, this only happens for classes, not modules: the singleton class of a module is <em>never</em> the ancestor of some other class. See the next section for more.</p>
<h2><a class="anchor" aria-hidden="true" id="tclass_of-and-modules"></a><a href="#tclass_of-and-modules" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T.class_of</code> and modules</h2>
<p>Usually when people write <code>T.class_of(MyInterface)</code>, what they actually want is either:</p>
<ul>
<li>To rewrite the code to use abstract classes instead of interfaces, and then use <code>T.class_of(MyAbstractClass)</code>, or</li>
<li>To use a type like <code>T.all(T::Class[MyInterface], MyInterface::ClassMethods)</code></li>
</ul>
<p>To showcase why <code>T.class_of(MyInterface)</code> is usually a problem and why these two are better solutions, let’s walk through an example. The full code for this example is available here:</p>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aclass%20Module%3B%20include%20T%3A%3ASig%3B%20end%0A%0Amodule%20MyInterface%0A%20%20extend%20T%3A%3AHelpers%0A%0A%20%20def%20some_instance_method%3B%20end%0A%0A%20%20module%20ClassMethods%0A%20%20%20%20def%20some_class_method%3B%20end%0A%20%20end%0A%20%20mixes_in_class_methods%28ClassMethods%29%0Aend%0A%0Aclass%20MyClass%0A%20%20include%20MyInterface%0Aend%0A%0Asig%20%7Bparams%28x%3A%20T.class_of%28MyClass%29%29.void%7D%0Adef%20example1%28x%29%0A%20%20x.new.some_instance_method%20%20%23%20ok%0A%20%20x.some_class_method%20%20%20%20%20%20%20%20%20%23%20ok%0Aend%0A%0Aexample1%28MyClass%29%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20ok%0A%0Asig%20%7Bparams%28x%3A%20T.class_of%28MyInterface%29%29.void%7D%0Adef%20example2%28x%29%0A%20%20x.new.some_instance_method%20%20%23%20error%3A%20%60new%60%20does%20not%20exist%0A%20%20x.some_class_method%20%20%20%20%20%20%20%20%20%23%20error%3A%20%60some_class_method%60%20does%20not%20exist%0Aend%0A%0Aexample2%28MyClass%29%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20error%3A%20Expected%20%60T.class_of%28MyInterface%29%60%20but%20found%20%60T.class_of%28MyClass%29%60%0A%0Asig%20%7Bparams%28x%3A%20T.all%28T%3A%3AClass%5BMyInterface%5D%2C%20MyInterface%3A%3AClassMethods%29%29.void%7D%0Adef%20example3%28x%29%0A%20%20x.new.some_instance_method%20%20%23%20ok%0A%20%20x.some_class_method%20%20%20%20%20%20%20%20%20%23%20ok%0Aend%0A%0Aexample3%28MyClass%29%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20ok">
→ View on sorbet.run
</a></p>
<p>Suppose we have some code like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">some_instance_method</span>;</span> <span class="hljs-keyword">end</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">some_class_method</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sig { params(<span class="hljs-symbol">x:</span> T.class_of(MyClass)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example1</span><span class="hljs-params">(x)</span></span>
  x.new.some_instance_method  <span class="hljs-comment"># ok</span>
  x.some_class_method         <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>

example1(MyClass)             <span class="hljs-comment"># ok</span>
</code></pre>
<p><code>MyClass</code> declares a class which has an instance method and a class method. The <code>T.class_of(MyClass)</code> annotation allows <code>example1</code> to call both those methods. None of this is surprising.</p>
<p>Now imagine that we have a lot of these classes and we want to factor out an interface. The straightforward way to factor out an interface that defines both instance and singleton class methods uses <a href="abstract#interfaces-and-the-included-hook"><code>mixes_in_class_methods</code></a>, like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyInterface</span></span>
  extend T::Helpers

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">some_instance_method</span>;</span> <span class="hljs-keyword">end</span>

  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">ClassMethods</span></span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">some_class_method</span>;</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
  mixes_in_class_methods(ClassMethods)
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-keyword">include</span> MyInterface
<span class="hljs-keyword">end</span>
</code></pre>
<p>This will make <code>some_instance_method</code> and <code>some_class_method</code> available on <code>MyClass</code>, just like before. But if we try to replace <code>T.class_of(MyClass)</code> with <code>T.class_of(MyInterface)</code>, it doesn’t work:</p>
<pre><code class="hljs css language-ruby">sig { params(<span class="hljs-symbol">x:</span> T.class_of(MyInterface)).void }  <span class="hljs-comment"># ← sig has changed</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example2</span><span class="hljs-params">(x)</span></span>
  x.new.some_instance_method  <span class="hljs-comment"># error: `new` does not exist</span>
  x.some_class_method         <span class="hljs-comment"># error: `some_class_method` does not exist</span>
<span class="hljs-keyword">end</span>

example2(MyClass)             <span class="hljs-comment"># error: Expected `T.class_of(MyInterface)`</span>
                              <span class="hljs-comment">#        but found `T.class_of(MyClass)`</span>
</code></pre>
<p><strong>These errors are correct</strong>. Conceptually, <code>T.class_of(MyInterface)</code> represents the type of the <code>MyInterface</code> class object <em>itself</em>, not “any class object whose instances implement <code>MyInterface</code>.” We can verify these errors are correct in the repl.</p>
<p>First, we can explain the error on the call to <code>example2</code> by looking at ancestors:</p>
<pre><code class="hljs css language-plaintext">❯ MyClass.singleton_class.ancestors
=&gt; [#&lt;Class:MyClass&gt;, MyInterface::ClassMethods,
    #&lt;Class:Object&gt;, T::Private::Methods::MethodHooks, #&lt;Class:BasicObject&gt;,
    Class, Module, T::Sig, Object, Kernel, BasicObject]
</code></pre>
<p>The first two ancestors of the <code>MyClass</code> singleton class are itself and <code>MyInterface::ClassMethods</code>. But notably, <code>#&lt;Class:MyInterface&gt;</code> <strong>does not</strong> appear in this list, so Sorbet is correct to say that <code>MyClass</code> does not have type <code>T.class_of(MyInterface)</code>. This is because neither <code>include</code> nor <code>extend</code> in Ruby will cause <code>#&lt;Class:MyInterface&gt;</code> to appear in any ancestors list.</p>
<p>Next, let’s explain the other two errors:</p>
<pre><code class="hljs css language-plaintext">❯ MyInterface.singleton_class.ancestors
=&gt; [#&lt;Class:MyInterface&gt;,
    T::Private::MixesInClassMethods, T::Helpers, Module, T::Sig, Object,
    Kernel, BasicObject]
</code></pre>
<p>For the <code>MyInterface</code> singleton class, we see that its only ancestor is itself (ignoring common ancestors like <code>Object</code>). Notably, <strong>none</strong> of the classes in this list define either a method called <code>new</code> (because <code>Class</code> is not there) nor <code>some_class_method</code> (because <code>MyInterface::ClassMethods</code> is not there).</p>
<p>While these errors are technically correct, we want to be able to type this code. There are two options:</p>
<ol>
<li><p>Use an abstract class instead of an interface.</p>
<p>If this option is available, it’s likely the most straightforward. If we change <code>MyInterface</code> to <code>MyAbstractClass</code>, all our problems vanish. Sometimes this is not possible, because the class in question already has a superclass that can’t be changed.</p></li>
<li><p>Use <code>T.all(T::Class[MyInterface], MyInterface::ClassMethods)</code>.</p></li>
</ol>
<p>Specifically, option (2) looks like this:</p>
<pre><code class="hljs css language-ruby">sig { params(<span class="hljs-symbol">x:</span> T.all(T::Class[MyInterface], MyInterface::ClassMethods)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example3</span><span class="hljs-params">(x)</span></span>
  x.new.some_instance_method  <span class="hljs-comment"># ok</span>
  x.some_class_method         <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>

example3(MyClass)             <span class="hljs-comment"># OK</span>
</code></pre>
<p>We discuss <code>T::Class</code> more in the next section. To break down that large type:</p>
<ul>
<li><p><code>T.all</code> is an <a href="/docs/intersection-types">Intersection Type</a>, which says that <code>x</code> has both the type <code>T::Class[MyInterface]</code> and <code>MyInterface::ClassMethods</code>. It’s allowed to call all the methods defined on those types individually.</p></li>
<li><p><code>T::Class[MyInterface]</code> is a type that represents “any class object which, when instantiated, creates instances that at least have type <code>MyInterface</code>.” Other than that, it says nothing about what singleton class methods the class object has, which means it only assumes those that are defined on <code>::Class</code> in the Ruby standard library (basically, just <code>.new</code> and <code>.name</code>). But Sorbet is smart enough to know that objects created by calling <code>new</code> have type <code>MyInterface</code>, and thus that <code>some_instance_method</code> exists.</p></li>
<li><p><code>MyInterface::ClassMethods</code></p>
<p>This module holds all of the interface’s class methods, including <code>some_class_methods</code>.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="tclass-vs-tclass_of"></a><a href="#tclass-vs-tclass_of" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T::Class</code> vs <code>T.class_of</code></h2>
<p><code>T::Class</code> was designed to model some mismatches between how people think they can use <code>T.class_of</code> and how <code>T.class_of</code> actually works. <code>T::Class</code> is powered by Sorbet’s support for <a href="/docs/generics">generic classes</a>, and is therefore a good choice for writing code that abstracts over class objects.</p>
<p>What are these mismatches? <code>T.class_of(...)</code> is, simply, a type representing the singleton class of <code>A</code>, matching how singleton classes work in Ruby as closely as possible. However:</p>
<ul>
<li>Arbitrary types don’t necessarily have singleton classes: for example, <code>T.class_of(T.noreturn)</code> is not a valid type, and neither is <code>T.class_of(T.any(A, B))</code>.</li>
<li>As we saw in the previous section, <code>T.class_of(MyInterface)</code> <strong>does not mean</strong> “any class object which, when instantiated, creates instances that at least have type <code>MyInterface</code>.”</li>
</ul>
<p>Sorbet provides <code>T::Class</code> to relax these restrictions. Like other <code>T::</code>-prefixed types, this is a <a href="/docs/stdlib-generics">typed wrapper</a> for the <code>::Class</code> class defined in the Ruby standard library. It’s also a <a href="/docs/generics">generic class</a>, which means it can be given an arbitrary type, unlike <code>T.class_of(...)</code> which can only be given a class name, not an arbitrary type). And finally, the generic type parameter on <code>T::Class</code> uses the same internal mechanism as Sorbet’s <a href="/docs/attached-class"><code>T.attached_class</code> type</a>, which represents “an instance of the current class.”</p>
<p>Combined, these features allow <code>T::Class[...]</code> to model some common Ruby patterns. For example:</p>
<pre><code class="hljs css language-ruby">sig <span class="hljs-keyword">do</span>
  type_parameters(<span class="hljs-symbol">:Instance</span>)
    .params(<span class="hljs-symbol">klass:</span> T::Class[T.type_parameter(<span class="hljs-symbol">:Instance</span>)])
    .returns(T.type_parameter(<span class="hljs-symbol">:Instance</span>))
<span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">instantiate_class</span><span class="hljs-params">(klass)</span></span>
  instance = klass.new
  puts(<span class="hljs-string">"Instantiated: <span class="hljs-subst">#{instance}</span>"</span>)
  instance
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-comment"># converts T.class_of(A) -&gt; A</span>
a = instantiate_class(A)

<span class="hljs-comment"># converts T.class_of(B) -&gt; B</span>
b = instantiate_class(B)
</code></pre>
<p>The example above uses <a href="/docs/generics#generic-methods">a generic method</a> to take any class object, instantiate it, and understand that the return value’s type is the <a href="/docs/attached-class">attached class</a> of the class object that was passed in. Calling <code>instantiate_class(A)</code> takes a value of type <code>T.class_of(A)</code> and produces a value of type <code>A</code>. <code>T::Class[T.type_parameter(:U)]</code> is a type we can actually write because <code>T::Class</code> is a full-fledged generic class. By contrast, we can’t write <code>T.class_of(T.type_parameter(:U))</code>,because an arbitrary type like <code>T.type_parameter(:U)</code> might not have a singleton class.</p>
<p>Another example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">AbstractCommand</span></span>
  extend T::Helpers
  interface!
  sig { abstract.void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCommand</span></span>
  <span class="hljs-keyword">include</span> AbstractCommand

  sig { override.void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>;</span> puts(<span class="hljs-string">"Hello, world!"</span>); <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sig { params(<span class="hljs-symbol">command_klass:</span> T::Class[AbstractCommand]).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_command</span><span class="hljs-params">(command_klass)</span></span>
  <span class="hljs-comment"># (1) Instantiate some command class</span>
  command = command_klass.new
  T.reveal_type(command) <span class="hljs-comment"># =&gt; AbstractCommand</span>
  <span class="hljs-comment"># (2) Run the command</span>
  command.run
<span class="hljs-keyword">end</span>

run_command(MyCommand)
</code></pre>
<p>In this example, we use <code>T::Class</code> to place a constraint on the class object’s attached class. The <code>run_command</code> method takes class objects, but only those whose attached classes implement the <code>AbstractCommand</code> interface. At point (1) we use the class object to instantiate <code>command_class</code>, and Sorbet understands that the resulting value has type <code>AbstractCommand</code>. This allows point (2) to type check, because Sorbet will know that the <code>.run</code> method exists.</p>
<h3><a class="anchor" aria-hidden="true" id="why-have-both-tclass_of-and-tclass"></a><a href="#why-have-both-tclass_of-and-tclass" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why have both <code>T.class_of</code> and <code>T::Class</code>?</h3>
<p>There are some things that are only possible to represent with <code>T.class_of</code>, and some things that are only possible to represent with <code>T::Class</code>.</p>
<ul>
<li><p><code>T::Class</code> is generic in its attached class. It can be applied to an arbitrary type, which means that things like <code>T::Class[T.any(A, B)]</code> and <code>T::Class[MyInterface]</code> work.</p>
<p>By contrast, it’s simply a syntax error to write <code>T.class_of(T.any(A, B))</code> (because this doesn’t resolve to a single singleton class), and <code>T.class_of(MyInterface)</code> means something different from what people might otherwise expect it to mean.</p></li>
<li><p><code>T.class_of</code> knows what methods are on the singleton class of a class. By contrast, given this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The type <code>T::Class[MyClass]</code> isn’t aware of what singleton class methods exist on that class object, only that the associated instance type is. But <code>T.class_of(MyClass)</code> represents both what singleton class methods exist, and also that creating an instance of this class will have type <code>MyClass</code>.</p></li>
</ul>
<p>So these two types are similar, but each has functionality unique to itself.</p>
<p>The fact that the names are so similar is an unfortunate consequence of history. It might have been better to use syntax like <code>T.singleton_class(A)</code> (or maybe even <code>A.singleton_class</code>) if we could have anticipated that we would eventually want to build <code>T::Class</code> one day.</p>
<h3><a class="anchor" aria-hidden="true" id="tclass-vs-class"></a><a href="#tclass-vs-class" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T::Class</code> vs <code>Class</code></h3>
<p>In old versions of Sorbet, the <code>::Class</code> class in the Ruby standard library was not generic. In versions of Sorbet that support <code>T::Class</code>, <code>::Class</code> became generic. Sorbet requires that generic classes in type annotations not be bare–they must be applied to a type argument.</p>
<p>For more information, see <a href="/docs/stdlib-generics#generic-class-without-type-arguments">this section in the docs</a>.</p>
<p>The difference between <code>T::Class</code> and <code>Class</code> is the same as the difference between <code>T::Array</code> and <code>Array</code>. <code>T::Class</code> and <code>Class</code> represent the same class definition in the standard library, but <code>T::Class</code> allows passing type arguments to the generic type parameters defined in <code>Class</code>. This error is only reported at <a href="/docs/static"><code># typed: strict</code> or higher</a>. At lower levels, Sorbet implicitly assumes that a bare type annotation like <code>Class</code> is the same as <code>T::Class[T.anything]</code>. (See <a href="/docs/anything"><code>T.anything</code></a>.)</p>
<p>Feel free to replace <code>Class</code> with <code>T::Class[T.anything]</code> in type annotations where nothing is known about the class object. If there’s an obvious more specific type, feel free to narrow <code>T.anything</code> to whatever the more specific type is.</p>
<h3><a class="anchor" aria-hidden="true" id="tclass_of-applying-type-arguments-to-a-singleton-class-type"></a><a href="#tclass_of-applying-type-arguments-to-a-singleton-class-type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T.class_of(...)[...]</code>: Applying type arguments to a singleton class type</h3>
<p>For this entire discussion of <code>T.class_of</code>, we’ve been hiding something: Sorbet implicitly treats the singleton classes of classes (not modules) as generic classes. This means that just like how <code>T::Class[T.type_parameter(:Instance)]</code> is a valid type, so is <code>T.class_of(MyClass)[T.type_parameter(:Instance)]</code>.</p>
<p>Normally, Sorbet hides this fact from users. Whenever it sees something like <code>T.class_of(MyClass)</code>, it implicitly assumes the type the user wanted to write was <code>T.class_of(MyClass)[MyClass]</code>. This type represents the singleton class of <code>MyClass</code>, and makes it clear that the attached class of this singleton class is <code>MyClass</code> explicitly.</p>
<p>To further clarify, let’s consider this method:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">some_singleton_method</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sig <span class="hljs-keyword">do</span>
  type_parameters(<span class="hljs-symbol">:Instance</span>)
    .params(<span class="hljs-symbol">klass:</span> T::Class[T.type_parameter(<span class="hljs-symbol">:Instance</span>)])
    .returns(T.type_parameter(<span class="hljs-symbol">:Instance</span>))
<span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(klass)</span></span>
  klass.some_singleton_method
  <span class="hljs-comment">#     ^^^^^^^^^^^^^^^^^^^^^ error!</span>
  klass.new
<span class="hljs-keyword">end</span>
</code></pre>
<p>This snippet doesn’t work because <code>T::Class</code> says “I’ll take <em>any</em> singleton class object” but says nothing about what methods might exist on that object.</p>
<p>We can fix this error by using <code>T.class_of</code> with an explicit type application:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">some_singleton_method</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sig <span class="hljs-keyword">do</span>
  type_parameters(<span class="hljs-symbol">:Instance</span>)
    .params(
      <span class="hljs-symbol">klass:</span> T.class_of(MyClass)[T.all(MyClass, T.type_parameter(<span class="hljs-symbol">:Instance</span>))]
    )
    .returns(T.type_parameter(<span class="hljs-symbol">:Instance</span>))
<span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(klass)</span></span>
  klass.some_singleton_method
  <span class="hljs-comment">#     ^^^^^^^^^^^^^^^^^^^^^ okay!</span>
  klass.new
<span class="hljs-keyword">end</span>
</code></pre>
<p>This works because the <code>T.class_of(...)</code> tells Sorbet what singleton class methods exist, and the <code>[...]</code> tells Sorbet what type an object instantiated from that class has.</p>
<p>The <code>T.all</code> is an <a href="/docs/intersection-types">Intersection Type</a> and is needed because unlike <code>T::Class</code>, which allows being applied to any type, the type applied to <code>T.class_of(MyClass)</code> must be a subtype of <code>MyClass</code>. The intersection is a way to <a href="/docs/generics#placing-bounds-on-generic-methods">approximate placing bounds on generic methods</a>.</p>
<p>This <code>T.class_of(...)[...]</code> syntax generalizes–it can be used to apply types to singleton classes with user-defined <code>type_template</code>s as well. Given a class like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherClass</span></span>
  extend T::Generic
  MyTypeTemplate = type_template
<span class="hljs-keyword">end</span>
</code></pre>
<p>It’s possible to apply a type argument to <code>MyTypeTemplate</code> with code like</p>
<pre><code class="hljs css language-ruby">T.class_of(AnotherClass)[AnotherClass, Integer]
</code></pre>
<p>Sorbet still requires that the first argument must be the type for the attached class, and then the remaining arguments apply to each <code>type_template</code> the class defines, in turn.</p>
<h2><a class="anchor" aria-hidden="true" id="tmodule-vs-tclass"></a><a href="#tmodule-vs-tclass" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T::Module</code> vs <code>T::Class</code></h2>
<p><code>T::Module</code> is just like <code>T::Class</code>, but for arbitrary module objects. That is: <code>T::Module</code> is a generic wrapper for the <code>::Module</code> class defined in the Ruby standard library. Things defined with the <code>module</code> keyword are instances of <code>Module</code>, just like things defined with the <code>class</code> keyword are instances of <code>Class</code>. Said another way, in code:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>;</span> <span class="hljs-keyword">end</span>
puts(C<span class="hljs-class">.<span class="hljs-keyword">class</span>)           <span class="hljs-comment"># =&gt; Class</span></span>
T.let(C, T::Class[C])   <span class="hljs-comment"># =&gt; ✅</span>
T.let(C, T::Module[C])  <span class="hljs-comment"># =&gt; ✅</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">M</span>;</span> <span class="hljs-keyword">end</span>
puts(M<span class="hljs-class">.<span class="hljs-keyword">class</span>)           <span class="hljs-comment"># =&gt; Module</span></span>
T.let(M, T::Class[M])   <span class="hljs-comment"># =&gt; ⛔️</span>
T.let(M, T::Module[M])  <span class="hljs-comment"># =&gt; ✅</span>
</code></pre>
<p>Ruby chooses to model these two classes (i.e., the <code>Class</code> class and the <code>Module</code> class) using inheritance. In Ruby, every <code>Class</code> is a <code>Module</code>, but not every <code>Module</code> is a <code>Class</code>. This makes sense, because class objects have all the methods available on module objects (like <code>mod.name</code>, <code>mod.const_get</code>, etc.), but also have a few methods that are unique to classes (like <code>klass.new</code>, i.e., only classes not modules can be instantiated). Said another way, in code:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># these are defined in the Ruby standard library:</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> ::<span class="hljs-title">Module</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>;</span> <span class="hljs-keyword">end</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">const_get</span><span class="hljs-params">(cnst)</span></span>; <span class="hljs-keyword">end</span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> ::<span class="hljs-title">Class</span> &lt; ::<span class="hljs-title">Module</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span><span class="hljs-params">(...)</span></span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Just like <code>T::Class[...]</code>, <code>T::Module[...]</code> can take an arbitrary type, like <a href="/docs/generics#generic-methods"><code>T.type_parameter(:U)</code></a> or <a href="/docs/union-types"><code>T.any(A, B)</code></a> or <a href="/docs/anything"><code>T.anything</code></a> (not just a simple class or module name, like <code>T.class_of(...)</code>).</p>
<p>Somewhat counterintuitively, this means that <code>T::Class[SomeModule]</code> and <code>T::Module[SomeClass]</code> are both valid types:</p>
<ul>
<li><code>T::Class[SomeModule]</code> means &quot;any <code>class</code> object that has included <code>SomeModule</code>&quot;</li>
<li><code>T::Module[SomeClass]</code> means “any <code>module</code> object that inherits from <code>SomeClass</code>.” It’s kind of a weird type, because anything that inherits from <code>SomeClass</code> must necessarily also be a <code>Class</code>, so this could most likely be replaced with <code>T::Class[SomeClass]</code> for free. But explicitly annotating something as <code>T::Module[...]</code> prohibits calling any <code>Class</code>-specific methods, like <code>.new</code>, and maybe this is a guarantee you want to enforce in the type system.</li>
</ul>
<p>Use <code>T::Module[...]</code> over <code>T::Class[...]</code> for methods that can accept any module object, and want to be able to operate on the attached class. For example:</p>
<pre><code class="hljs css language-ruby">sig {
  type_parameters(<span class="hljs-symbol">:Attached</span>)
    .params(
      <span class="hljs-symbol">x:</span> T.anything,
      <span class="hljs-symbol">mod:</span> T::Module[T.type_parameter(<span class="hljs-symbol">:Attached</span>)]
    )
    .returns(T.nilable(T.type_parameter(<span class="hljs-symbol">:Attached</span>)))
}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validate_against_module</span><span class="hljs-params">(x, mod)</span></span>
  <span class="hljs-keyword">case</span> x
  <span class="hljs-keyword">when</span> mod <span class="hljs-keyword">then</span> x
  <span class="hljs-keyword">else</span> <span class="hljs-literal">nil</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

data = JSON.parse(File.read(<span class="hljs-string">'foo.json'</span>))
T.reveal_type(data) <span class="hljs-comment"># =&gt; T.untyped</span>

validated = validate_against_module(data, Enumerable)
T.reveal_type(validated) <span class="hljs-comment"># =&gt; T.nilable(T::Enumerable[T.untyped])</span>

validated = validated&amp;.map {<span class="hljs-params">|item|</span> validate_against_module(item, Integer) }
T.reveal_type(validated) <span class="hljs-comment"># =&gt; T.nilable(T::Array[T.nilable(Integer)])</span>
</code></pre>
<p>This <code>validate_against_module</code> method only uses <code>mod</code> in a <code>case</code> statement, i.e., it only uses the <code>mod.===(x)</code>, the <a href="https://docs.ruby-lang.org/en/master/Module.html#method-i-3D-3D-3D">case equality operator</a>. Accepting <code>T::Module[...]</code> instead of <code>T::Class[...]</code> allows this method to be maximally permissive, and we see it called with both a module (<code>Enumerable</code>) and a class (<code>Integer</code>).</p>
<p>For further reading:</p>
<ul>
<li>Be sure to read all about <code>T::Class[...]</code>, because basically everything that is true about how <code>T::Class[...]</code> works also holds for <code>T::Module[...]</code> from a type system perspective. For example:
<ul>
<li><code>T::Module</code> is to <code>Module</code> like <code>T::Array</code> is to <code>Array</code>: it’s a generic wrapper that allows passing type arguments without needing to define a <code>[]</code> method</li>
<li><code>Module</code> another way of writing <code>T::Module[T.anything]</code>. At <code># typed: strict</code> and above, it’s an error to have a bare <code>Module</code> without specifying an explicit type argument</li>
<li>This feature is powered by <a href="/docs/generics">generic classes</a> and is related to <a href="/docs/attached-class">T.attached_class</a></li>
</ul></li>
<li>See the <a href="https://docs.ruby-lang.org/en/master/Class.html">class Class documentation</a> in the official Ruby docs
<ul>
<li>There’s a neat ASCII art diagram of the top of the Ruby class hierarchy</li>
</ul></li>
<li>Browse Sorbet’s definitions for these two classes: <a href="https://github.com/sorbet/sorbet/blob/master/rbi/core/class.rbi#L71">class.rbi</a>, <a href="https://github.com/sorbet/sorbet/blob/master/rbi/core/module.rbi#L26">module.rbi</a>
<ul>
<li>defined in Sorbet’s <a href="/docs/rbi">RBI files</a> for the Ruby standard library</li>
</ul></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/sealed"><span class="arrow-prev">← </span><span>Sealed Classes</span></a><a class="docs-next button" href="/docs/self-type"><span>T.self_type</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#what-is-a-tclass_of-type">What is a <code>T.class_of</code> type?</a></li><li><a href="#tclass_of-and-inheritance"><code>T.class_of</code> and inheritance</a></li><li><a href="#tclass_of-and-modules"><code>T.class_of</code> and modules</a></li><li><a href="#tclass-vs-tclass_of"><code>T::Class</code> vs <code>T.class_of</code></a><ul class="toc-headings"><li><a href="#why-have-both-tclass_of-and-tclass">Why have both <code>T.class_of</code> and <code>T::Class</code>?</a></li><li><a href="#tclass-vs-class"><code>T::Class</code> vs <code>Class</code></a></li><li><a href="#tclass_of-applying-type-arguments-to-a-singleton-class-type"><code>T.class_of(...)[...]</code>: Applying type arguments to a singleton class type</a></li></ul></li><li><a href="#tmodule-vs-tclass"><code>T::Module</code> vs <code>T::Class</code></a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer"><svg width="99" height="28" viewBox="0 0 99 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.98432 20H6.27432C8.44932 20 9.81432 18.905 9.81432 17.03C9.81432 15.665 9.00432 14.72 7.78932 14.39C8.61432 14.105 9.45432 13.415 9.45432 12.035C9.45432 10.235 8.23932 9.23 5.95932 9.23H1.98432V20ZM3.37932 13.85V10.445H5.83932C7.27932 10.445 8.07432 11 8.07432 12.155C8.07432 13.295 7.27932 13.85 5.83932 13.85H3.37932ZM3.37932 15.08H6.21432C7.65432 15.08 8.43432 15.83 8.43432 16.925C8.43432 18.035 7.65432 18.785 6.21432 18.785H3.37932V15.08ZM18.0294 12.155H16.6794V16.88C16.6794 18.185 15.6894 18.92 14.7144 18.92C13.5594 18.92 13.0794 18.17 13.0794 17.06V12.155H11.7294V17.345C11.7294 19.01 12.6744 20.165 14.3544 20.165C15.4644 20.165 16.2294 19.58 16.6794 18.92V20H18.0294V12.155ZM20.5112 10.79H21.9812V9.23H20.5112V10.79ZM21.9212 12.155H20.5712V20H21.9212V12.155ZM25.8247 9.23H24.4747V20H25.8247V9.23ZM28.5882 18.125C28.5882 19.625 29.3532 20.075 30.6882 20.075C31.1382 20.075 31.5282 20.03 31.8732 19.955V18.8C31.5582 18.875 31.3332 18.89 31.0182 18.89C30.3282 18.89 29.9232 18.74 29.9232 17.915V13.31H31.7082V12.155H29.9232V9.86H28.5882V12.155H27.3732V13.31H28.5882V18.125ZM41.0199 20.165C43.1949 20.165 44.4399 18.305 44.4399 16.085C44.4399 13.85 43.1949 12.005 41.0199 12.005C39.9249 12.005 39.0549 12.53 38.5899 13.295V9.23H37.2399V20H38.5899V18.86C39.0549 19.64 39.9249 20.165 41.0199 20.165ZM38.5599 15.815C38.5599 13.985 39.6699 13.19 40.7799 13.19C42.2499 13.19 43.0749 14.39 43.0749 16.085C43.0749 17.765 42.2499 18.98 40.7799 18.98C39.6699 18.98 38.5599 18.17 38.5599 16.37V15.815ZM49.1804 20.855L52.5554 12.155H51.1454L48.9704 18.155L46.7654 12.155H45.3404L48.2504 19.715L47.8754 20.645C47.5604 21.425 47.2454 21.635 46.6604 21.635C46.4354 21.635 46.2704 21.62 46.0154 21.56V22.73C46.2554 22.775 46.4204 22.79 46.7504 22.79C48.1154 22.79 48.7304 22.04 49.1804 20.855Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M98.7993 15.7838C98.7993 12.8786 97.3871 10.5862 94.688 10.5862C91.9774 10.5862 90.3374 12.8786 90.3374 15.7611C90.3374 19.177 92.2735 20.9019 95.0524 20.9019C96.4077 20.9019 97.4327 20.5955 98.2071 20.1643V17.8946C97.4327 18.2804 96.5443 18.5188 95.4168 18.5188C94.3121 18.5188 93.3327 18.1329 93.2074 16.7938H98.7766C98.7766 16.6463 98.7993 16.0561 98.7993 15.7838ZM93.1732 14.7057C93.1732 13.4233 93.9591 12.8899 94.6766 12.8899C95.3713 12.8899 96.1116 13.4233 96.1116 14.7057H93.1732Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M85.9413 10.5862C84.8251 10.5862 84.1076 11.1082 83.709 11.4714L83.561 10.7678H81.0554V24.0001L83.9026 23.3986L83.914 20.187C84.324 20.482 84.9276 20.9019 85.9299 20.9019C87.9685 20.9019 89.8249 19.2678 89.8249 15.6703C89.8135 12.3792 87.9343 10.5862 85.9413 10.5862ZM85.2579 18.4053C84.586 18.4053 84.1874 18.167 83.914 17.8719L83.9026 13.6616C84.1988 13.3325 84.6088 13.1055 85.2579 13.1055C86.2943 13.1055 87.0118 14.2631 87.0118 15.7497C87.0118 17.2704 86.3057 18.4053 85.2579 18.4053Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M77.1377 9.91656L79.9963 9.30374V7L77.1377 7.60147V9.91656Z" fill="white"></path><path d="M79.9963 10.7791H77.1377V20.709H79.9963V10.7791Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M74.074 11.6187L73.8918 10.7789H71.4318V20.7088H74.279V13.9792C74.9509 13.1054 76.0898 13.2642 76.4429 13.3891V10.7789C76.0784 10.6427 74.7459 10.3931 74.074 11.6187Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M68.3796 8.31641L65.6007 8.90653L65.5894 17.9966C65.5894 19.6762 66.8535 20.9132 68.5391 20.9132C69.473 20.9132 70.1563 20.743 70.5321 20.5387V18.235C70.1677 18.3825 68.3682 18.9045 68.3682 17.225V13.1962H70.5321V10.779H68.3682L68.3796 8.31641Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M60.6807 13.6616C60.6807 13.219 61.0452 13.0488 61.6488 13.0488C62.5143 13.0488 63.6076 13.3098 64.4732 13.7751V11.1082C63.5279 10.7337 62.594 10.5862 61.6488 10.5862C59.3368 10.5862 57.7993 11.7891 57.7993 13.7978C57.7993 16.93 62.1271 16.4306 62.1271 17.7811C62.1271 18.3031 61.6715 18.4734 61.0338 18.4734C60.0885 18.4734 58.8813 18.0875 57.9246 17.5655V20.2664C58.9838 20.7204 60.0543 20.9133 61.0338 20.9133C63.4026 20.9133 65.0313 19.7444 65.0313 17.713C65.0199 14.3312 60.6807 14.9326 60.6807 13.6616Z" fill="white"></path></svg><a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div><div id="csat-extension-config" data-notify="#sorbet-team"></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>