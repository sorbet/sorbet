<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Abstract Classes and Interfaces ¬∑ Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Sorbet supports abstract classes, abstract methods, and interfaces. Abstract methods ensure that a particular method gets implemented anywhere the class or module is inherited, included, or extended. An abstract class or module is one that contains one or more abstract methods. An interface is a class or module that must have only abstract methods."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Abstract Classes and Interfaces ¬∑ Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="Sorbet supports abstract classes, abstract methods, and interfaces. Abstract methods ensure that a particular method gets implemented anywhere the class or module is inherited, included, or extended. An abstract class or module is one that contains one or more abstract methods. An interface is a class or module that must have only abstract methods."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5H7PQ9Z8KF"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'G-5H7PQ9Z8KF');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>‚Ä∫</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ‚Üî Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">CLI Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/cli-ref">CLI Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/why-type-annotations">Why type annotations?</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/unsupported">Unsupported Ruby Features</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">sig</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations (non-sig)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">T.let, T.cast, T.must, T.bind</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types (Integer, String)</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types (T.nilable)</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types (T.any)</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow-Sensitivity (is_a?, nil?)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">T.type_alias</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness (T.absurd)</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/anything">T.anything</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types (T.all)</a></li><li class="navListItem"><a class="navItem" href="/docs/generics">Generics</a></li><li class="navListItem"><a class="navItem" href="/docs/strong">Banning untyped</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Ruby &amp; DSL Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/attr_reader">attr_reader</a></li><li class="navListItem"><a class="navItem" href="/docs/minitest">minitest</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Editor Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/lsp">Language Server (LSP)</a></li><li class="navListItem"><a class="navItem" href="/docs/server-status">Server Status</a></li><li class="navListItem"><a class="navItem" href="/docs/lsp-typed-level">LSP &amp; Typed Level</a></li><li class="navListItem"><a class="navItem" href="/docs/go-to-def">Go to Definition</a></li><li class="navListItem"><a class="navItem" href="/docs/hover">Hover</a></li><li class="navListItem"><a class="navItem" href="/docs/autocompletion">Autocompletion</a></li><li class="navListItem"><a class="navItem" href="/docs/references">Find All References</a></li><li class="navListItem"><a class="navItem" href="/docs/code-actions">Code Actions</a></li><li class="navListItem"><a class="navItem" href="/docs/outline">Outline &amp; Document Symbols</a></li><li class="navListItem"><a class="navItem" href="/docs/doc-comments">Documentation Comments</a></li><li class="navListItem"><a class="navItem" href="/docs/sig-suggestion">Suggesting sigs</a></li><li class="navListItem"><a class="navItem" href="/docs/highlight-untyped">Highlighting untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/sorbet-uris">sorbet: URIs</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/overloads">Overloads</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li><li class="navListItem"><a class="navItem" href="/docs/rbs-support">RBS Comments</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/abstract.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Abstract Classes and Interfaces</h1></header><article><div><span><p>Sorbet supports abstract classes, abstract methods, and interfaces. Abstract methods ensure that a particular method gets implemented anywhere the class or module is inherited, included, or extended. An abstract class or module is one that contains one or more abstract methods. An interface is a class or module that must have only abstract methods.</p>
<p>Keep in mind:</p>
<ul>
<li><code>abstract!</code> can be used to prevent a class from being instantiated.</li>
<li>Both <code>abstract!</code> and <code>interface!</code> allow the class or module to have <code>abstract</code> methods.</li>
<li>Mix in a module (via <code>include</code> or <code>extend</code>) to declare that a class implements an interface.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Most of the abstract and override checks are implemented statically, but some are still only implemented at runtime, most notably variance checks.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="creating-an-abstract-method"></a><a href="#creating-an-abstract-method" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating an abstract method</h2>
<p>To create an abstract method:</p>
<ol>
<li>Add <code>extend T::Helpers</code> to the class or module (in addition to <code>extend T::Sig</code>).</li>
<li>Add <code>abstract!</code> or <code>interface!</code> to the top of the class or module. (<em>All</em> methods must be abstract to use <code>interface!</code>.)</li>
<li>Add a <code>sig</code> with <code>abstract</code> to any methods that should be abstract, and thus implemented by a child.</li>
<li>Declare the method on a single line with an empty body.</li>
</ol>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Runnable</span></span>
  extend T::Sig
  extend T::Helpers                                    <span class="hljs-comment"># (1)</span>
  interface!                                           <span class="hljs-comment"># (2)</span>

  sig { abstract.params(<span class="hljs-symbol">args:</span> T::Array[String]).void }   <span class="hljs-comment"># (3)</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">(args)</span></span>; <span class="hljs-keyword">end</span>                                  <span class="hljs-comment"># (4)</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="implementing-an-abstract-method"></a><a href="#implementing-an-abstract-method" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementing an abstract method</h2>
<p>To implement an abstract method, define the method in the implementing class or module with an identical signature as the parent, except replacing <code>abstract</code> with <code>override</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span>
  extend T::Sig
  <span class="hljs-keyword">include</span> Runnable

  <span class="hljs-comment"># This implements the abstract `main` method from our Runnable module:</span>
  sig { override.params(<span class="hljs-symbol">args:</span> T::Array[String]).void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">(args)</span></span>
    puts <span class="hljs-string">'Hello, world!'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="additional-requirements"></a><a href="#additional-requirements" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Additional Requirements</h2>
<p>There are some additional stipulations on the use of <code>abstract!</code> and <code>interface!</code>:</p>
<ul>
<li>All methods in a module marked as <code>interface!</code> must have signatures, and must be marked <code>abstract</code>.
<ul>
<li><strong>Note</strong>: this applies to all methods defined within the module, as well as any that are included from another module</li>
</ul></li>
<li>A module marked <code>interface!</code> can‚Äôt have <code>private</code> or <code>protected</code> methods.</li>
<li>Any method marked <code>abstract</code> must have no body. <code>sorbet-runtime</code> will take care to raise an exception if an abstract method is called at runtime.</li>
<li>Classes without <code>abstract!</code> or <code>interface!</code> must implement all <code>abstract</code> methods from their parents.</li>
<li><code>extend MyAbstractModule</code> works just like <code>include MyAbstractModule</code>, but for singleton methods.</li>
<li><code>abstract!</code> classes cannot be instantiated (will raise at runtime).</li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="why-choose-interface-over-abstract"></a><a href="#why-choose-interface-over-abstract" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why choose <code>interface!</code> over <code>abstract!</code>?</h3>
<p>Apart from the differences listed above, the choice of whether to use <code>interface!</code> or <code>abstract!</code> comes down to preference and circumstance.</p>
<p>An example where the difference matters: people sometimes use <code>interface!</code> as the starting point for extracting logic across a network boundary into a new service. In this case, having implementation logic in the interface would complicate an in-progress migration: the logic should either live in the soon-to-be-extracted service, or the current service.</p>
<p>Similarly, <code>interface!</code> is a way to prevent accidental dependencies. Ruby applications developed in monorepos can use static analysis to list the files which must be included in a service‚Äôs deploy artifact or be preloaded at deploy time. (Tangled code leads a service to include more files than might be strictly necessary.) When these analyses use Ruby constant resolution-based algorithms, using an <code>interface!</code> guarantees that depending on the interface does not necessarily incur a dependency on some part of the implementation. This makes it easier to detangle and modularize dependencies.</p>
<p>In cases like these, the line with the <code>interface!</code> declaration serves as a great point to capture context around <strong>why</strong> the given module is the way it is in a comment. If no such context exists, and the other differences mentioned above are okay for the use case, it‚Äôs usually fine to switch from <code>interface!</code> to <code>abstract!</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="overridable-providing-default-implementations-of-methods"></a><a href="#overridable-providing-default-implementations-of-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>overridable</code>: Providing default implementations of methods</h2>
<p>Certain abstract classes or interfaces want to provide methods that provide a reasonable default implementation of a method, allowing individual children to override the method with a more specific implementation.</p>
<p>This is done with <code>overridable</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Countable</span></span>
  extend T::Helpers

  <span class="hljs-comment"># 1: `abstract!` instead of `interface!`</span>
  abstract!

  sig { abstract.returns(T.nilable(Integer)) }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_count</span>;</span> <span class="hljs-keyword">end</span>

  <span class="hljs-comment"># 2: Use `overridable` to provide default implementation of `to_count!`</span>
  sig { overridable.returns(Integer) }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_count!</span></span>
    T.must(<span class="hljs-keyword">self</span>.to_count)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>As the example shows, there are two main steps:</p>
<ol>
<li><p>If the module is not already <code>abstract!</code> (i.e., if it‚Äôs an <code>interface!</code>), change it to use <code>abstract!</code>. Modules declared with <code>interface!</code> are constrained to <em>only</em> have abstract methods, which prevents adding methods with a default implementation.</p></li>
<li><p>Use <code>overridable</code> to declare the default implementation of a method. Using <code>overridable</code> opts the method into static <a href="/docs/override-checking">override checking</a>, which will ensure that children define a type-compatible override.</p></li>
</ol>
<p>Note: if you want to provide functionality in an abstract class or module that <strong>must not</strong> be possible to override in a child, use a <a href="/docs/final">final method</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="letting-abstract-methods-be-implemented-via-inheritance"></a><a href="#letting-abstract-methods-be-implemented-via-inheritance" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Letting abstract methods be implemented via inheritance</h2>
<p>Sorbet allows abstract methods in modules to be implemented by an <strong>ancestor</strong> of the class or module they‚Äôre eventually mixed into. Consider this example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span> = <span class="hljs-title">puts</span> '<span class="hljs-title">Hello!</span>'</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">IFoo</span></span>
  extend T::Helpers
  abstract!

  sig { abstract.void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent <span class="hljs-comment"># ‚úÖ okay</span></span>
  <span class="hljs-keyword">include</span> IFoo
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotAParent</span> <span class="hljs-comment"># ‚ùå Missing definition for `foo`</span></span>
  <span class="hljs-keyword">include</span> IFoo
<span class="hljs-keyword">end</span>
</code></pre>
<p>Breaking down this example:</p>
<ul>
<li><p>The <code>IFoo</code> module declares a single, abstract <code>foo</code> method. All classes that include this module must either be marked abstract or define this method.</p></li>
<li><p>The <code>Parent</code> method does <strong>not</strong> depend on <code>IFoo</code>, <strong>but</strong> does happen to define a method called <code>foo</code>.</p></li>
<li><p>Both <code>Child</code> and <code>NotAParent</code> have <code>include IFoo</code>, but neither define a <code>foo</code> method.</p></li>
<li><p>Despite this: only <code>NotAParent</code> has an error saying that a concrete implementation of <code>foo</code> is missing. Sorbet allows the <code>foo</code> method to be implemented in <code>Child</code> because it inherits a <code>foo</code> method from <code>Parent</code>.</p></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="approximating-duck-types"></a><a href="#approximating-duck-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Approximating duck types</h3>
<p>This technique is particularly useful as a way to approximate ‚Äúduck typing,‚Äù where you depend on ‚Äúanything type, so long as it has this method.‚Äù</p>
<p>For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">ShortName</span></span>
  extend T::Helpers
  abstract!
  sig { abstract.returns(T.nilable(String)) }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>;</span> <span class="hljs-keyword">end</span>

  sig { returns(T.nilable(String)) }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">short_name</span></span>
    <span class="hljs-keyword">self</span>.name&amp;.split(<span class="hljs-string">'::'</span>)&amp;.last
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This module provides a <code>short_name</code> method (which computes the ‚Äúshort name‚Äù of a something like a <code>Module</code> by splitting the full name into <code>::</code>-delimited tokens and returning the last one. Like <code>C</code> for <code>module A::B::C</code>).</p>
<p>The module‚Äôs implementation depends on the <code>name</code> method existing. If we don‚Äôt declare it as an <code>abstract</code> method, Sorbet reports an error saying ‚ÄúMethod <code>name</code> does not exist,‚Äù which is true‚Äìthere‚Äôs no guarantee someone mixes this module into a context where <code>name</code> is defined.</p>
<p>But by declaring <code>name</code> as an abstract method, Sorbet will check this property. In particular, this has the effect of catching someone who accidentally uses <code>include</code> instead of <code>extend</code> when mixing this module into a class:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  <span class="hljs-keyword">include</span> ShortName <span class="hljs-comment"># ‚ùå error: Must define abstract method `name`</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>
  extend ShortName <span class="hljs-comment"># ‚úÖ</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This technique is particularly effective when it‚Äôs not possible to refactor some upstream dependency‚Äôs code to expose an explicit interface. The <code>Module</code> class in the Ruby stdlib doesn‚Äôt have some sort of public <code>INameable</code> interface with the <code>name</code> method. A handful of database model classes in an application might share a set of related fields, without explicitly implementing some interface. And yet, using this technique Sorbet allows writing modules which depend on those implicit interfaces.</p>
<p>This technique is also quite flexible: the <code>ShortName</code> module can be used in <strong>any</strong> context where a <code>name</code> method is available. So for example, if you had some <code>T::Struct</code> that stores a <code>name</code>, this <code>ShortName</code> mixin could also be used:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt; T::Struct</span>
  <span class="hljs-keyword">include</span> ShortName
  prop <span class="hljs-symbol">:name</span>, String, <span class="hljs-symbol">override:</span> <span class="hljs-symbol">:reader</span>
<span class="hljs-keyword">end</span>

C.new(<span class="hljs-symbol">name:</span> <span class="hljs-string">"Some::Long::Namespace"</span>).short_name <span class="hljs-comment"># =&gt; "Namespace"</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="consequences-for-runtime-signature-checking"></a><a href="#consequences-for-runtime-signature-checking" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Consequences for runtime signature checking</h3>
<p>Letting abstract methods be implemented by inherited methods relies on the fact that method signatures are <a href="/docs/runtime">checked at runtime</a>. To explain why this feature requires runtime support, let‚Äôs look at the resolved ancestors of <code>Child</code>:</p>
<pre><code class="hljs css language-plaintext">irb&gt; Child.ancestors
=&gt; [Child, IFoo, Parent, &lt;...&gt;]
</code></pre>
<p>This shows that Ruby resolves a call like <code>child.foo</code> by first checking whether <code>Child</code> defines <code>foo</code>, then whether <code>IFoo</code> defines <code>foo</code>, and then finally whether <code>Parent</code> does. Since it looks in <code>IFoo</code> <strong>before</strong> <code>Parent</code>, Ruby actually calls the <code>IFoo#foo</code> method. But this method would normally have an empty method body‚Äîit‚Äôs abstract!</p>
<p>So at runtime, the <code>sig</code> method replaces the implementation of <code>foo</code> with a method that does something like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
  <span class="hljs-keyword">if</span> <span class="hljs-keyword">defined</span>?(<span class="hljs-keyword">super</span>)
    <span class="hljs-keyword">super</span>
  <span class="hljs-keyword">else</span>
    raise NotImplementedError.new(<span class="hljs-string">"Call to unimplemented abstract method"</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This allows <code>IFoo#foo</code> to dispatch up the ancestor chain, letting <code>child.foo</code> result in a call to <code>Parent#foo</code>.</p>
<p>If runtime signature checking is disabled, a call like <code>child.foo</code> will silently produce <code>nil</code> instead of calling the appropriate method.</p>
<h2><a class="anchor" aria-hidden="true" id="abstract-singleton-methods"></a><a href="#abstract-singleton-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Abstract singleton methods</h2>
<p><code>abstract</code> singleton methods on a module are not allowed, as there‚Äôs no way to implement these methods.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">M</span></span>
  extend T::Sig
  extend T::Helpers

  abstract!

  sig { abstract.void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

M.foo <span class="hljs-comment"># error: `M.foo` can never be implemented</span>
</code></pre>
<p>Abstract singleton methods on a class <strong>are</strong> allowed, but are unsound (i.e., they can lead to runtime, type-related exceptions like <code>TypeError</code> and <code>NameError</code> even when there is no <code>T.untyped</code> involved):</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractParent</span></span>
  abstract!
  sig { abstract.void } <span class="hljs-comment"># ‚ùå BAD: abstract singleton class method!</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteChild</span> &lt; AbstractParent</span>
  sig { override.void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">foo</span> = <span class="hljs-title">puts</span><span class="hljs-params">(<span class="hljs-string">"hello!"</span>)</span></span>
<span class="hljs-keyword">end</span>

sig { params(<span class="hljs-symbol">klass:</span> T.class_of(AbstractParent)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(klass)</span></span>
  klass.foo
<span class="hljs-keyword">end</span>

example(ConcreteChild)  <span class="hljs-comment"># ‚úÖ okay</span>
example(AbstractParent) <span class="hljs-comment"># static:  ‚úÖ no errors</span>
                        <span class="hljs-comment"># runtime: üí• call to abstract method foo</span>
</code></pre>
<p>For more information, see this blog post:</p>
<p><a href="https://blog.jez.io/abstract-singleton-methods">Abstract singleton class methods are an abomination ‚Üí</a></p>
<p>The blog post above discusses the problem and three alternatives to avoid using abstract singleton class methods. To summarize:</p>
<ol>
<li><p>Declare an interface or abstract module with abstract instance methods, and <code>extend</code> that module onto a class.</p></li>
<li><p>Use the above approach, but with <a href="#interfaces-and-the-included-hook"><code>mixes_in_class_methods</code></a>, discussed below.</p></li>
<li><p>Make the method <code>overridable</code> instead of <code>abstract</code>, effectively giving the method a default implementation.</p></li>
</ol>
<p>There are also some runtime escape hatches to work around this problem. See <a href="#runtime-reflection-on-abstract-classes">Runtime reflection on abstract classes</a> below.</p>
<h2><a class="anchor" aria-hidden="true" id="interfaces-and-the-included-hook"></a><a href="#interfaces-and-the-included-hook" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interfaces and the <code>included</code> hook</h2>
<p>A somewhat common pattern in Ruby is to use an <code>included</code> hook to mix class methods from a module onto the including class:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">M</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">ClassMethods</span></span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
      <span class="hljs-keyword">self</span>.bar
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">included</span><span class="hljs-params">(other)</span></span>
    other.extend(ClassMethods)
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  <span class="hljs-keyword">include</span> M
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># runtime error as `bar` is not defined on A</span>
A.bar
</code></pre>
<p>This is hard to statically analyze, as it involves looking into the body of the <code>self.included</code> method, which might have arbitrary computation. As a compromise, Sorbet provides a new construct: <code>mixes_in_class_methods</code>. At runtime, it behaves as if we‚Äôd defined <code>self.included</code> like above, but will declare to Sorbet statically what module is being extended.</p>
<p>We can update our previous example to use <code>mixes_in_class_methods</code>, which lets Sorbet catch the runtime error about <code>bar</code> not being defined on <code>A</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">M</span></span>
  extend T::Helpers
  interface!

  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">ClassMethods</span></span>
    extend T::Sig
    extend T::Helpers
    abstract!

    sig { void }
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
      bar
    <span class="hljs-keyword">end</span>

    sig { abstract.void }
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  mixes_in_class_methods(ClassMethods)
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-comment"># error: Missing definition for abstract method</span></span>
  <span class="hljs-keyword">include</span> M

  extend T::Sig

  sig { override.void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># Sorbet knows that `foo` is a class method on `A`</span>
A.foo
</code></pre>
<p>We can also call <code>mixes_in_class_methods</code> with multiple modules to mix in more methods. Some Ruby modules mixin more than one module as class methods when they are included, and some modules mixin class methods but also include other modules that mixin in their own class modules. In these cases, you will need to declare multiple modules in the <code>mixes_in_class_methods</code> call or make multiple <code>mixes_in_class_methods</code> calls.</p>
<p>For a more comprehensive resource on how <code>mixes_in_class_methods</code> builds on existing Ruby inheritance features, see this blog post:</p>
<p><a href="https://blog.jez.io/inheritance-in-ruby">Inheritance in Ruby, in pictures ‚Üí</a></p>
<h2><a class="anchor" aria-hidden="true" id="runtime-reflection-on-abstract-classes"></a><a href="#runtime-reflection-on-abstract-classes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Runtime reflection on abstract classes</h2>
<p>From time to time, it‚Äôs useful to be able to ask whether a class or module object is abstract at runtime.</p>
<p>This can be done with</p>
<pre><code class="hljs css language-ruby">sig { params(<span class="hljs-symbol">mod:</span> Module).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(mod)</span></span>
  <span class="hljs-keyword">if</span> T::AbstractUtils.abstract_module?(mod)
    puts <span class="hljs-string">"<span class="hljs-subst">#{mod}</span> is abstract"</span>
  <span class="hljs-keyword">else</span>
    puts <span class="hljs-string">"<span class="hljs-subst">#{mod}</span> is concrete"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Note that in general, having to ask whether a module is abstract is a <strong>code smell</strong>. There is usually a way to reorganize the code such that calling <code>abstract_module?</code> isn‚Äôt needed. In particular, this happens most frequently from the use of modules with <a href="#abstract-singleton-methods">abstract singleton class methods</a> (abstract <code>self.</code> methods), and the fix is to stop using abstract singleton class methods.</p>
<p>Here‚Äôs an example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

<span class="hljs-comment"># --- This is an example of what NOT to do ---</span>

extend T::Sig

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFoo</span></span>
  extend T::Sig
  extend T::Helpers
  abstract!

  sig { abstract.void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">example</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &lt; AbstractFoo</span>
  sig { override.void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">example</span></span>
    puts <span class="hljs-string">'Foo#example'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sig { params(<span class="hljs-symbol">mod:</span> T.class_of(AbstractFoo)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calls_example_bad</span><span class="hljs-params">(mod)</span></span>
  <span class="hljs-comment"># even though there are no errors,</span>
  <span class="hljs-comment"># the call to mod.example is NOT always safe!</span>
  <span class="hljs-comment"># (see comments below)</span>
  mod.example
<span class="hljs-keyword">end</span>

sig { params(<span class="hljs-symbol">mod:</span> T.class_of(AbstractFoo)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calls_example_okay</span><span class="hljs-params">(mod)</span></span>
  <span class="hljs-keyword">if</span> !T::AbstractUtils.abstract_module?(mod)
    mod.example
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

calls_example_bad(Foo)         <span class="hljs-comment"># no errors</span>
calls_example_bad(AbstractFoo) <span class="hljs-comment"># no static error, BUT raises at runtime!</span>

calls_example_okay(Foo)         <span class="hljs-comment"># no errors</span>
calls_example_okay(AbstractFoo) <span class="hljs-comment"># no errors, because of explicit check</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Aclass%20AbstractFoo%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20T%3A%3AHelpers%0A%20%20abstract!%0A%0A%20%20sig%20%7Babstract.void%7D%0A%20%20def%20self.example%3B%20end%0Aend%0A%0Aclass%20Foo%20%3C%20AbstractFoo%0A%20%20sig%20%7Boverride.void%7D%0A%20%20def%20self.example%0A%20%20%20%20puts%20'Foo%23example'%0A%20%20end%0Aend%0A%0Asig%20%7Bparams%28mod%3A%20T.class_of%28AbstractFoo%29%29.void%7D%0Adef%20calls_example_bad%28mod%29%0A%20%20%23%20even%20though%20there%20are%20no%20errors%2C%0A%20%20%23%20the%20call%20to%20mod.example%20is%20NOT%20always%20safe!%0A%20%20%23%20%28see%20comments%20below%29%0A%20%20mod.example%0Aend%0A%0Asig%20%7Bparams%28mod%3A%20T.class_of%28AbstractFoo%29%29.void%7D%0Adef%20calls_example_okay%28mod%29%0A%20%20if%20!T%3A%3AAbstractUtils.abstract_module%3F%28mod%29%0A%20%20%20%20mod.example%0A%20%20end%0Aend%0A%0Acalls_example_bad%28Foo%29%20%20%20%20%20%20%20%20%20%23%20no%20errors%0Acalls_example_bad%28AbstractFoo%29%20%23%20no%20static%20error%2C%20BUT%20raises%20at%20runtime!%0A%0Acalls_example_okay%28Foo%29%20%20%20%20%20%20%20%20%20%23%20no%20errors%0Acalls_example_okay%28AbstractFoo%29%20%23%20no%20errors%2C%20because%20of%20explicit%20check">‚Üí View on sorbet.run</a></p>
<p>In the example above, <code>calls_example_bad</code> is bad because <code>mod.example</code> is not always okay to call, despite Sorbet reporting no errors. In particular, <code>calls_example_bad(AbstractFoo)</code> will raise an exception at runtime because <code>example</code> is an abstract method with no implementation.</p>
<p>An okay, but not great, fix for this is to call <code>abstract_module?</code> before the call to <code>mod.example</code>, which is demonstrated in <code>calls_example_okay</code>.</p>
<p>Most other languages simply do not allow defining abstract singleton class methods (for example, <code>static</code> methods in TypeScript, C++, Java, C#, and more are not allowed to be abstract). For historical reasons attempting to make migrating to Sorbet easier in existing Ruby codebases, Sorbet allows abstract singleton class methods.</p>
<p>A better solution is to make an interface with abstract methods, and <code>extend</code> that interface into a class:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">IFoo</span></span>
  extend T::Sig
  extend T::Helpers
  abstract!

  sig { abstract.void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  extend T::Sig
  extend IFoo
  sig { override.void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">example</span></span>
    puts <span class="hljs-string">'Foo#example'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sig { params(<span class="hljs-symbol">mod:</span> IFoo).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calls_example_good</span><span class="hljs-params">(mod)</span></span>
  <span class="hljs-comment"># call to mod.example is always safe</span>
  mod.example
<span class="hljs-keyword">end</span>


calls_example_good(Foo)  <span class="hljs-comment"># no errors</span>
calls_example_good(IFoo) <span class="hljs-comment"># doesn't type check</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20IFoo%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20T%3A%3AHelpers%0A%20%20abstract!%0A%0A%20%20sig%20%7Babstract.void%7D%0A%20%20def%20example%3B%20end%0Aend%0A%0Aclass%20Foo%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20IFoo%0A%20%20sig%20%7Boverride.void%7D%0A%20%20def%20self.example%0A%20%20%20%20puts%20'Foo%23example'%0A%20%20end%0Aend%0A%0Asig%20%7Bparams%28mod%3A%20IFoo%29.void%7D%0Adef%20calls_example_good%28mod%29%0A%20%20%23%20call%20to%20mod.example%20is%20always%20safe%0A%20%20mod.example%0Aend%0A%0A%0Acalls_example_good%28Foo%29%20%20%23%20no%20errors%0Acalls_example_good%28IFoo%29%20%23%20doesn't%20type%20check">‚Üí View on sorbet.run</a></p>
<p>In this example, unlike before, we have a module <code>IFoo</code> with an abstract <strong>instance</strong> method, instead of a class <code>AbstractFoo</code> with an abstract singleton class method. This module is then <code>extend</code>'ed into <code>class Foo</code> to implement the interface.</p>
<p>This fixes all of our problems:</p>
<ul>
<li>We no longer need to use <code>abstract_module?</code> to check whether <code>mod</code> is abstract.</li>
<li>Sorbet statically rejects <code>calls_example_good(IFoo)</code> (intuitively: because <code>IFoo.example</code> is not a method that even exists).</li>
</ul>
<p>Another benefit is that now we have an explicit interface that can be documented and implemented by any class, not just subclasses of <code>AbstractFoo</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="whats-next"></a><a href="#whats-next" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What‚Äôs next?</h2>
<ul>
<li><p><a href="/docs/override-checking">Override Checking</a></p>
<p>Sorbet has more ways to check overriding than just whether an abstract method is implemented in a child. See this doc to learn about the ways to declare what kinds of overriding should be allowed.</p></li>
<li><p><a href="/docs/sealed">Sealed Classes and Modules</a></p>
<p>Abstract classes and interfaces are frequently used with sealed classes to recreate a sort of ‚Äúalgebraic data type‚Äù in Sorbet.</p></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/procs"><span class="arrow-prev">‚Üê </span><span>Blocks, Procs, &amp; Lambdas</span></a><a class="docs-next button" href="/docs/final"><span>Final Methods &amp; Classes</span><span class="arrow-next"> ‚Üí</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#creating-an-abstract-method">Creating an abstract method</a></li><li><a href="#implementing-an-abstract-method">Implementing an abstract method</a></li><li><a href="#additional-requirements">Additional Requirements</a><ul class="toc-headings"><li><a href="#why-choose-interface-over-abstract">Why choose <code>interface!</code> over <code>abstract!</code>?</a></li></ul></li><li><a href="#overridable-providing-default-implementations-of-methods"><code>overridable</code>: Providing default implementations of methods</a></li><li><a href="#letting-abstract-methods-be-implemented-via-inheritance">Letting abstract methods be implemented via inheritance</a><ul class="toc-headings"><li><a href="#approximating-duck-types">Approximating duck types</a></li><li><a href="#consequences-for-runtime-signature-checking">Consequences for runtime signature checking</a></li></ul></li><li><a href="#abstract-singleton-methods">Abstract singleton methods</a></li><li><a href="#interfaces-and-the-included-hook">Interfaces and the <code>included</code> hook</a></li><li><a href="#runtime-reflection-on-abstract-classes">Runtime reflection on abstract classes</a></li><li><a href="#whats-next">What's next?</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer"><svg width="99" height="28" viewBox="0 0 99 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.98432 20H6.27432C8.44932 20 9.81432 18.905 9.81432 17.03C9.81432 15.665 9.00432 14.72 7.78932 14.39C8.61432 14.105 9.45432 13.415 9.45432 12.035C9.45432 10.235 8.23932 9.23 5.95932 9.23H1.98432V20ZM3.37932 13.85V10.445H5.83932C7.27932 10.445 8.07432 11 8.07432 12.155C8.07432 13.295 7.27932 13.85 5.83932 13.85H3.37932ZM3.37932 15.08H6.21432C7.65432 15.08 8.43432 15.83 8.43432 16.925C8.43432 18.035 7.65432 18.785 6.21432 18.785H3.37932V15.08ZM18.0294 12.155H16.6794V16.88C16.6794 18.185 15.6894 18.92 14.7144 18.92C13.5594 18.92 13.0794 18.17 13.0794 17.06V12.155H11.7294V17.345C11.7294 19.01 12.6744 20.165 14.3544 20.165C15.4644 20.165 16.2294 19.58 16.6794 18.92V20H18.0294V12.155ZM20.5112 10.79H21.9812V9.23H20.5112V10.79ZM21.9212 12.155H20.5712V20H21.9212V12.155ZM25.8247 9.23H24.4747V20H25.8247V9.23ZM28.5882 18.125C28.5882 19.625 29.3532 20.075 30.6882 20.075C31.1382 20.075 31.5282 20.03 31.8732 19.955V18.8C31.5582 18.875 31.3332 18.89 31.0182 18.89C30.3282 18.89 29.9232 18.74 29.9232 17.915V13.31H31.7082V12.155H29.9232V9.86H28.5882V12.155H27.3732V13.31H28.5882V18.125ZM41.0199 20.165C43.1949 20.165 44.4399 18.305 44.4399 16.085C44.4399 13.85 43.1949 12.005 41.0199 12.005C39.9249 12.005 39.0549 12.53 38.5899 13.295V9.23H37.2399V20H38.5899V18.86C39.0549 19.64 39.9249 20.165 41.0199 20.165ZM38.5599 15.815C38.5599 13.985 39.6699 13.19 40.7799 13.19C42.2499 13.19 43.0749 14.39 43.0749 16.085C43.0749 17.765 42.2499 18.98 40.7799 18.98C39.6699 18.98 38.5599 18.17 38.5599 16.37V15.815ZM49.1804 20.855L52.5554 12.155H51.1454L48.9704 18.155L46.7654 12.155H45.3404L48.2504 19.715L47.8754 20.645C47.5604 21.425 47.2454 21.635 46.6604 21.635C46.4354 21.635 46.2704 21.62 46.0154 21.56V22.73C46.2554 22.775 46.4204 22.79 46.7504 22.79C48.1154 22.79 48.7304 22.04 49.1804 20.855Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M98.7993 15.7838C98.7993 12.8786 97.3871 10.5862 94.688 10.5862C91.9774 10.5862 90.3374 12.8786 90.3374 15.7611C90.3374 19.177 92.2735 20.9019 95.0524 20.9019C96.4077 20.9019 97.4327 20.5955 98.2071 20.1643V17.8946C97.4327 18.2804 96.5443 18.5188 95.4168 18.5188C94.3121 18.5188 93.3327 18.1329 93.2074 16.7938H98.7766C98.7766 16.6463 98.7993 16.0561 98.7993 15.7838ZM93.1732 14.7057C93.1732 13.4233 93.9591 12.8899 94.6766 12.8899C95.3713 12.8899 96.1116 13.4233 96.1116 14.7057H93.1732Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M85.9413 10.5862C84.8251 10.5862 84.1076 11.1082 83.709 11.4714L83.561 10.7678H81.0554V24.0001L83.9026 23.3986L83.914 20.187C84.324 20.482 84.9276 20.9019 85.9299 20.9019C87.9685 20.9019 89.8249 19.2678 89.8249 15.6703C89.8135 12.3792 87.9343 10.5862 85.9413 10.5862ZM85.2579 18.4053C84.586 18.4053 84.1874 18.167 83.914 17.8719L83.9026 13.6616C84.1988 13.3325 84.6088 13.1055 85.2579 13.1055C86.2943 13.1055 87.0118 14.2631 87.0118 15.7497C87.0118 17.2704 86.3057 18.4053 85.2579 18.4053Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M77.1377 9.91656L79.9963 9.30374V7L77.1377 7.60147V9.91656Z" fill="white"></path><path d="M79.9963 10.7791H77.1377V20.709H79.9963V10.7791Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M74.074 11.6187L73.8918 10.7789H71.4318V20.7088H74.279V13.9792C74.9509 13.1054 76.0898 13.2642 76.4429 13.3891V10.7789C76.0784 10.6427 74.7459 10.3931 74.074 11.6187Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M68.3796 8.31641L65.6007 8.90653L65.5894 17.9966C65.5894 19.6762 66.8535 20.9132 68.5391 20.9132C69.473 20.9132 70.1563 20.743 70.5321 20.5387V18.235C70.1677 18.3825 68.3682 18.9045 68.3682 17.225V13.1962H70.5321V10.779H68.3682L68.3796 8.31641Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M60.6807 13.6616C60.6807 13.219 61.0452 13.0488 61.6488 13.0488C62.5143 13.0488 63.6076 13.3098 64.4732 13.7751V11.1082C63.5279 10.7337 62.594 10.5862 61.6488 10.5862C59.3368 10.5862 57.7993 11.7891 57.7993 13.7978C57.7993 16.93 62.1271 16.4306 62.1271 17.7811C62.1271 18.3031 61.6715 18.4734 61.0338 18.4734C60.0885 18.4734 58.8813 18.0875 57.9246 17.5655V20.2664C58.9838 20.7204 60.0543 20.9133 61.0338 20.9133C63.4026 20.9133 65.0313 19.7444 65.0313 17.713C65.0199 14.3312 60.6807 14.9326 60.6807 13.6616Z" fill="white"></path></svg><a href="/docs/adopting">Get started</a> ¬∑ <a href="/docs/overview">Docs</a> ¬∑ <a href="https://sorbet.run">Try</a> ¬∑ <a href="/en/community">Community</a> ¬∑ <a href="/blog">Blog</a> ¬∑ <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div><div id="csat-extension-config" data-notify="#sorbet-team"></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>