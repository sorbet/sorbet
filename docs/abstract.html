<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Abstract Classes and Interfaces · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Sorbet supports abstract classes, abstract methods, and interfaces. Abstract"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Abstract Classes and Interfaces · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="Sorbet supports abstract classes, abstract methods, and interfaces. Abstract"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ↔ Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/why-type-annotations">Why type annotations?</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">sig</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations (non-sig)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">T.let, T.cast, T.must, T.bind</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types (Integer, String)</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types (T.nilable)</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types (T.any)</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow-Sensitivity (is_a?, nil?)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">T.type_alias</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness (T.absurd)</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types (T.all)</a></li><li class="navListItem"><a class="navItem" href="/docs/non-forcing-constants">T::NonForcingConstants</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/generics">Generics</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/abstract.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Abstract Classes and Interfaces</h1></header><article><div><span><p>Sorbet supports abstract classes, abstract methods, and interfaces. Abstract
methods ensure that a particular method gets implemented anywhere the class or
module is inherited, included, or extended. An abstract class or module is one
that contains one or more abstract methods. An interface is a class or module
that must have only abstract methods.</p>
<p>Keep in mind:</p>
<ul>
<li><code>abstract!</code> can be used to prevent a class from being instantiated.</li>
<li>Both <code>abstract!</code> and <code>interface!</code> allow the class or module to have <code>abstract</code>
methods.</li>
<li>Mix in a module (via <code>include</code> or <code>extend</code>) to declare that a class implements
an interface.</li>
</ul>
<blockquote>
<p><strong>Note</strong>: Most of the abstract and override checks are implemented statically,
but some are still only implemented at runtime, most notably variance checks.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="creating-an-abstract-method"></a><a href="#creating-an-abstract-method" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating an abstract method</h2>
<p>To create an abstract method:</p>
<ol>
<li>Add <code>extend T::Helpers</code> to the class or module (in addition to
<code>extend T::Sig</code>).</li>
<li>Add <code>abstract!</code> or <code>interface!</code> to the top of the class or module. (<em>All</em>
methods must be abstract to use <code>interface!</code>.)</li>
<li>Add a <code>sig</code> with <code>abstract</code> to any methods that should be abstract, and thus
implemented by a child.</li>
<li>Declare the method on a single line with an empty body.</li>
</ol>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Runnable</span></span>
  extend T::Sig
  extend T::Helpers                                    <span class="hljs-comment"># (1)</span>
  interface!                                           <span class="hljs-comment"># (2)</span>

  sig {abstract.params(<span class="hljs-symbol">args:</span> T::Array[String]).void}   <span class="hljs-comment"># (3)</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">(args)</span></span>; <span class="hljs-keyword">end</span>                                  <span class="hljs-comment"># (4)</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="implementing-an-abstract-method"></a><a href="#implementing-an-abstract-method" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Implementing an abstract method</h2>
<p>To implement an abstract method, define the method in the implementing class or
module with an identical signature as the parent, except replacing <code>abstract</code>
with <code>override</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span></span>
  extend T::Sig
  <span class="hljs-keyword">include</span> Runnable

  <span class="hljs-comment"># This implements the abstract `main` method from our Runnable module:</span>
  sig {override.params(<span class="hljs-symbol">args:</span> T::Array[String]).void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">(args)</span></span>
    puts <span class="hljs-string">'Hello, world!'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="additional-requirements"></a><a href="#additional-requirements" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Additional Requirements</h2>
<p>There are some additional stipulations on the use of <code>abstract!</code> and
<code>interface!</code>:</p>
<ul>
<li>All methods in a module marked as <code>interface!</code> must have signatures, and must
be marked <code>abstract</code>.
<ul>
<li><strong>Note</strong>: this applies to all methods defined within the module, as well as
any that are included from another module</li>
</ul></li>
<li>A module marked <code>interface!</code> can’t have <code>private</code> or <code>protected</code> methods.</li>
<li>Any method marked <code>abstract</code> must have no body. <code>sorbet-runtime</code> will take
care to raise an exception if an abstract method is called at runtime.</li>
<li>Classes without <code>abstract!</code> or <code>interface!</code> must implement all <code>abstract</code>
methods from their parents.</li>
<li><code>extend MyAbstractModule</code> works just like <code>include MyAbstractModule</code>, but for
singleton methods.</li>
<li><code>abstract!</code> classes cannot be instantiated (will raise at runtime).</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="abstract-singleton-methods"></a><a href="#abstract-singleton-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Abstract singleton methods</h2>
<p><code>abstract</code> singleton methods on a module are not allowed, as there’s no way to
implement these methods.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">M</span></span>
  extend T::Sig
  extend T::Helpers

  abstract!

  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

M.foo <span class="hljs-comment"># error: `M.foo` can never be implemented</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="interfaces-and-the-included-hook"></a><a href="#interfaces-and-the-included-hook" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Interfaces and the <code>included</code> hook</h2>
<p>A somewhat common pattern in Ruby is to use an <code>included</code> hook to mix class
methods from a module onto the including class:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">M</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">ClassMethods</span></span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
      <span class="hljs-keyword">self</span>.bar
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">included</span><span class="hljs-params">(other)</span></span>
    other.extend(ClassMethods)
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  <span class="hljs-keyword">include</span> M
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># runtime error as `bar` is not defined on A</span>
A.bar
</code></pre>
<p>This is hard to statically analyze, as it involves looking into the body of the
<code>self.included</code> method, which might have arbitrary computation. As a compromise,
Sorbet provides a new construct: <code>mixes_in_class_methods</code>. At runtime, it
behaves as if we’d defined <code>self.included</code> like above, but will declare to <code>srb</code>
statically what module is being extended.</p>
<p>We can update our previous example to use <code>mixes_in_class_methods</code>, which lets
Sorbet catch the runtime error about <code>bar</code> not being defined on <code>A</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">M</span></span>
  extend T::Helpers
  interface!

  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">ClassMethods</span></span>
    extend T::Sig
    extend T::Helpers
    abstract!

    sig {void}
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
      bar
    <span class="hljs-keyword">end</span>

    sig {abstract.void}
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  mixes_in_class_methods(ClassMethods)
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-comment"># error: Missing definition for abstract method</span></span>
  <span class="hljs-keyword">include</span> M

  extend T::Sig

  sig {override.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># Sorbet knows that `foo` is a class method on `A`</span>
A.foo
</code></pre>
<p>We can also call <code>mixes_in_class_methods</code> with multiple modules to mix in more
methods. Some Ruby modules mixin more than one module as class methods when they
are included, and some modules mixin class methods but also include other
modules that mixin in their own class modules. In these cases, you will need to
declare multiple modules in the <code>mixes_in_class_methods</code> call or make multiple
<code>mixes_in_class_methods</code> calls.</p>
<h2><a class="anchor" aria-hidden="true" id="runtime-reflection-on-abstract-classes"></a><a href="#runtime-reflection-on-abstract-classes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Runtime reflection on abstract classes</h2>
<p>From time to time, it’s useful to be able to ask whether a class or module
object is abstract at runtime.</p>
<p>This can be done with</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">mod:</span> Module).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(mod)</span></span>
  <span class="hljs-keyword">if</span> T::AbstractUtils.abstract_module?(mod)
    puts <span class="hljs-string">"<span class="hljs-subst">#{mod}</span> is abstract"</span>
  <span class="hljs-keyword">else</span>
    puts <span class="hljs-string">"<span class="hljs-subst">#{mod}</span> is concrete"</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Note that in general, having to ask whether a module is abstract is a <strong>code
smell</strong>. There is usually a way to reorganize the code such that calling
<code>abstract_module?</code> isn’t needed. In particular, this happens most frequently
from the use of modules with abstract singleton class methods (abstract <code>self.</code>
methods), and the fix is to stop using abstract singleton class methods.</p>
<p>Here’s an example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

<span class="hljs-comment"># --- This is an example of what NOT to do ---</span>

extend T::Sig

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFoo</span></span>
  extend T::Sig
  extend T::Helpers
  abstract!

  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">example</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &lt; AbstractFoo</span>
  sig {override.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">example</span></span>
    puts <span class="hljs-string">'Foo#example'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">mod:</span> T.class_of(AbstractFoo)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calls_example_bad</span><span class="hljs-params">(mod)</span></span>
  <span class="hljs-comment"># even though there are no errors,</span>
  <span class="hljs-comment"># the call to mod.example is NOT always safe!</span>
  <span class="hljs-comment"># (see comments below)</span>
  mod.example
<span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">mod:</span> T.class_of(AbstractFoo)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calls_example_okay</span><span class="hljs-params">(mod)</span></span>
  <span class="hljs-keyword">if</span> !T::AbstractUtils.abstract_module?(mod)
    mod.example
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

calls_example_bad(Foo)         <span class="hljs-comment"># no errors</span>
calls_example_bad(AbstractFoo) <span class="hljs-comment"># no static error, BUT raises at runtime!</span>

calls_example_okay(Foo)         <span class="hljs-comment"># no errors</span>
calls_example_okay(AbstractFoo) <span class="hljs-comment"># no errors, because of explicit check</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Aclass%20AbstractFoo%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20T%3A%3AHelpers%0A%20%20abstract!%0A%0A%20%20sig%20%7Babstract.void%7D%0A%20%20def%20self.example%3B%20end%0Aend%0A%0Aclass%20Foo%20%3C%20AbstractFoo%0A%20%20sig%20%7Boverride.void%7D%0A%20%20def%20self.example%0A%20%20%20%20puts%20'Foo%23example'%0A%20%20end%0Aend%0A%0Asig%20%7Bparams%28mod%3A%20T.class_of%28AbstractFoo%29%29.void%7D%0Adef%20calls_example_bad%28mod%29%0A%20%20%23%20even%20though%20there%20are%20no%20errors%2C%0A%20%20%23%20the%20call%20to%20mod.example%20is%20NOT%20always%20safe!%0A%20%20%23%20%28see%20comments%20below%29%0A%20%20mod.example%0Aend%0A%0Asig%20%7Bparams%28mod%3A%20T.class_of%28AbstractFoo%29%29.void%7D%0Adef%20calls_example_okay%28mod%29%0A%20%20if%20!T%3A%3AAbstractUtils.abstract_module%3F%28mod%29%0A%20%20%20%20mod.example%0A%20%20end%0Aend%0A%0Acalls_example_bad%28Foo%29%20%20%20%20%20%20%20%20%20%23%20no%20errors%0Acalls_example_bad%28AbstractFoo%29%20%23%20no%20static%20error%2C%20BUT%20raises%20at%20runtime!%0A%0Acalls_example_okay%28Foo%29%20%20%20%20%20%20%20%20%20%23%20no%20errors%0Acalls_example_okay%28AbstractFoo%29%20%23%20no%20errors%2C%20because%20of%20explicit%20check">→ View on sorbet.run</a></p>
<p>In the example above, <code>calls_example_bad</code> is bad because <code>mod.example</code> is not
always okay to call, despite Sorbet reporting no errors. In particular,
<code>calls_example_bad(AbstractFoo)</code> will raise an exception at runtime because
<code>example</code> is an abstract method with no implementation.</p>
<p>An okay, but not great, fix for this is to call <code>abstract_module?</code> before the
call to <code>mod.example</code>, which is demonstrated in <code>calls_example_okay</code>.</p>
<p>Most other languages simply do not allow defining abstract singleton class
methods (for example, <code>static</code> methods in TypeScript, C++, Java, C#, and more
are not allowed to be abstract). For historical reasons attempting to make
migrating to Sorbet easier in existing Ruby codebases, Sorbet allows abstract
singleton class methods.</p>
<p>A better solution is to make an interface with abstract methods, and <code>extend</code>
that interface into a class:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">IFoo</span></span>
  extend T::Sig
  extend T::Helpers
  abstract!

  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  extend T::Sig
  extend IFoo
  sig {override.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">example</span></span>
    puts <span class="hljs-string">'Foo#example'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">mod:</span> IFoo).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calls_example_good</span><span class="hljs-params">(mod)</span></span>
  <span class="hljs-comment"># call to mod.example is always safe</span>
  mod.example
<span class="hljs-keyword">end</span>


calls_example_good(Foo)  <span class="hljs-comment"># no errors</span>
calls_example_good(IFoo) <span class="hljs-comment"># doesn't type check</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Amodule%20IFoo%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20T%3A%3AHelpers%0A%20%20abstract!%0A%0A%20%20sig%20%7Babstract.void%7D%0A%20%20def%20example%3B%20end%0Aend%0A%0Aclass%20Foo%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20IFoo%0A%20%20sig%20%7Boverride.void%7D%0A%20%20def%20self.example%0A%20%20%20%20puts%20'Foo%23example'%0A%20%20end%0Aend%0A%0Asig%20%7Bparams%28mod%3A%20IFoo%29.void%7D%0Adef%20calls_example_good%28mod%29%0A%20%20%23%20call%20to%20mod.example%20is%20always%20safe%0A%20%20mod.example%0Aend%0A%0A%0Acalls_example_good%28Foo%29%20%20%23%20no%20errors%0Acalls_example_good%28IFoo%29%20%23%20doesn't%20type%20check">→ View on sorbet.run</a></p>
<p>In this example, unlike before, we have a module <code>IFoo</code> with an abstract
<strong>instance</strong> method, instead of a class <code>AbstractFoo</code> with an abstract singleton
class method. This module is then <code>extend</code>'ed into <code>class Foo</code> to implement the
interface.</p>
<p>This fixes all of our problems:</p>
<ul>
<li>We no longer need to use <code>abstract_module?</code> to check whether <code>mod</code> is
abstract.</li>
<li>Sorbet statically rejects <code>calls_example_good(IFoo)</code> (intuitively: because
<code>IFoo.example</code> is not a method that even exists).</li>
</ul>
<p>Another benefit is that now we have an explicit interface that can be documented
and implemented by any class, not just subclasses of <code>AbstractFoo</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="whats-next"></a><a href="#whats-next" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What’s next?</h2>
<ul>
<li><p><a href="/docs/override-checking">Override Checking</a></p>
<p>Sorbet has more ways to check overriding than just whether an abstract method
is implemented in a child. See this doc to learn about the ways to declare
what kinds of overriding should be allowed.</p></li>
<li><p><a href="/docs/sealed">Sealed Classes and Modules</a></p>
<p>Abstract classes and interfaces are frequently used with sealed classes to
recreate a sort of “algebraic data type” in Sorbet.</p></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/procs"><span class="arrow-prev">← </span><span>Blocks, Procs, &amp; Lambdas</span></a><a class="docs-next button" href="/docs/final"><span>Final Methods &amp; Classes</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#creating-an-abstract-method">Creating an abstract method</a></li><li><a href="#implementing-an-abstract-method">Implementing an abstract method</a></li><li><a href="#additional-requirements">Additional Requirements</a></li><li><a href="#abstract-singleton-methods">Abstract singleton methods</a></li><li><a href="#interfaces-and-the-included-hook">Interfaces and the <code>included</code> hook</a></li><li><a href="#runtime-reflection-on-abstract-classes">Runtime reflection on abstract classes</a></li><li><a href="#whats-next">What's next?</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer">© 2022 Stripe · <a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>