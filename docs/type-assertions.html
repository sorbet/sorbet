<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Type Assertions · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="There are five ways to assert the types of expressions in Sorbet:"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Type Assertions · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="There are five ways to assert the types of expressions in Sorbet:"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5H7PQ9Z8KF"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'G-5H7PQ9Z8KF');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ↔ Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">CLI Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/cli-ref">CLI Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/why-type-annotations">Why type annotations?</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/unsupported">Unsupported Ruby Features</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">sig</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations (non-sig)</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/type-assertions">T.let, T.cast, T.must, T.bind</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types (Integer, String)</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types (T.nilable)</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types (T.any)</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow-Sensitivity (is_a?, nil?)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">T.type_alias</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness (T.absurd)</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/anything">T.anything</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types (T.all)</a></li><li class="navListItem"><a class="navItem" href="/docs/generics">Generics</a></li><li class="navListItem"><a class="navItem" href="/docs/strong">Banning untyped</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Ruby &amp; DSL Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/attr_reader">attr_reader</a></li><li class="navListItem"><a class="navItem" href="/docs/minitest">minitest</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Editor Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/lsp">Language Server (LSP)</a></li><li class="navListItem"><a class="navItem" href="/docs/server-status">Server Status</a></li><li class="navListItem"><a class="navItem" href="/docs/lsp-typed-level">LSP &amp; Typed Level</a></li><li class="navListItem"><a class="navItem" href="/docs/go-to-def">Go to Definition</a></li><li class="navListItem"><a class="navItem" href="/docs/hover">Hover</a></li><li class="navListItem"><a class="navItem" href="/docs/autocompletion">Autocompletion</a></li><li class="navListItem"><a class="navItem" href="/docs/references">Find All References</a></li><li class="navListItem"><a class="navItem" href="/docs/code-actions">Code Actions</a></li><li class="navListItem"><a class="navItem" href="/docs/outline">Outline &amp; Document Symbols</a></li><li class="navListItem"><a class="navItem" href="/docs/doc-comments">Documentation Comments</a></li><li class="navListItem"><a class="navItem" href="/docs/sig-suggestion">Suggesting sigs</a></li><li class="navListItem"><a class="navItem" href="/docs/highlight-untyped">Highlighting untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/sorbet-uris">sorbet: URIs</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/overloads">Overloads</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li><li class="navListItem"><a class="navItem" href="/docs/rbs-support">RBS Comments</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/type-assertions.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Type Assertions</h1></header><article><div><span><p>There are five ways to assert the types of expressions in Sorbet:</p>
<ul>
<li><code>T.let(expr, Type)</code></li>
<li><code>T.cast(expr, Type)</code></li>
<li><code>T.must(expr)</code> / <code>T.must_because(expr) {msg}</code></li>
<li><code>T.assert_type!(expr, Type)</code></li>
<li><code>T.bind(self, Type)</code></li>
</ul>
<blockquote>
<p>There is also <code>T.unsafe</code> which is not a “type assertion” so much as an <a href="/docs/troubleshooting#escape-hatches">Escape Hatch</a>.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="tlet"></a><a href="#tlet" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T.let</code></h2>
<p>A <code>T.let</code> assertion is checked statically <strong>and</strong> at runtime. In the following example, the definition of <code>y</code> will raise an error when Sorbet is run, and also when the program is run.</p>
<pre><code class="hljs css language-ruby">x = T.let(<span class="hljs-number">10</span>, Integer)
T.reveal_type(x) <span class="hljs-comment"># Revealed type: Integer</span>

y = T.let(<span class="hljs-number">10</span>, String) <span class="hljs-comment"># error: Argument does not have asserted type String</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Ax%20%3D%20T.let(10%2C%20Integer)%0AT.reveal_type(x)%20%23%20Revealed%20type%3A%20Integer%0A%0Ay%20%3D%20T.let(10%2C%20String)%20%23%20error%3A%20Argument%20does%20not%20have%20asserted%20type%20String">
→ View on sorbet.run
</a></p>
<p>At runtime, a <code>TypeError</code> will be raised when the assignment to <code>y</code> is evaluated:</p>
<pre><code class="hljs css language-cli">$ ruby test.rb
&lt;...&gt;/lib/types/<span class="hljs-keyword">private</span>/casts.rb:<span class="hljs-number">15</span>:in `cast': <span class="hljs-type">T</span>.let: <span class="hljs-type">Expected</span> <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">String</span>, <span class="hljs-title">got</span> <span class="hljs-title">type</span> <span class="hljs-title">Integer</span> <span class="hljs-keyword">with</span> <span class="hljs-title">value</span> 10 (<span class="hljs-params"><span class="hljs-type">TypeError</span></span>)</span>
<span class="hljs-type">Caller</span>: test.rb:<span class="hljs-number">8</span>
    from &lt;...&gt;/lib/types/_types.rb:<span class="hljs-number">138</span>:in `let'
    from test.rb:<span class="hljs-number">8</span>:in `&lt;main&gt;'
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tcast"></a><a href="#tcast" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T.cast</code></h2>
<p>Sometimes we the programmer are aware of an invariant in the code that isn’t currently expressible in the Sorbet type system:</p>
<pre><code class="hljs css language-ruby">extend T::Sig

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>; <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>; <span class="hljs-keyword">end</span>

sig { params(<span class="hljs-symbol">label:</span> String, <span class="hljs-symbol">a_or_b:</span> T.any(A, B)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(label, a_or_b)</span></span>
  <span class="hljs-keyword">case</span> label
  <span class="hljs-keyword">when</span> <span class="hljs-string">'a'</span>
    a_or_b.foo
  <span class="hljs-keyword">when</span> <span class="hljs-string">'b'</span>
    a_or_b.bar
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, we know (through careful test cases / confidence in our production monitoring) that every time this method is called with <code>label = 'a'</code>, <code>a_or_b</code> is an instance of <code>A</code>, and same for <code>'b'</code> / <code>B</code>.</p>
<p>Ideally we’d refactor the code to express this invariant in the types. To reiterate: the <strong>preferred</strong> solution is to refactor this code. The time spent adjusting this code now will make it easier and safer to refactor the code in the future. Even still, we don’t always have the time <em>right now</em>, so let’s see how we can work around the issue.</p>
<p>We can use <code>T.cast</code> to explicitly tell our invariant to Sorbet:</p>
<pre><code class="hljs css language-ruby">  <span class="hljs-keyword">case</span> label
  <span class="hljs-keyword">when</span> <span class="hljs-string">'a'</span>
    T.cast(a_or_b, A).foo
  <span class="hljs-keyword">when</span> <span class="hljs-string">'b'</span>
    T.cast(a_or_b, B).bar
  <span class="hljs-keyword">end</span>
</code></pre>
<p>Sorbet cannot <strong>statically</strong> guarantee that a <code>T.cast</code>-enforced invariant will succeed in every case, but it will check the invariant <strong>dynamically</strong> on every invocation.</p>
<p><code>T.cast</code> is better than <code>T.unsafe</code>, because it means that something like</p>
<pre><code class="hljs css language-ruby">    T.cast(a_or_b, A).bad_method
</code></pre>
<p>will still be caught as a missing method statically.</p>
<h2><a class="anchor" aria-hidden="true" id="tmust"></a><a href="#tmust" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T.must</code></h2>
<p><a id="tmust_because"></a></p>
<p><code>T.must</code> is for asserting that a value of a <a href="/docs/nilable-types">nilable type</a> is not <code>nil</code>. <code>T.must</code> is similar to <code>T.cast</code> in that it will not necessarily trigger an error when <code>srb tc</code> is run, but can trigger an error during runtime.</p>
<p><code>T.must_because</code> is like <code>T.must</code> but also takes a reason why the value is not expected to be <code>nil</code>, which appears in the exception that is raised if passed a <code>nil</code> argument.</p>
<p>The following example illustrates two cases:</p>
<ol>
<li>a use of <code>T.must</code> with a value that Sorbet is able to determine statically is <code>nil</code>, that raises an error indicating that the subsequent statements are unreachable;</li>
<li>a use of <code>T.must</code> with a computed <code>nil</code> value that Sorbet is not able to detect statically, which raises an error at runtime.</li>
</ol>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    x = T.let(<span class="hljs-literal">nil</span>, T.nilable(String))
    y = T.must(<span class="hljs-literal">nil</span>)
    puts y <span class="hljs-comment"># error: This code is unreachable</span>
  <span class="hljs-keyword">end</span>

  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span></span>
    vals = T.let([], T::Array[Integer])
    x = vals.find {<span class="hljs-params">|a|</span> a &gt; <span class="hljs-number">0</span>}
    T.reveal_type(x) <span class="hljs-comment"># Revealed type: T.nilable(Integer)</span>
    y = T.must(x)
    puts y <span class="hljs-comment"># no static error</span>
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aclass%20A%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20sig%20%7Bvoid%7D%0A%20%20def%20foo%0A%20%20%20%20x%20%3D%20T.let(nil%2C%20T.nilable(String))%0A%20%20%20%20y%20%3D%20T.must(nil)%0A%20%20%20%20puts%20y%20%23%20error%3A%20This%20code%20is%20unreachable%0A%20%20end%0A%0A%20%20sig%20%7Bvoid%7D%0A%20%20def%20bar%0A%20%20%20%20vals%20%3D%20T.let(%5B%5D%2C%20T%3A%3AArray%5BInteger%5D)%0A%20%20%20%20x%20%3D%20vals.find%20%7B%7Ca%7C%20a%20%3E%200%7D%0A%20%20%20%20T.reveal_type(x)%20%23%20Revealed%20type%3A%20T.nilable(Integer)%0A%20%20%20%20y%20%3D%20T.must(x)%0A%20%20%20%20puts%20y%20%23%20no%20static%20error%0A%20%20end%0A%0Aend">
→ View on sorbet.run
</a></p>
<h3><a class="anchor" aria-hidden="true" id="tmust_because"></a><a href="#tmust_because" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T.must_because</code></h3>
<p>Here’s the same example with <code>T.must_because</code>, showing the use of custom reasons. The reason is provided as a block that returns a <code>String</code>, so that the reason is only computed if the exception would be raised.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    y = T.must_because(<span class="hljs-literal">nil</span>) {<span class="hljs-string">'reason'</span>}
    puts y <span class="hljs-comment"># error: This code is unreachable</span>
  <span class="hljs-keyword">end</span>

  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span></span>
    vals = T.let([], T::Array[Integer])
    x = vals.find {<span class="hljs-params">|a|</span> a &gt; <span class="hljs-number">0</span>}
    T.reveal_type(x) <span class="hljs-comment"># Revealed type: T.nilable(Integer)</span>
    y = T.must_because(x) {<span class="hljs-string">'reason'</span>}
    puts y <span class="hljs-comment"># no static error</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0Aclass%20A%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20sig%20%7Bvoid%7D%0A%20%20def%20foo%0A%20%20%20%20y%20%3D%20T.must_because%28nil%29%20%7B'reason'%7D%0A%20%20%20%20puts%20y%20%23%20error%3A%20This%20code%20is%20unreachable%0A%20%20end%0A%0A%20%20sig%20%7Bvoid%7D%0A%20%20def%20bar%0A%20%20%20%20vals%20%3D%20T.let%28%5B%5D%2C%20T%3A%3AArray%5BInteger%5D%29%0A%20%20%20%20x%20%3D%20vals.find%20%7B%7Ca%7C%20a%20%3E%200%7D%0A%20%20%20%20T.reveal_type%28x%29%20%23%20Revealed%20type%3A%20T.nilable%28Integer%29%0A%20%20%20%20y%20%3D%20T.must_because%28x%29%20%7B'reason'%7D%0A%20%20%20%20puts%20y%20%23%20no%20static%20error%0A%20%20end%0Aend">
→ View on sorbet.run
</a></p>
<h2><a class="anchor" aria-hidden="true" id="tassert_type"></a><a href="#tassert_type" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T.assert_type!</code></h2>
<p><code>T.assert_type!</code> is similar to <code>T.let</code>: it is checked statically <strong>and</strong> at runtime. It has the additional restriction that it will <strong>always</strong> fail statically if given something that’s <a href="/docs/untyped"><code>T.untyped</code></a>. For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  sig { params(<span class="hljs-symbol">x:</span> T.untyped).void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
    T.assert_type!(x, String) <span class="hljs-comment"># error here</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0Aclass%20A%0A%20%20extend%20T%3A%3ASig%0A%0A%20%20sig%20%7Bparams(x%3A%20T.untyped).void%7D%0A%20%20def%20foo(x)%0A%20%20%20%20T.assert_type!(x%2C%20String)%20%23%20error%20here%0A%20%20end%0Aend">
→ View on sorbet.run
</a></p>
<h2><a class="anchor" aria-hidden="true" id="tbind"></a><a href="#tbind" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>T.bind</code></h2>
<p><code>T.bind</code> works like <code>T.cast</code>, except with special syntactic sugar for <code>self</code>. Like <code>T.cast</code>, it is unchecked statically but checked at runtime. Unlike <code>T.cast</code>, it does not require assigning the result to a variable.</p>
<p>Sometimes we would like to use <code>T.cast</code> to ascribe a type for <code>self</code>. One option is to assign the cast result to a variable, perhaps called <code>this</code>:</p>
<pre><code class="hljs css language-ruby">this = T.cast(<span class="hljs-keyword">self</span>, MyClass)
this.method_on_my_class
</code></pre>
<p>This is annoying:</p>
<ul>
<li>It requires replacing <code>self</code> with <code>this</code> everywhere it’s used.</li>
<li>It prevents calling private methods.</li>
</ul>
<p>If we tried to clean this up with something like <code>self = T.cast(self, ...)</code>, the Ruby VM rejects our code with a syntax error: <code>self</code> is not a variable, and can’t be used as the name of one.</p>
<p>Thus, Sorbet provides <code>T.bind</code> for this specific usecase instead:</p>
<pre><code class="hljs css language-ruby">T.bind(<span class="hljs-keyword">self</span>, MyClass)
<span class="hljs-keyword">self</span>.method_on_my_class
</code></pre>
<p><code>T.bind</code> is the only type assertion that does not require assigning the assertion result into a variable, and it can only be used on <code>self</code>.</p>
<p><code>T.bind</code> can be used anywhere <code>self</code> is used (i.e., methods, blocks, lambdas, etc.), though it is most usually useful within blocks. See <a href="/docs/procs">Blocks, Procs, and Lambda Types</a> for more real-world usage examples.</p>
<h2><a class="anchor" aria-hidden="true" id="static-vs-runtime-checking"></a><a href="#static-vs-runtime-checking" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Static vs Runtime Checking</h2>
<p>At runtime, all of these assertions verify the <code>expr</code> they are passed matches the <code>Type</code> they are passed.</p>
<p>Statically, e.g., when type checking with <code>srb tc</code>, some of them are <strong>assumed</strong> to hold, but not statically checked.</p>
<table>
<thead>
<tr><th>Assertion</th><th>Static</th><th>Runtime</th></tr>
</thead>
<tbody>
<tr><td><code>T.let(expr, Type)</code></td><td>checked</td><td>checked</td></tr>
<tr><td><code>T.cast(expr, Type)</code></td><td><strong>assumed</strong></td><td>checked</td></tr>
<tr><td><code>T.must(expr)</code></td><td><strong>assumed</strong></td><td>checked</td></tr>
<tr><td><code>T.assert_type!(expr, Type)</code></td><td>checked</td><td>checked</td></tr>
<tr><td><code>T.bind(self, Type)</code></td><td><strong>assumed</strong></td><td>checked</td></tr>
</tbody>
</table>
<p>When an assertion is assumed to hold statically, Sorbet will only use it for the purpose of updating its internal understanding of the types, and will never attempt to alert the programmer that an assumption might not hold. In this sense, those assertions can be considered <a href="/docs/troubleshooting#escape-hatches">Escape Hatches</a> for getting something to typecheck that might not otherwise.</p>
<p><strong>Note</strong> that even though all of these assertions are checked at runtime, some <strong>individual types</strong> might never be checked at runtime, regardless of the type assertion used. This includes the element types of generics (like the <code>Integer</code> in <code>T::Array[Integer]</code>), the argument and return types of <a href="/docs/procs">Proc Types</a>, <a href="/docs/self-type"><code>T.self_type</code></a>, <a href="attached-class"><code>T.attached_class</code></a>, and others.</p>
<p>These assertions are also subject to the <code>T::Configuration</code> hooks that <code>sorbet-runtime</code> provides for controlling runtime type checking. See <a href="/docs/tconfiguration">Runtime Configuration</a> for more. By default, all of these assertions will raise a <code>TypeError</code> if they are violated at runtime.</p>
<p>It’s possible to opt out of runtime checking for individual calls to <code>T.let</code>, <code>T.cast</code>, and <code>T.bind</code> by adding <code>checked: false</code>, e.g. <code>x = T.let(y, Foo, checked: false)</code>. This isn’t recommended in most circumstances, even in performance-critical code; while adding <code>checked(:never)</code> to a method signature is an easy way to remove performance overhead, doing the same for <code>T.let</code> removes neither the method call overhead nor the overhead of constructing any type argument. For more effective options, see below.</p>
<h2><a class="anchor" aria-hidden="true" id="comparison-of-type-assertions"></a><a href="#comparison-of-type-assertions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Comparison of type assertions</h2>
<p>Here are some other ways to think of the behavior of the individual type assertions:</p>
<ul>
<li><p><code>T.let</code> vs <code>T.cast</code></p>
<pre><code class="hljs css language-ruby">T.cast(expr, Type)
</code></pre>
<p>is the same as</p>
<pre><code class="hljs css language-ruby">T.let(T.unsafe(expr), Type)
</code></pre></li>
<li><p><code>T.unsafe</code> in terms of <code>T.let</code></p>
<pre><code class="hljs css language-ruby">T.unsafe(expr)
</code></pre>
<p>is the same as</p>
<pre><code class="hljs css language-ruby">T.let(expr, T.untyped)
</code></pre></li>
<li><p><code>T.must</code> is like <code>T.cast</code>, but without having to know the result type:</p>
<pre><code class="hljs css language-ruby">T.cast(nil_or_string, String)
</code></pre>
<p>is the same as</p>
<pre><code class="hljs css language-ruby">T.must(nil_or_string)
</code></pre></li>
<li><p><code>T.bind</code> is like <code>T.cast</code>, but only for <code>self</code>,</p>
<pre><code class="hljs css language-ruby">T.bind(<span class="hljs-keyword">self</span>, String)
</code></pre>
<p>behaves like</p>
<pre><code class="hljs css language-ruby"><span class="hljs-keyword">self</span> = T.cast(<span class="hljs-keyword">self</span>, String)
</code></pre>
<p>if it were valid in Ruby to assign to <code>self</code>.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="performance-considerations"></a><a href="#performance-considerations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Performance considerations</h2>
<p>Unlike <code>sig</code> annotations, type assertions <em>always</em> have a performance cost, even if runtime checks are globally disabled or <code>checked: false</code> is used at individual callsites. <code>T.let</code> and friends are ordinary Ruby method calls, which have intrisic overhead, in addition to the overhead of constructing any type arguments.</p>
<p>This overhead isn’t normally worth worrying about, but in code where you are already micro-optimizing to reduce method calls or object allocations, there are a few patterns that may be helpful:</p>
<h3><a class="anchor" aria-hidden="true" id="prefer-method-signatures-over-type-assertions"></a><a href="#prefer-method-signatures-over-type-assertions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefer method signatures over type assertions</h3>
<p>It’s often possible to avoid using a type assertion at all, without loss of type safety, with a slight refactoring.</p>
<p>For example, one common use for a type assertion is defining the type of an instance variable. One can frequently move this type definition to the signature of the constructor, taking advantage of Sorbet’s ability to infer instance variable types when variables are set directly from constructor arguments.</p>
<p>Instead of:</p>
<pre><code class="hljs css language-ruby">sig { void.checked(<span class="hljs-symbol">:tests</span>) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>
  @foo = T.let(MyObject.new, MyInterface)
<span class="hljs-keyword">end</span>
</code></pre>
<p>Write:</p>
<pre><code class="hljs css language-ruby">sig { params(<span class="hljs-symbol">foo:</span> MyInterface).void.checked(<span class="hljs-symbol">:tests</span>) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(<span class="hljs-symbol">foo:</span> MyObject.new)</span></span>
  @foo = foo
<span class="hljs-keyword">end</span>
</code></pre>
<p>In other circumstances, breaking out a method can avoid a type assertion (which would itself involve at least one method call anyway).</p>
<p>For example, rather than:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hot_method</span><span class="hljs-params">(..)</span></span>
  <span class="hljs-comment"># ...</span>
  x = T.let(polymorphic_factory(foo_please), Foo)
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Write:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hot_method</span><span class="hljs-params">(..)</span></span>
  <span class="hljs-comment"># ...</span>
  x = make_foo
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>

sig { returns(FooType).checked(<span class="hljs-symbol">:tests</span>) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_foo</span></span>
  polymorphic_factory(foo_please)
<span class="hljs-keyword">end</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="avoid-constructing-type-objects"></a><a href="#avoid-constructing-type-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avoid constructing type objects</h3>
<p>The construction of an non-trivial type object is typically the most expensive part of a type assertion at runtime. One can usually mitigate this with the use of <code>T.type_alias</code>.</p>
<p>For example, rather than:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hot_method</span><span class="hljs-params">(..)</span></span>
  <span class="hljs-comment"># ...</span>
  foo = T.let({}, T::Hash[T.nilable(Symbol), T.any(Integer, Float)])
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Write:</p>
<pre><code class="hljs css language-ruby">FooHash = T.type_alias { T::Hash[T.nilable(Symbol), T.any(Integer, Float)] }

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hot_method</span><span class="hljs-params">(..)</span></span>
  <span class="hljs-comment"># ...</span>
  foo = T.let({}, FooHash)
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="put-type-assertions-behind-memoization"></a><a href="#put-type-assertions-behind-memoization" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Put type assertions behind memoization</h3>
<p>Performance-sensitive methods are often memoized. In this case, it’s usually possible to memoize the runtime type check as well.</p>
<p>For example, rather than:</p>
<pre><code class="hljs css language-ruby">sig { returns(Foo).checked(<span class="hljs-symbol">:tests</span>) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
  @foo = T.let(@foo, T.nilable(Foo))
  @foo <span class="hljs-params">||</span>= something_expensive
<span class="hljs-keyword">end</span>
</code></pre>
<p>Write:</p>
<pre><code class="hljs css language-ruby">sig { returns(Foo).checked(<span class="hljs-symbol">:tests</span>) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
  @foo <span class="hljs-params">||</span>= T.let(something_expensive, T.nilable(Foo))
<span class="hljs-keyword">end</span>
</code></pre>
<p>Note that for class methods, there’s a better option:</p>
<pre><code class="hljs css language-ruby">@foo = T.let(<span class="hljs-literal">nil</span>, T.nilable(Foo))

sig { returns(Foo).checked(<span class="hljs-symbol">:tests</span>) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">foo</span></span>
  @foo <span class="hljs-params">||</span>= something_expensive
<span class="hljs-keyword">end</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="inline-type-assertions-using-flow-sensitivity"></a><a href="#inline-type-assertions-using-flow-sensitivity" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Inline type assertions using flow-sensitivity</h3>
<p>A type assertion can usually be replaced by an explicit <code>===</code>, <code>is_a?</code> or equivalent check of a local variable, which will avoid a method call. Sometimes this makes code more verbose, but sometimes it can be a readability improvement instead, especially in cases involving <code>T.must</code>.</p>
<p>For example, in place of:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-keyword">if</span> foo.bar
  T.must(foo.bar).baz
<span class="hljs-keyword">end</span>
</code></pre>
<p>Write:</p>
<pre><code class="hljs css language-ruby">x = foo.bar
<span class="hljs-keyword">if</span> x
  x.baz
<span class="hljs-keyword">end</span>
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/type-annotations"><span class="arrow-prev">← </span><span>Type Annotations (non-sig)</span></a><a class="docs-next button" href="/docs/class-types"><span>Class Types (Integer, String)</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#tlet"><code>T.let</code></a></li><li><a href="#tcast"><code>T.cast</code></a></li><li><a href="#tmust"><code>T.must</code></a><ul class="toc-headings"><li><a href="#tmust_because"><code>T.must_because</code></a></li></ul></li><li><a href="#tassert_type"><code>T.assert_type!</code></a></li><li><a href="#tbind"><code>T.bind</code></a></li><li><a href="#static-vs-runtime-checking">Static vs Runtime Checking</a></li><li><a href="#comparison-of-type-assertions">Comparison of type assertions</a></li><li><a href="#performance-considerations">Performance considerations</a><ul class="toc-headings"><li><a href="#prefer-method-signatures-over-type-assertions">Prefer method signatures over type assertions</a></li><li><a href="#avoid-constructing-type-objects">Avoid constructing type objects</a></li><li><a href="#put-type-assertions-behind-memoization">Put type assertions behind memoization</a></li><li><a href="#inline-type-assertions-using-flow-sensitivity">Inline type assertions using flow-sensitivity</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer"><svg width="99" height="28" viewBox="0 0 99 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.98432 20H6.27432C8.44932 20 9.81432 18.905 9.81432 17.03C9.81432 15.665 9.00432 14.72 7.78932 14.39C8.61432 14.105 9.45432 13.415 9.45432 12.035C9.45432 10.235 8.23932 9.23 5.95932 9.23H1.98432V20ZM3.37932 13.85V10.445H5.83932C7.27932 10.445 8.07432 11 8.07432 12.155C8.07432 13.295 7.27932 13.85 5.83932 13.85H3.37932ZM3.37932 15.08H6.21432C7.65432 15.08 8.43432 15.83 8.43432 16.925C8.43432 18.035 7.65432 18.785 6.21432 18.785H3.37932V15.08ZM18.0294 12.155H16.6794V16.88C16.6794 18.185 15.6894 18.92 14.7144 18.92C13.5594 18.92 13.0794 18.17 13.0794 17.06V12.155H11.7294V17.345C11.7294 19.01 12.6744 20.165 14.3544 20.165C15.4644 20.165 16.2294 19.58 16.6794 18.92V20H18.0294V12.155ZM20.5112 10.79H21.9812V9.23H20.5112V10.79ZM21.9212 12.155H20.5712V20H21.9212V12.155ZM25.8247 9.23H24.4747V20H25.8247V9.23ZM28.5882 18.125C28.5882 19.625 29.3532 20.075 30.6882 20.075C31.1382 20.075 31.5282 20.03 31.8732 19.955V18.8C31.5582 18.875 31.3332 18.89 31.0182 18.89C30.3282 18.89 29.9232 18.74 29.9232 17.915V13.31H31.7082V12.155H29.9232V9.86H28.5882V12.155H27.3732V13.31H28.5882V18.125ZM41.0199 20.165C43.1949 20.165 44.4399 18.305 44.4399 16.085C44.4399 13.85 43.1949 12.005 41.0199 12.005C39.9249 12.005 39.0549 12.53 38.5899 13.295V9.23H37.2399V20H38.5899V18.86C39.0549 19.64 39.9249 20.165 41.0199 20.165ZM38.5599 15.815C38.5599 13.985 39.6699 13.19 40.7799 13.19C42.2499 13.19 43.0749 14.39 43.0749 16.085C43.0749 17.765 42.2499 18.98 40.7799 18.98C39.6699 18.98 38.5599 18.17 38.5599 16.37V15.815ZM49.1804 20.855L52.5554 12.155H51.1454L48.9704 18.155L46.7654 12.155H45.3404L48.2504 19.715L47.8754 20.645C47.5604 21.425 47.2454 21.635 46.6604 21.635C46.4354 21.635 46.2704 21.62 46.0154 21.56V22.73C46.2554 22.775 46.4204 22.79 46.7504 22.79C48.1154 22.79 48.7304 22.04 49.1804 20.855Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M98.7993 15.7838C98.7993 12.8786 97.3871 10.5862 94.688 10.5862C91.9774 10.5862 90.3374 12.8786 90.3374 15.7611C90.3374 19.177 92.2735 20.9019 95.0524 20.9019C96.4077 20.9019 97.4327 20.5955 98.2071 20.1643V17.8946C97.4327 18.2804 96.5443 18.5188 95.4168 18.5188C94.3121 18.5188 93.3327 18.1329 93.2074 16.7938H98.7766C98.7766 16.6463 98.7993 16.0561 98.7993 15.7838ZM93.1732 14.7057C93.1732 13.4233 93.9591 12.8899 94.6766 12.8899C95.3713 12.8899 96.1116 13.4233 96.1116 14.7057H93.1732Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M85.9413 10.5862C84.8251 10.5862 84.1076 11.1082 83.709 11.4714L83.561 10.7678H81.0554V24.0001L83.9026 23.3986L83.914 20.187C84.324 20.482 84.9276 20.9019 85.9299 20.9019C87.9685 20.9019 89.8249 19.2678 89.8249 15.6703C89.8135 12.3792 87.9343 10.5862 85.9413 10.5862ZM85.2579 18.4053C84.586 18.4053 84.1874 18.167 83.914 17.8719L83.9026 13.6616C84.1988 13.3325 84.6088 13.1055 85.2579 13.1055C86.2943 13.1055 87.0118 14.2631 87.0118 15.7497C87.0118 17.2704 86.3057 18.4053 85.2579 18.4053Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M77.1377 9.91656L79.9963 9.30374V7L77.1377 7.60147V9.91656Z" fill="white"></path><path d="M79.9963 10.7791H77.1377V20.709H79.9963V10.7791Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M74.074 11.6187L73.8918 10.7789H71.4318V20.7088H74.279V13.9792C74.9509 13.1054 76.0898 13.2642 76.4429 13.3891V10.7789C76.0784 10.6427 74.7459 10.3931 74.074 11.6187Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M68.3796 8.31641L65.6007 8.90653L65.5894 17.9966C65.5894 19.6762 66.8535 20.9132 68.5391 20.9132C69.473 20.9132 70.1563 20.743 70.5321 20.5387V18.235C70.1677 18.3825 68.3682 18.9045 68.3682 17.225V13.1962H70.5321V10.779H68.3682L68.3796 8.31641Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M60.6807 13.6616C60.6807 13.219 61.0452 13.0488 61.6488 13.0488C62.5143 13.0488 63.6076 13.3098 64.4732 13.7751V11.1082C63.5279 10.7337 62.594 10.5862 61.6488 10.5862C59.3368 10.5862 57.7993 11.7891 57.7993 13.7978C57.7993 16.93 62.1271 16.4306 62.1271 17.7811C62.1271 18.3031 61.6715 18.4734 61.0338 18.4734C60.0885 18.4734 58.8813 18.0875 57.9246 17.5655V20.2664C58.9838 20.7204 60.0543 20.9133 61.0338 20.9133C63.4026 20.9133 65.0313 19.7444 65.0313 17.713C65.0199 14.3312 60.6807 14.9326 60.6807 13.6616Z" fill="white"></path></svg><a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div><div id="csat-extension-config" data-notify="#sorbet-team"></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>