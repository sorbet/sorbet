<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Sorbet Error Reference · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;style&gt;"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Sorbet Error Reference · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="&lt;style&gt;"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Troubleshooting</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">Signatures</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">Type Assertions</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow Sensitivity</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">Type Aliases</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types</a></li><li class="navListItem"><a class="navItem" href="/docs/non-forcing-constants">T::NonForcingConstants</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/error-reference.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Sorbet Error Reference</h1></header><article><div><span><style>
#missing-doc-for-error-code-box.is-hidden {
  display: none;
}
</style>
<div class="is-hidden red" id="missing-doc-for-error-code-box">
<p><a class="anchor" aria-hidden="true" id="missing-doc-for-error-code-scroll"></a></p>
<blockquote>
<p><strong>Heads up</strong>: There aren’t any docs yet for <span id="missing-error-code">this
error code</span>. If you have suggestions for what would have helped you
solve this problem, click the “Edit” button above to contribute! Otherwise,
try using the search above to find an answer.</p>
</blockquote>
</div>
<blockquote>
<p><strong>Note</strong>: This list is not exhaustive! Some errors are very context dependent
and other error codes are not common enough to know how to generally suggest
help. Contributions to this list are welcome!</p>
</blockquote>
<p>This is one of three docs aimed at helping answer common questions about Sorbet:</p>
<ol>
<li><a href="/docs/troubleshooting">Troubleshooting</a></li>
<li><a href="/docs/faq">Frequently Asked Questions</a></li>
<li><a href="/docs/error-reference">Sorbet Error Reference</a> (this doc)</li>
</ol>
<p>This page contains tips and tricks for common errors from <code>srb</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="1001"></a><a href="#1001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1001</h2>
<p>Sorbet has crashed. Please <a href="https://github.com/sorbet/sorbet/issues">report an issue</a>!</p>
<h2><a class="anchor" aria-hidden="true" id="1004"></a><a href="#1004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1004</h2>
<p>Sorbet couldn’t find a file.</p>
<h2><a class="anchor" aria-hidden="true" id="2001"></a><a href="#2001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2001</h2>
<p>There was a Ruby syntax error. Sorbet was unable to parse the source code. If
you encounter this error but your code is accepted by Ruby itself, this is a bug
in our parser; please <a href="https://github.com/sorbet/sorbet/issues">report an issue</a> to us so we can address it.</p>
<p>The only intentional break with Ruby compatibility is that method names that are
keywords have some limitations with multi-line code, as explained in <a href="https://github.com/sorbet/sorbet/pull/1993">#1993</a>,
and should not be reported.</p>
<h2><a class="anchor" aria-hidden="true" id="3001"></a><a href="#3001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3001</h2>
<p>Sorbet doesn’t support singleton definitions outside of the class itself:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; MyClass <span class="hljs-comment"># error: `class &lt;&lt; EXPRESSION` is only supported for `class &lt;&lt; self`</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The workaround is to move the definition inside the <code>MyClass</code> class itself:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; self</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
      <span class="hljs-comment"># ...</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Sometimes, <code>EXPRESSION</code> is not a constant literal like in what follows:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; some_variable</span>
  <span class="hljs-keyword">include</span> Foo
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, it is possible to directly call <code>include</code> on the the singleton
class of <code>EXPRESSION</code>, but it should be done with <strong>utmost caution</strong>, as Sorbet
will not consider the include and provide a less accurate analysis (see also
<a href="#4002">#4002</a>):</p>
<pre><code class="hljs css language-rb">some_variable.singleton_class.<span class="hljs-keyword">include</span>(Foo)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3002"></a><a href="#3002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3002</h2>
<p>Sorbet is limited to C++ <code>INT_MAX</code>:</p>
<pre><code class="hljs css language-rb">puts <span class="hljs-number">11377327221391349843</span> + <span class="hljs-number">1</span> <span class="hljs-comment"># error: Unsupported integer literal: 11377327221391349843</span>
</code></pre>
<p>A possible workaround is to use a string and <code>to_i</code>:</p>
<pre><code class="hljs css language-rb">puts <span class="hljs-string">"11377327221391349843"</span>.to_i + <span class="hljs-number">1</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3011"></a><a href="#3011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3011</h2>
<p>There was a Hash literal with duplicated keys.</p>
<pre><code class="hljs css language-ruby">{<span class="hljs-symbol">my_key:</span> <span class="hljs-number">1</span>, <span class="hljs-symbol">my_key:</span> <span class="hljs-number">2</span>} <span class="hljs-comment"># error: `my_key` is duplicated</span>
</code></pre>
<p>This error can also be caused when trying to write a <code>sig</code> for a method with
duplicated parameter names:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">_:</span> String, <span class="hljs-symbol">_:</span> Integer).void} <span class="hljs-comment"># error: `_` is duplicated</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-number">_</span>, <span class="hljs-number">_</span>)</span></span>; <span class="hljs-keyword">end</span>
</code></pre>
<p>To write a <code>sig</code> for this method, rename the method’s parameters to have unique
names:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">_a:</span> String, <span class="hljs-symbol">_b:</span> Integer).void} <span class="hljs-comment"># ok</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(_a, _b)</span></span>; <span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="4002"></a><a href="#4002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4002</h2>
<p>Sorbet requires that every <code>include</code> references a constant literal. For example,
this is an error, even in <code># typed: false</code> files:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span></span>
  rand.round == <span class="hljs-number">0</span> ? A : B
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  <span class="hljs-keyword">include</span> x  <span class="hljs-comment"># error: `include` must be passed a constant literal</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Non-constant literals make it hard to impossible to determine the complete
inheritance hierarchy in a codebase. Sorbet must know the complete inheritance
hierarchy of a codebase in order to check that a variable is a valid instance of
a type.</p>
<p>It is possible to silence this error with <code>T.unsafe</code>, but it should be done with
<strong>utmost caution</strong>, as Sorbet will not consider the include and provide a less
accurate analysis:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span></span>
  rand.round == <span class="hljs-number">0</span> ? A : B
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  T.unsafe(<span class="hljs-keyword">self</span>).<span class="hljs-keyword">include</span> x
<span class="hljs-keyword">end</span>
</code></pre>
<p>Which might create unexpected errors:</p>
<pre><code class="hljs css language-ruby">c = C.new

c.a <span class="hljs-comment"># error: Method `a` does not exist on `C`</span>
c.b <span class="hljs-comment"># error: Method `b` does not exist on `C`</span>

T.let(C, A) <span class="hljs-comment"># error: Argument does not have asserted type `A`</span>
T.let(C, B) <span class="hljs-comment"># error: Argument does not have asserted type `B`</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="4010"></a><a href="#4010" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4010</h2>
<p>There are multiple definitions for a method. Having multiple definitions for a
method is problematic, because it can make a codebase’s behavior dependent on
the order in which files are loaded.</p>
<p>The only way to silence this error currently is to mark the offending file as
<code># typed: false</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="4011"></a><a href="#4011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4011</h2>
<p>There are multiple definitions for the same type member within a given class or
module.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>
  extend T::Generic

  Elem = type_member
  Elem = type_member <span class="hljs-comment"># error: Duplicate type member</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>You can fix this by removing the second definition of the type member:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>
  extend T::Generic

  Elem = type_member <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="4012"></a><a href="#4012" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4012</h2>
<p>A <code>class</code> was redefined as a <code>module</code> or <em>vice versa</em> in two separate locations.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># file_a.rb</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># file_b.rb</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0A%23%20file_a.rb%0Aclass%20Foo%0Aend%0A%0A%23%20file_b.rb%0Amodule%20Foo%0Aend">→
View on sorbet.run</a></p>
<p>You can fix this error by ensuring that both definitions are declared as
<code>class</code>es, ensuring both definitions are declared as <code>module</code>s, or renaming
either definition so they no longer conflict.</p>
<h2><a class="anchor" aria-hidden="true" id="4015"></a><a href="#4015" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4015</h2>
<p>This error usually comes when a class or module is dynamically defined and
stored into a constant, like this:</p>
<pre><code class="hljs css language-ruby">A = ...
A::B = <span class="hljs-number">1</span>
</code></pre>
<p>where <code>...</code> is some expression which computes a class or module. Sorbet can’t
know statically what this <code>...</code> code does (and for example even if could assume
that it’s defining a class, Sorbet can’t know what methods or constants it has).
Therefore, Sorbet does not support this pattern.</p>
<h2><a class="anchor" aria-hidden="true" id="5001"></a><a href="#5001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5001</h2>
<p>Sorbet cannot resolve references to dynamic constants. The common case occurs
when a constant is dynamically referenced through the singleton class of <code>self</code>:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCachable</span> &lt; Cachable</span>
  CACHE_KEY_PREFIX = <span class="hljs-string">"my_cachable_"</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cache_key</span></span>
    <span class="hljs-keyword">self</span><span class="hljs-class">.<span class="hljs-keyword">class</span>::<span class="hljs-title">CACHE_KEY_PREFIX</span> + <span class="hljs-title">identifier</span></span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This code can by made statically analysable by using a singleton method to
reference the constant:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCachable</span> &lt; Cachable</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cache_key</span></span>
    <span class="hljs-keyword">self</span><span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">cache_key_prefix</span> + <span class="hljs-title">identifier</span></span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; self</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cache_key_prefix</span></span>
      <span class="hljs-string">"my_cachable_"</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5002"></a><a href="#5002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5002</h2>
<p>This means that the typechecker has been unable to resolve a reference to a
constant (e.g., a Ruby class). Most commonly, this indicates that there’s a
typo.</p>
<p>First, try confirming whether the code runs successfully. Does the code raise an
“uninitialized constant” error when run? If so, Sorbet caught a bug! Try finding
out why that constant is actually uninitialized.</p>
<p>If it isn’t a typo, then there are a few other things to look at. If it looks
like the constant is related to a gem, maybe one of these helps:</p>
<ul>
<li><p>Is it coming from a gem? Sorbet does not look through the gem’s source code.
Instead, there must be an <code>*.rbi</code> file for this gem. Try finding the <code>*.rbi</code>
corresponding to this gem, and searching through it for the constant.</p>
<p>For more information, see <a href="/docs/rbi">RBI files</a>. If you are at Stripe, please
instead see <a href="http://go/types/rbi">http://go/types/rbi</a>.</p></li>
<li><p>If the gem was recently updated, its <code>*.rbi</code> might need to be regenerated.
Each RBI file has a line at the top which can be copy / pasted to re-generate
the file when the underlying gem has changed.</p></li>
<li><p>When deleting constants, sometimes they are still referenced from an
autogenerated <code>*.rbi</code> file. If that’s the case, consider deleting the constant
or regenerating the file.</p></li>
</ul>
<p>Another thing it could be: Sorbet explicitly does not support resolving
constants through ancestors (both mixins or superclasses).</p>
<p>Concretely, here’s an example of code rejected and accepted by Sorbet:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  MY_CONST = <span class="hljs-number">91</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent;</span> <span class="hljs-keyword">end</span>

Child::MY_CONST    <span class="hljs-comment"># error</span>
Parent::MY_CONST   <span class="hljs-comment"># ok</span>
</code></pre>
<p>Alternatively, if it’s much more preferable to access the constant on the child,
we can set up an explicit alias:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  MY_CONST = <span class="hljs-number">91</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  MY_CONST = Parent::MY_CONST
<span class="hljs-keyword">end</span>

Child::MY_CONST    <span class="hljs-comment"># ok</span>
Parent::MY_CONST   <span class="hljs-comment"># ok</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5005"></a><a href="#5005" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5005</h2>
<p>A class or instance variable is defined in the wrong context.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    @@class_var = T.let(<span class="hljs-number">10</span>, Integer)
    @x = T.let(<span class="hljs-number">10</span>, Integer)
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>
</code></pre>
<p>There are two such errors in the above. In the first, <code>@@class_var</code> is declared
outside of the class scope. In the second, <code>@x</code> is declared outside of the
<code>initialize</code> method.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5006"></a><a href="#5006" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5006</h2>
<p>An instance variable has been redeclared with another type.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>
    @x = T.let(<span class="hljs-number">10</span>, Integer)
    @x = T.let(<span class="hljs-string">"x"</span>, String)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5008"></a><a href="#5008" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5008</h2>
<p>A class was defined as the subclass of a <code>type_alias</code>. It also occurs if a
<code>type_alias</code> mixin is used in a class.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
A = T.type_alias {Integer}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &lt; A;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error: Superclasses and mixins may not be type aliases</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">M</span>;</span> <span class="hljs-keyword">end</span>

AliasModule = T.type_alias {M}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  <span class="hljs-keyword">include</span> AliasModule <span class="hljs-comment"># error: Superclasses and mixins may not be type aliases</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5011"></a><a href="#5011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5011</h2>
<p>A class inherits from itself either directly or through an inheritance chain.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &lt; A;</span> <span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &lt; C;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt; B;</span> <span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5012"></a><a href="#5012" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5012</h2>
<p>A class was changed to inherit from a different superclass.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt; A;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt; B;</span> <span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5013"></a><a href="#5013" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5013</h2>
<p>A class or instance variable declaration used <code>T.cast</code> when it should use
<code>T.let</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  @@x = T.cast(<span class="hljs-number">10</span>, Integer)
<span class="hljs-keyword">end</span>
</code></pre>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<p>To instead use <code>T.cast</code> as a runtime-only type check (that is, neither as a
statically-checked assertion nor as an instance variable declaration), assign
the cast result to an intermediate variable:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  x = T.cast(<span class="hljs-number">10</span>, Integer)
  @@x = x
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5014"></a><a href="#5014" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5014</h2>
<p>Given code like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  extend T::Generic
  Foo = type_member
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  extend T::Generic
<span class="hljs-keyword">end</span>
</code></pre>
<p>We need to change our code to redeclare the type member in the child class too:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  extend T::Generic
  Foo = type_member
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  extend T::Generic
  Foo = type_member
<span class="hljs-keyword">end</span>
</code></pre>
<p>The same thing holds for type templates.</p>
<h2><a class="anchor" aria-hidden="true" id="5023"></a><a href="#5023" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5023</h2>
<p>Some modules require specific functionality in the receiving class to work. For
example <code>Enumerable</code> needs a <code>each</code> method in the target class.</p>
<p>Failing example in
<a href="https://sorbet.run/#class%20Example%0A%20%20include%20Enumerable%0Aend">sorbet.run</a>:</p>
<pre><code class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span>
  <span class="hljs-symbol">include</span> <span class="hljs-symbol">Enumerable</span>
<span class="hljs-symbol">end</span>
</code></pre>
<p>To fix this, implement the required abstract methods in your class to provide
the required functionality.</p>
<p>Passing example in
<a href="https://sorbet.run/#class%20Example%0A%20%20include%20Enumerable%0A%0A%20%20def%20each(%2526blk)%0A%0A%20%20end%0Aend">sorbet.run</a>:</p>
<pre><code class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span>
  <span class="hljs-symbol">include</span> <span class="hljs-symbol">Enumerable</span>

  <span class="hljs-symbol">def</span> <span class="hljs-symbol">each</span>(&amp;<span class="hljs-symbol">blk</span>)
  <span class="hljs-symbol">end</span>
<span class="hljs-symbol">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5028"></a><a href="#5028" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5028</h2>
<p>In <code># typed: strict</code> files, Sorbet requires that all constants are annotated
with a <code>T.let</code>.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<p>See also: <a href="#6002">6002</a>, <a href="#7017">7017</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5034"></a><a href="#5034" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5034</h2>
<p>Sorbet does not support creating normal Ruby constant aliases to type aliases.
Once a type alias is created, all subsequent aliases must also be type aliases.</p>
<p>Concretely, this is not allowed:</p>
<pre><code class="hljs css language-ruby">A = T.type_alias {Integer}
B = A <span class="hljs-comment"># error: Reassigning a type alias is not allowed</span>
</code></pre>
<p>while this is:</p>
<pre><code class="hljs css language-ruby">A = T.type_alias {Integer}
B = T.type_alias {A}
</code></pre>
<p>(Why? This is due to design tradeoffs to enforce stronger internal invariants.
Basically, Sorbet can emit more reliable warnings when users declare their
intent to create a new type alias.)</p>
<h2><a class="anchor" aria-hidden="true" id="5035"></a><a href="#5035" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5035</h2>
<p>A method was marked <code>override</code>, but sorbet was unable to find a method in the
class’s ancestors that would be overridden. Ensure that the method being
overridden exists in the ancestors of the class defining the <code>override</code> method,
or remove <code>override</code> from the signature that’s raising the error. See
<a href="override-checking">Override Checking</a> for more information about <code>override</code>.</p>
<p>If the parent method definitely exists at runtime, it might be hidden in a
<a href="static#file-level-granularity-strictness-levels"><code># typed: ignore</code></a> file.
Sorbet will not see it and this error will be raised. In that case you will need
to either raise the <code>typed</code> sigil of that file above <code>ignore</code>, or generate an
<a href="rbi">RBI file</a> that contains signatures for the classes and methods that file
defines.</p>
<h2><a class="anchor" aria-hidden="true" id="5036"></a><a href="#5036" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5036</h2>
<p>See <a href="#5014">5014</a>. 5036 is the same error as <a href="#5014">5014</a> but slightly modified
to allow more common Ruby idioms to pass by in <code># typed: true</code> (5036 is only
reported in <code># typed: strict</code>).</p>
<h2><a class="anchor" aria-hidden="true" id="5037"></a><a href="#5037" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5037</h2>
<p>Sorbet must be able to statically resolve a method to create an alias to it.</p>
<p>Here, the method is created through a DSL called <code>data_accessor</code> which defines
methods at runtime through meta-programming:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">data_accessor</span><span class="hljs-params">(key)</span></span>
    define_method(key) <span class="hljs-keyword">do</span>
      data[key]
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &lt; Base</span>
  data_accessor <span class="hljs-symbol">:foo</span>

  alias_method <span class="hljs-symbol">:bar</span>, <span class="hljs-symbol">:foo</span> <span class="hljs-comment"># error: Can't make method alias from `bar` to non existing method `foo`</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>One way to make those methods visible statically is to add a declaration for
them in an <a href="https://sorbet.org/docs/rbi">RBI file</a>. For example, we can write
our definitions as RBI under <code>sorbet/rbi/shims/foo.rbi</code>:</p>
<pre><code class="hljs css language-rb"><span class="hljs-comment"># sorbet/rbi/shims/foo.rbi</span>
<span class="hljs-comment"># typed: true</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Sometimes, Sorbet will complain about an alias to a method coming from an
included modules. For example, here <code>bar</code> is coming from the inclusion of <code>Bar</code>
but Sorbet will complain about the method not existing anyway:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Bar</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-keyword">include</span> Bar

  alias_method <span class="hljs-symbol">:foo</span>, <span class="hljs-symbol">:bar</span> <span class="hljs-comment"># error: Can't make method alias from `foo` to non existing method `bar`</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>It’s because Sorbet resolves method aliases before it resolves includes. You can
see an example of this behaviour
<a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0Amodule%20Bar%0A%20%20def%20bar%3B%20end%0Aend%0A%0Amodule%20Foo%0A%20%20include%20Bar%0A%0A%20%20alias_method%20%3Afoo%2C%20%3Abar%20%23%20aliases%20are%20resolved%20before%20includes%2C%20so%20%60bar%60%20is%20not%20found%20yet%0A%0A%20%20def%20baz%0A%20%20%20%20bar%20%23%20includes%20are%20resolved%20when%20we%20analyze%20this%20code%0A%20%20end%0Aend">here</a>.
To workaround this limitation, we can replace the <code>alias_method</code> by a real
method definition:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-keyword">include</span> Bar

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    bar
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5041"></a><a href="#5041" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5041</h2>
<p>Sorbet does not allow inheriting from a class which inherits from <code>T::Struct</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">S</span> &lt; T::Struct</span>
  prop <span class="hljs-symbol">:foo</span>, Integer
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bad</span> &lt; S;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>
</code></pre>
<p>This limitation exists because, in order to generate a static type for
<code>initialize</code> for a struct, we need to know all of the <code>prop</code>s that are declared
on this struct. By disallowing inheritance of structs, we can know that all of
the props declared on this struct were syntactically present in the class body.</p>
<p>One common situation where inheritance may be desired is when a parent struct
declares some common props, and children structs declare their own props.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> &lt; T::Struct</span>
  prop <span class="hljs-symbol">:foo</span>, Integer
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildOne</span> &lt; Parent <span class="hljs-comment"># error</span></span>
  prop <span class="hljs-symbol">:bar</span>, String
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildTwo</span> &lt; Parent <span class="hljs-comment"># error</span></span>
  prop <span class="hljs-symbol">:quz</span>, Symbol
<span class="hljs-keyword">end</span>
</code></pre>
<p>We can restructure the code to use composition instead of inheritance.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Common</span> &lt; T::Struct</span>
  prop <span class="hljs-symbol">:foo</span>, Integer
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildOne</span> &lt; T::Struct</span>
  prop <span class="hljs-symbol">:common</span>, Common
  prop <span class="hljs-symbol">:bar</span>, String
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChildTwo</span> &lt; T::Struct</span>
  prop <span class="hljs-symbol">:common</span>, Common
  prop <span class="hljs-symbol">:quz</span>, Symbol
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5046"></a><a href="#5046" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5046</h2>
<p>Generic classes must be passed all their generic type arguments when being used
as types. For example:</p>
<pre><code class="hljs css language-ruby">T.let([], Array)              <span class="hljs-comment"># error</span>
T.let([], T::Array[Integer])  <span class="hljs-comment"># ok</span>
</code></pre>
<p>Many classes in the standard library are generic classes
(<a href="/docs/stdlib-generics">see here</a>), and must be passed type arguments, including
<code>Array</code> and <code>Hash</code>. Any user-defined generic classes must similarly be provided
type arguments when used.</p>
<p>For legacy reasons relating to the intial rollout of Sorbet, this error is only
reported at <code># typed: strict</code> for standard library generic classes and
<code># typed: true</code> for all user-defined generic classes. (In an ideal world, it
would have always been reported at <code># typed: true</code>, and we might change this in
the future.)</p>
<h2><a class="anchor" aria-hidden="true" id="5047"></a><a href="#5047" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5047</h2>
<p>A class or module tried to inherit, include, or extend a final class or module.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Final</span></span>
  extend T::Helpers
  final!
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bad</span> &lt; Final;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5048"></a><a href="#5048" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5048</h2>
<p>A class or module was declared as final, but a method in the class or module was
not explicitly declared as final with a final <code>sig</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  extend T::Helpers
  final!

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">no_sig</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>

  extend T::Sig

  sig {void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">non_final_sig</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>

  sig(<span class="hljs-symbol">:final</span>) {void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">final_sig</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># good</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5054"></a><a href="#5054" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5054</h2>
<p>Use of <code>implementation</code> has been replaced by <code>override</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="5056"></a><a href="#5056" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5056</h2>
<p>The <code>generated</code> annotation in method signatures is deprecated.</p>
<p>For alternatives, see <a href="/docs/runtime">Enabling Runtime Checks</a> which talks about
how to change the runtime behavior when method signatures encounter a problem.</p>
<h2><a class="anchor" aria-hidden="true" id="5057"></a><a href="#5057" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5057</h2>
<p>Static methods (like <code>self.foo</code>) can never be mixed into another class or
module. Both <code>include</code> and <code>extend</code> only mix that module’s <em>instance</em> methods
onto the target class or module. Classes can inherit static methods from their
superclass, but only classes (not modules) can be superclasses.</p>
<p>Thus, a static, abstract method on a module is impossible to implement, and thus
is a no-op.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyMixin</span></span>
  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>

  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error: Static methods in a module cannot be abstract</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Some alternatives:</p>
<ul>
<li><p>Use <code>mixes_in_class_methods</code>, which declares to Sorbet that when a module is
included, some other module should be extended into the target class.
<a href="/docs/abstract">Full documentation here</a>. This is the preferred option.</p></li>
<li><p>Separate the interface into two modules. Include one and extend the other in
all the places where</p></li>
<li><p>Change the abstract module to an abstract class, and update all downstream
references to inherit from this class instead of including the original
module.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="5058"></a><a href="#5058" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5058</h2>
<p>It’s an error to use <code>T.attached_class</code> to describe the type of method
parameters. See the
<a href="/docs/attached-class#tattached_class-as-an-argument">T.attached_class</a>
documentation for a more thorough description of why this is.</p>
<h2><a class="anchor" aria-hidden="true" id="5064"></a><a href="#5064" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5064</h2>
<p>Using the <code>requires_ancestor</code> method, module <code>Bar</code> has indicated to Sorbet that
it can only work properly if it is explicitly included along module <code>Foo</code>. In
this example, we see that while module <code>Bar</code> is included in <code>MyClass</code>, <code>MyClass</code>
does not include <code>Foo</code>.</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Bar</span></span>
  extend T::Helpers

  requires_ancestor { Foo }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span></span>
    foo
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-comment"># error: `MyClass` must include `Foo` (required by `Bar`)</span></span>
  <span class="hljs-keyword">include</span> Bar
<span class="hljs-keyword">end</span>
</code></pre>
<p>The solution is to include <code>Foo</code> in <code>MyClass</code>:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-keyword">include</span> Foo
  <span class="hljs-keyword">include</span> Bar
<span class="hljs-keyword">end</span>
</code></pre>
<p>Other potential (albeit less common) sources of this error code are classes that
are required to have some class as an ancestor:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Bar</span></span>
  <span class="hljs-keyword">extend</span> <span class="hljs-symbol">T:</span>:Helpers

  requires_ancestor { Foo }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span></span>
    foo
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySuperClass</span></span>
  <span class="hljs-keyword">extend</span> <span class="hljs-symbol">T:</span>:Helpers
  <span class="hljs-keyword">include</span> Bar

  <span class="hljs-keyword">abstract</span>!
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &lt; <span class="hljs-title">MySuperClass</span> <span class="hljs-comment"># error: `MyClass` must inherit `Foo` (required by `Bar`)</span></span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Ensuring <code>MyClass</code> inherits from <code>Foo</code> at some point will fix the error:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySuperClass</span> &lt; Foo</span>
  extend T::Helpers
  <span class="hljs-keyword">include</span> Bar

  abstract!
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &lt; MySuperClass</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5068"></a><a href="#5068" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5068</h2>
<p>Sorbet requires that class or module definitions be namespaced unambiguously.
For example, in this code:</p>
<pre><code class="hljs"><span class="hljs-comment"># typed: true</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span></span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B::C</span></span>
   <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The definition B::C is ambiguous. In Ruby’s runtime, it resolves to B::C (and
not A::B::C). However, things are different in the presence of a pre-declared
filler namespace like below:</p>
<pre><code class="hljs"><span class="hljs-comment"># typed: true</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B::C</span></span>
   <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, the definition resolves to A::B::C in Ruby’s runtime.</p>
<p>By default, Sorbet assumes the presence of filler namespaces while typechecking,
regardless of whether they are explicitly predeclared like in the second
example. This means that in Sorbet’s view, the definition resolves to A::B::C in
either case.</p>
<p>In Stripe’s codebase, this is generally not a problem at runtime, as we use
Sorbet’s own autoloader generation to pre-declare filler namespaces, keeping the
Ruby runtime’s behavior equivalent to Sorbet. However, the autoloader has some
edge cases, which can often cause deviations between Ruby’s runtime and Sorbet.
This error helps guard against these issues.</p>
<h2><a class="anchor" aria-hidden="true" id="6002"></a><a href="#6002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6002</h2>
<p>In <code># typed: strict</code> files, Sorbet requires that all instance and class
variables are annotated with a <code>T.let</code>.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<p>See also: <a href="#5028">5028</a>, <a href="#7017">7017</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="7001"></a><a href="#7001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7001</h2>
<p>Sorbet does not allow reassigning a variable to a different type within a loop
or block. (Note that we model blocks similarly to loops, as in general they may
execute 0, 1, or more times). Due to implementation constraints, Sorbet does not
permit this behavior.</p>
<p>A prototypical example of code that might trigger this is code that sets a
variable to <code>nil</code>, and then updates it if some value is found inside a loop:</p>
<pre><code class="hljs css language-ruby">found = <span class="hljs-literal">nil</span>

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  found = elem <span class="hljs-keyword">if</span> want?(elem)
<span class="hljs-keyword">end</span>
</code></pre>
<p>In most cases, we can fix this error by declaring the type of the loop variable
outside the loop using <code>T.let</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># This is a type annotation that explicitly widens the type:</span>
found = T.let(<span class="hljs-literal">nil</span>, T.nilable(String))

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  found = elem <span class="hljs-keyword">if</span> want?(elem)
<span class="hljs-keyword">end</span>
</code></pre>
<p><strong>But my variable does not change its type, it is always a <code>Boolean</code>!</strong></p>
<p>In Ruby, there is no <code>Boolean</code> type. Instead, there are <code>FalseClass</code> and
<code>TrueClass</code> types, the union of which defines
<a href="/docs/class-types#booleans"><code>T::Boolean</code> type as a union type</a>.</p>
<p>When Sorbet encounters a variable declaration like <code>x = true</code>, it infers the
type of <code>x</code> as <code>TrueClass</code>. An assignment to <code>x</code> later on in the same block such
as <code>x = false</code> would imply that the variable is reassigned to a different type
(namely, to <code>FalseClass</code> in this case).</p>
<p>For this reason, a loop such as the following triggers an error:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Declares `found_valid` with type `FalseClass`</span>
found_valid = <span class="hljs-literal">false</span>

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  <span class="hljs-comment"># Might change the type of `found_valid` to `TrueClass`</span>
  found_valid = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> valid?(elem) <span class="hljs-comment"># error: Changing the type of a variable in a loop</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The fix, again, is to use <code>T.let</code> to widen the type to <code>T::Boolean</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Declare `found_valid` with type `T::Boolean`</span>
found_valid = T.let(<span class="hljs-literal">false</span>, T::Boolean)

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  <span class="hljs-comment"># Does not change the type of `found_valid`</span>
  found_valid = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> valid?(elem) <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7002"></a><a href="#7002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7002</h2>
<p>This is a standard type mismatch. A method’s <code>sig</code> declares one type, but the
actual value didn’t match. For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-string">'str'</span> + <span class="hljs-symbol">:sym</span>  <span class="hljs-comment"># error: Expected `String` but found `Symbol(:"sym")` for argument `arg0`</span>
</code></pre>
<p>Even still, sometimes these errors can be rather confusing. Consider using
<a href="/docs/troubleshooting"><code>T.reveal_type</code></a> to pin down the origin of why Sorbet
thinks the types are what it says.</p>
<p><strong>Why does Sorbet think this is <code>nil</code>? I just checked that it’s not!</strong></p>
<p>That’s a <a href="flow-sensitive#limitations-of-flow-sensitivity">great question</a>, and
probably the most common question people have when using Sorbet!</p>
<p>It’s answered here:
<a href="flow-sensitive#limitations-of-flow-sensitivity">Limitations of flow-sensitivity</a></p>
<h2><a class="anchor" aria-hidden="true" id="7003"></a><a href="#7003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7003</h2>
<p>This error indicates a call to a method we believe does not exist (a la Ruby’s
<code>NoMethodError</code> exception). Some steps to debug:</p>
<ol>
<li><p>Double check that the code actually runs, either in the REPL, in CI, or with
manual tests. If the method doesn’t actually exist when run, Sorbet caught a
bug!</p></li>
<li><p>Even if the method exists when run, Sorbet still might report an error
because the method won’t <strong>always</strong> be there. For example, maybe the value
is <a href="/docs/nilable-types">nilable</a>, or we have a <a href="/docs/union-types">union</a> of a
handful of different types.</p></li>
<li><p>Many times, methods are defined dynamically in Ruby. Sorbet cannot see
methods defined with <code>define_method</code>. Sorbet also can’t see methods defined
using Ruby’s <code>included</code> + <code>other.extend(self)</code> pattern. For such dynamically
defined methods, Sorbet requires <code>*.rbi</code> files which define the method
statically.</p>
<p>See the <a href="/docs/rbi">RBI</a> docs for how to regenerate the <code>*.rbi</code> files.</p></li>
<li><p><a class="anchor" aria-hidden="true" id="include-kernel"></a>Sorbet will
complain about this code:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span>;</span> <span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">x:</span> MyModule).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  x.<span class="hljs-literal">nil</span>? <span class="hljs-comment"># error: Method `nil?` does not exist on `MyModule`</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The <code>nil?</code> method is defined on <code>Kernel</code> in Ruby. <code>Kernel</code> is included in
<code>Object</code> (which classes default to inheriting from), but not on
<code>BasicObject</code> (which classes can optionally inherit from).</p>
<p>The solution is to <code>include Kernel</code> in our module:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-keyword">include</span> Kernel
<span class="hljs-keyword">end</span>
</code></pre></li>
<li><p>Sorbet will complain about this code:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> puts <span class="hljs-string">'hello'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The issue is similar to the above: <code>puts</code> is defined on <code>Kernel</code>, which is
not necessarily included in our module. For this situation, there are
actually two fixes:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Option 1: include Kernel</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-keyword">include</span> Kernel

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> puts <span class="hljs-string">'hello'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Option 2: Kernel.puts</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> Kernel.puts <span class="hljs-string">'hello'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre></li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="7004"></a><a href="#7004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7004</h2>
<p>This error indicates that a method has been called with incorrect parameters.
There are a few cases where this can occur:</p>
<ul>
<li>Too many parameters</li>
<li>Not enough parameters</li>
<li>Trying to pass parameters that don’t exist</li>
<li>Missing required parameters</li>
<li>Positional parameters used when the method expects named parameters, and vice
versa</li>
</ul>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-symbol">x:</span> <span class="hljs-literal">nil</span>)</span></span>; <span class="hljs-keyword">end</span>

foo(<span class="hljs-number">1</span>) <span class="hljs-comment"># error</span>
foo(<span class="hljs-symbol">y:</span> <span class="hljs-number">1</span>) <span class="hljs-comment"># error</span>
foo(<span class="hljs-symbol">x:</span> <span class="hljs-number">1</span>) <span class="hljs-comment"># ok</span>
foo() <span class="hljs-comment"># ok</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-symbol">x:</span>)</span></span>; <span class="hljs-keyword">end</span>

bar() <span class="hljs-comment"># error</span>
bar(<span class="hljs-number">1</span>) <span class="hljs-comment"># error</span>
bar(<span class="hljs-symbol">x:</span> <span class="hljs-number">1</span>) <span class="hljs-comment"># ok</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7005"></a><a href="#7005" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7005</h2>
<p>Sorbet detected a mismatch between the declared return type for the method and
the type of the returned value:</p>
<pre><code class="hljs css language-rb">sig { returns(Integer) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">answer</span></span>
  <span class="hljs-string">"42"</span> <span class="hljs-comment"># error: Expected `Integer` but found `String("42")` for method result type</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Here we specified in the signature that <code>find</code> returns an instance of
<code>Configuration</code>, yet the returned value might be <code>nil</code>:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  @lookup[name] <span class="hljs-comment"># error: Expected `Configuration` but found `T.nilable(Configuration)` for method result type</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>A possible solution, if we are <em>certain</em> that <code>name</code> is in the <code>@lookup</code> hash,
is to use <code>T.must</code> when returning the value:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  T.must(@lookup[name])
<span class="hljs-keyword">end</span>
</code></pre>
<p>In some cases, we’re already being cautious and perform some checks before
returning yet Sorbet still complains about the return type:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  raise ArgumentError, <span class="hljs-string">"Configuration <span class="hljs-subst">#{name}</span> not found"</span> <span class="hljs-keyword">unless</span> @lookup.key?(name)
  @lookup[name] <span class="hljs-comment"># error: Expected `Configuration` but found `T.nilable(Configuration)` for method result type</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>While this code is correct, Sorbet cannot assume the state of <code>@lookup</code> didn’t
change between the <code>key?</code> check and the <code>[]</code> read. To fix this, we can take
advantage of flow-typing to make the whole method work without inline type
annotations:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  config = @lookup[name]
  raise ArgumentError, <span class="hljs-string">"Configuration <span class="hljs-subst">#{name}</span> not found"</span> <span class="hljs-keyword">unless</span> config
  config
<span class="hljs-keyword">end</span>
</code></pre>
<p>By using a local variable, we allow Sorbet to assert that <code>config</code> is never
nilable past the <code>raise</code> instruction.</p>
<h2><a class="anchor" aria-hidden="true" id="7006"></a><a href="#7006" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7006</h2>
<p>In Sorbet, it is an error to have provably unreachable code. Because Sorbet is
<a href="/docs/flow-sensitive">sensitive to control flow</a> in a program, Sorbet can not only
track what types each variable has within all the branches of a conditional, but
also whether any given branch could be executed at all.</p>
<p>Erroring for dead or unreachable code is generally a way to prevent bugs. People
don’t usually expect that some branch of code is never taken; usually dead code
errors come from simple typos or misunderstandings about how Ruby works. In
particular: the only two “falsy” values in Ruby are <code>nil</code> and <code>false</code>.</p>
<p>Note if you intend for code to be dead because you’ve exhausted all the cases
and are trying to raise in the default case, use <code>T.absurd</code> to assert that a
case analysis is exhaustive. See <a href="/docs/exhaustiveness">Exhaustiveness Checking</a>
for more information.</p>
<p>Sometimes, dead code errors can be hard to track down. The best way to pinpoint
the cause of a dead code error is to wrap variables or expressions in
<code>T.reveal_type(...)</code> to validate the assumptions that a piece of code is making.
For more troubleshooting tips, see <a href="/docs/troubleshooting">Troubleshooting</a>.</p>
<p>If for whatever reason it’s too hard to track down the cause of a dead code
error, it’s possible to silence it by making a variable or expression
“unanalyzable,” aka untyped. (When something is untyped, Sorbet will do very
limited flow-sensitivity analysis compared to if Sorbet knows the type. To make
something unanalyzable, we can wrap it in <code>T.unsafe(...)</code>:</p>
<pre><code class="hljs css language-ruby">x = <span class="hljs-literal">false</span>

<span class="hljs-keyword">if</span> x
  puts <span class="hljs-string">'hello!'</span> <span class="hljs-comment"># error: This code is unreachable</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">if</span> T.unsafe(x)
  puts <span class="hljs-string">'hello!'</span> <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this (contrived) example, Sorbet knows statically that <code>x</code> is always <code>false</code>
and so our <code>puts</code> within the first <code>if</code> is never reachable. On the other hand,
Sorbet allows the second <code>if</code> because we’ve explicitly made <code>x</code> unanalyzable
with <code>T.unsafe(...)</code>. T.unsafe is one of a handful of
<a href="/docs/troubleshooting#escape-hatches">escape hatches</a> built into Sorbet.</p>
<h2><a class="anchor" aria-hidden="true" id="7007"></a><a href="#7007" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7007</h2>
<p>Sorbet can statically assert that the value passed into a <code>T.let</code> does not match
the expected type:</p>
<pre><code class="hljs css language-rb">x = T.let(<span class="hljs-number">1</span>, String) <span class="hljs-comment"># error: Argument does not have asserted type `String`</span>
</code></pre>
<p>Because of the way default values are desugared by Sorbet, this error also
occurs when Sorbet finds a mistmatch between the type specified for a parameter
in the signature and the default value provided in the method.</p>
<p>In this case, the signature states that <code>category</code> type is a <code>Category</code>, yet we
try to use <code>nil</code> as default value:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String, <span class="hljs-symbol">category:</span> Category).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">publish_item</span><span class="hljs-params">(name, category = <span class="hljs-literal">nil</span>)</span></span> <span class="hljs-comment"># error: Argument does not have asserted type `Category`</span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>If <code>category</code> value is <code>nil</code> by default, maybe we should make it so its type is
nilable:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String, <span class="hljs-symbol">category:</span> T.nilable(Category)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">publish_item</span><span class="hljs-params">(name, category = <span class="hljs-literal">nil</span>)</span></span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7009"></a><a href="#7009" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7009</h2>
<p>This error occurs when a value is used in place of a type. There are many
different situations where this can happen; one example is given below:</p>
<pre><code class="hljs">class Box
  extend T::Generic

  E = type_member
end

Box[<span class="hljs-literal">true</span>].new # error: Unsupported usage of bare<span class="hljs-built_in"> type
</span></code></pre>
<p>To fix this error, replace the <code>true</code> value with the type <code>TrueClass</code>:</p>
<pre><code class="hljs css language-rb">Box[TrueClass].new
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7013"></a><a href="#7013" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7013</h2>
<p>Sorbet detected that an instance variable was reassigned with different types:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>
    @x = T.let(<span class="hljs-number">0</span>, Integer)
  <span class="hljs-keyword">end</span>

  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    @x = <span class="hljs-string">'not an integer'</span> <span class="hljs-comment"># error: Expected `Integer` but found `String("not an integer")` for field</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>If the instance variable can hold both an <code>Integer</code> and a <code>String</code>, maybe the
type specified with <code>T.let</code> should be enlarged:</p>
<pre><code class="hljs css language-ruby">@x = T.let(<span class="hljs-number">0</span>, Object)
</code></pre>
<p>Similarly, Sorbet will reject constants reassigned with different types:</p>
<pre><code class="hljs css language-rb">FOO = <span class="hljs-number">42</span> <span class="hljs-comment"># error: Expected `String("Hello, world!")` but found `Integer(42)` for field</span>
FOO = <span class="hljs-string">"Hello, world!"</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7010"></a><a href="#7010" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7010</h2>
<p>Sorbet found a reference to a generic type with the wrong number of type
arguments.</p>
<p>Here we defined <code>MyMap</code> as a generic class expecting two type parameters
<code>KeyType</code> and <code>ValueType</code> but we try to instantiate it with only one type
argument:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMap</span></span>
  extend T::Generic

  KeyType = type_member
  ValueType = type_member

  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>

MyMap[String].new <span class="hljs-comment"># error: Wrong number of type parameters for `MyMap`. Expected: `2`, got: `1`</span>
</code></pre>
<p>Unless a type member was <code>fixed</code>, it is always required to pass the correct
amount of type arguments. <code>T.untyped</code> can also be used if the type is not
relevant at this point:</p>
<pre><code class="hljs css language-rb">MyMap[String, Integer].new
MyMap[String, String].new
MyMap[String, T.untyped].new
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7014"></a><a href="#7014" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7014</h2>
<p>Sorbet has a special method called <code>T.reveal_type</code> which can be useful for
debugging. <code>T.reveal_type(expr)</code> will report an error in the output of <code>srb tc</code>
that shows what the static component of Sorbet thinks the result type of <code>expr</code>
is.</p>
<p>Making this an error is nice for two reasons:</p>
<ul>
<li><p>It makes our internal implementation easier 😅 We don’t have some special-case
messages and then error messages. The only thing Sorbet prints under normal
circumstances are error messages.</p></li>
<li><p>It serves as a reminder to remove <code>T.reveal_type</code> before committing a change.
Since it’s a proper error, Sorbet will exit with non-zero status until it’s
removed.</p></li>
</ul>
<p>For more information, see <a href="/docs/troubleshooting">Troubleshooting</a>.</p>
<blockquote>
<p>Looking for how to assert that an expression has a certain type? Check out
<a href="/docs/type-assertions">Type Assertions</a>.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="7017"></a><a href="#7017" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7017</h2>
<p>In typed: strict files, Sorbet requires that all methods are annotated with a
<code>sig</code>. In a <code># typed: true</code> file Sorbet implicitly assumes that definitions
without types are <code>T.untyped</code>, but in a <code># typed: strict</code> file, Sorbet will no
longer make this implicit assumption.</p>
<p>You can still add a <code>sig</code> which declares the arguments or return as <code>T.untyped</code>,
so <code># typed: strict</code> does not outright ban <code>T.untyped</code>. The upside is that usage
of <code>T.untyped</code> is more explicit, which makes it easier to drive the number of
occurrences down. If you’re seeing this warning, there’s no time like the
present to add proper types to your public-facing API (i.e., your top-level
constant and method definitions)!</p>
<p>For how to fix, see <a href="/docs/sigs">Method Signatures</a>.</p>
<p>See also: <a href="#5028">5028</a>, <a href="#6002">6002</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="7018"></a><a href="#7018" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7018</h2>
<p>At <code>typed: strong</code>, Sorbet no longer allows <code>T.untyped</code> as the intermediate
result of any method call. This effectively means that Sorbet knew the type
statically for 100% of calls within a file. This sigil is rarely used—usually
the only files that are <code># typed: strong</code> are RBI files and files with empty
class definitions. Most Ruby files that actually do interesting things will have
errors in <code># typed: strong</code>. Support for <code>typed: strong</code> files is minimal, as
Sorbet changes regularly and new features often bring new <code>T.untyped</code>
intermediate values.</p>
<h2><a class="anchor" aria-hidden="true" id="7019"></a><a href="#7019" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7019</h2>
<p>Sorbet does not have great support for splats right now.</p>
<p>In general, when considering taking a variable number of arguments, consider
instead taking a single argument that’s an array instead of a “rest” arg:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ----- AVOID THIS ----------------------------</span>
sig {params(<span class="hljs-symbol">xs:</span> Integer).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*xs)</span></span>; <span class="hljs-keyword">end</span>

xs = Array.new(<span class="hljs-number">3</span>) {<span class="hljs-params">|i|</span> i}
foo(*xs)
<span class="hljs-comment"># ---------------------------------------------</span>

<span class="hljs-comment"># ----- Do this instead -----------------------</span>

sig {params(<span class="hljs-symbol">ys:</span> T::Array[Integer]).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">(ys)</span></span>; <span class="hljs-keyword">end</span>

ys = Array.new(<span class="hljs-number">3</span>) {<span class="hljs-params">|i|</span> i}
bar(ys)
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<p>If it is not possible to refactor the code, the current work around is to use
<code>T.unsafe</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ----- WORST CASE ----------------------------</span>
<span class="hljs-comment"># Prefer the solution described above</span>

sig {params(<span class="hljs-symbol">xs:</span> Integer).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*xs)</span></span>; <span class="hljs-keyword">end</span>

xs = Array.new(<span class="hljs-number">3</span>) {<span class="hljs-params">|i|</span> i}
T.unsafe(<span class="hljs-keyword">self</span>).foo(xs)
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7021"></a><a href="#7021" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7021</h2>
<p>The method called declares a block parameter that is not <code>T.nilable</code>, but a
block was not passed when it was called.</p>
<p>This can be fixed by either passing a block to the method, or changing the
method’s signature for the block parameter from <code>T.proc...</code> to
<code>T.nilable(T.proc...)</code> (and then changing the method to deal with a nilable
block parameter).</p>
<h2><a class="anchor" aria-hidden="true" id="7023"></a><a href="#7023" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7023</h2>
<p>This error occurs when a method is passed in a <code>Proc</code> object that Sorbet does
not know the arity for statically.</p>
<p>One instance where this can happen is when using <code>method</code>, since the arity of
method corresponding to the symbol is unknown. This can be fixed by passing in a
block with the correct arity:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: strict</span>

extend T::Sig

sig {params(<span class="hljs-symbol">blk:</span> T.proc.params(<span class="hljs-symbol">arg0:</span> String).void).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># ----- AVOID THIS ----------------------------</span>
foo(&amp;method(<span class="hljs-symbol">:puts</span>))
<span class="hljs-comment"># ---------------------------------------------</span>

<span class="hljs-comment"># ----- Do this instead -----------------------</span>
foo <span class="hljs-keyword">do</span> <span class="hljs-params">|arg0|</span>
    method(<span class="hljs-symbol">:puts</span>).call(arg<span class="hljs-number">0</span>)
<span class="hljs-keyword">end</span>
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7024"></a><a href="#7024" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7024</h2>
<p>This error occurs when a generic argument is passed in as a block parameter.</p>
<p>In <code># typed: strict</code> files, using a parameter from a method that does not have a
signature will cause this issue to be reported. Adding a signature to the method
will fix the issue.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: strict</span>

extend T::Sig

<span class="hljs-comment"># ----- This will error -----------------------</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
    proc(&amp;blk)
<span class="hljs-keyword">end</span>
<span class="hljs-comment"># ---------------------------------------------</span>

<span class="hljs-comment"># ----- This will not error -------------------</span>
sig {params(<span class="hljs-symbol">blk:</span> T.untyped).returns(T.untyped)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">(&amp;blk)</span></span>
    proc(&amp;blk)
<span class="hljs-keyword">end</span>
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7026"></a><a href="#7026" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7026</h2>
<p>Sorbet detected that it was possible for <code>T.absurd</code> to be reached. This usually
means that something that was meant to cover all possible cases of a union type
did not cover all the cases.</p>
<p>See <a href="/docs/exhaustiveness">Exhaustiveness Checking</a> for more information.</p>
<h2><a class="anchor" aria-hidden="true" id="7030"></a><a href="#7030" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7030</h2>
<p>This error is consistently used when the user is trying (implicitly or
explicitly) to call some method on a Sorbet type (e.g. <code>T::Array[Integer]</code>)
which would actually return a Sorbet-runtime representation of a type.</p>
<p>This error generally occurs when generic types are used in pattern matching:</p>
<pre><code class="hljs css language-rb"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_value</span><span class="hljs-params">(input)</span></span>
  <span class="hljs-keyword">case</span> input
  <span class="hljs-keyword">when</span> Integer
    input
  <span class="hljs-keyword">when</span> T::Array[Integer] <span class="hljs-comment"># error: Call to method `===` on `T::Array[Integer]` mistakes a type for a value</span>
    input.first
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Since generic types are erased at runtime, this construct would never work when
the program executed. Replace the generic type <code>T::Array[Integer]</code> by the erased
type <code>Array</code> so the runtime behavior is correct:</p>
<pre><code class="hljs">def get_value(<span class="hljs-keyword">input</span>)
  <span class="hljs-keyword">case</span> <span class="hljs-keyword">input</span>
  <span class="hljs-keyword">when</span> <span class="hljs-type">Integer</span>
    <span class="hljs-keyword">input</span>
  <span class="hljs-keyword">when</span> <span class="hljs-keyword">Array</span>
    <span class="hljs-keyword">input</span>.first
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7034"></a><a href="#7034" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7034</h2>
<p>Sorbet detected that the safe navigation operator (<code>&amp;.</code>) was being used on a
receiver that can never be nil. Replace the offending occurrence of <code>&amp;.</code> with a
normal method call (<code>.</code>).</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

extend T::Sig

sig {params(<span class="hljs-symbol">x:</span> Integer, <span class="hljs-symbol">y:</span> T.nilable(Integer)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x, y)</span></span>
  puts x&amp;.to_s  <span class="hljs-comment"># error: x can never be nil</span>
  puts x.to_s   <span class="hljs-comment"># no error</span>

  puts y&amp;.to_s  <span class="hljs-comment"># no error: y may be nil</span>
<span class="hljs-keyword">end</span>
</code></pre>
<script src="/js/error-reference.js"></script>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/faq"><span class="arrow-prev">← </span><span>FAQ</span></a><a class="docs-next button" href="/docs/sigs"><span>Signatures</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#1001">1001</a></li><li><a href="#1004">1004</a></li><li><a href="#2001">2001</a></li><li><a href="#3001">3001</a></li><li><a href="#3002">3002</a></li><li><a href="#3011">3011</a></li><li><a href="#4002">4002</a></li><li><a href="#4010">4010</a></li><li><a href="#4011">4011</a></li><li><a href="#4012">4012</a></li><li><a href="#4015">4015</a></li><li><a href="#5001">5001</a></li><li><a href="#5002">5002</a></li><li><a href="#5005">5005</a></li><li><a href="#5006">5006</a></li><li><a href="#5008">5008</a></li><li><a href="#5011">5011</a></li><li><a href="#5012">5012</a></li><li><a href="#5013">5013</a></li><li><a href="#5014">5014</a></li><li><a href="#5023">5023</a></li><li><a href="#5028">5028</a></li><li><a href="#5034">5034</a></li><li><a href="#5035">5035</a></li><li><a href="#5036">5036</a></li><li><a href="#5037">5037</a></li><li><a href="#5041">5041</a></li><li><a href="#5046">5046</a></li><li><a href="#5047">5047</a></li><li><a href="#5048">5048</a></li><li><a href="#5054">5054</a></li><li><a href="#5056">5056</a></li><li><a href="#5057">5057</a></li><li><a href="#5058">5058</a></li><li><a href="#5064">5064</a></li><li><a href="#5068">5068</a></li><li><a href="#6002">6002</a></li><li><a href="#7001">7001</a></li><li><a href="#7002">7002</a></li><li><a href="#7003">7003</a></li><li><a href="#7004">7004</a></li><li><a href="#7005">7005</a></li><li><a href="#7006">7006</a></li><li><a href="#7007">7007</a></li><li><a href="#7009">7009</a></li><li><a href="#7013">7013</a></li><li><a href="#7010">7010</a></li><li><a href="#7014">7014</a></li><li><a href="#7017">7017</a></li><li><a href="#7018">7018</a></li><li><a href="#7019">7019</a></li><li><a href="#7021">7021</a></li><li><a href="#7023">7023</a></li><li><a href="#7024">7024</a></li><li><a href="#7026">7026</a></li><li><a href="#7030">7030</a></li><li><a href="#7034">7034</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer">© 2022 Stripe · <a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>