<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blocks, Procs and Lambda Types · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="```ruby"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blocks, Procs and Lambda Types · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="```ruby"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-5H7PQ9Z8KF"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments); }
              gtag('js', new Date());
              gtag('config', 'G-5H7PQ9Z8KF');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ↔ Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">CLI Quickstart</a></li><li class="navListItem"><a class="navItem" href="/docs/cli-ref">CLI Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/why-type-annotations">Why type annotations?</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/unsupported">Unsupported Ruby Features</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">sig</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations (non-sig)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">T.let, T.cast, T.must, T.bind</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types (Integer, String)</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types (T.nilable)</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types (T.any)</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow-Sensitivity (is_a?, nil?)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">T.type_alias</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness (T.absurd)</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/anything">T.anything</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types (T.all)</a></li><li class="navListItem"><a class="navItem" href="/docs/generics">Generics</a></li><li class="navListItem"><a class="navItem" href="/docs/strong">Banning untyped</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Ruby &amp; DSL Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/attr_reader">attr_reader</a></li><li class="navListItem"><a class="navItem" href="/docs/minitest">minitest</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Editor Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/lsp">Language Server (LSP)</a></li><li class="navListItem"><a class="navItem" href="/docs/server-status">Server Status</a></li><li class="navListItem"><a class="navItem" href="/docs/lsp-typed-level">LSP &amp; Typed Level</a></li><li class="navListItem"><a class="navItem" href="/docs/go-to-def">Go to Definition</a></li><li class="navListItem"><a class="navItem" href="/docs/hover">Hover</a></li><li class="navListItem"><a class="navItem" href="/docs/autocompletion">Autocompletion</a></li><li class="navListItem"><a class="navItem" href="/docs/references">Find All References</a></li><li class="navListItem"><a class="navItem" href="/docs/code-actions">Code Actions</a></li><li class="navListItem"><a class="navItem" href="/docs/outline">Outline &amp; Document Symbols</a></li><li class="navListItem"><a class="navItem" href="/docs/doc-comments">Documentation Comments</a></li><li class="navListItem"><a class="navItem" href="/docs/sig-suggestion">Suggesting sigs</a></li><li class="navListItem"><a class="navItem" href="/docs/highlight-untyped">Highlighting untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/sorbet-uris">sorbet: URIs</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/overloads">Overloads</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li><li class="navListItem"><a class="navItem" href="/docs/rbs-support">RBS Comments</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/procs.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Blocks, Procs and Lambda Types</h1></header><article><div><span><pre><code class="hljs css language-ruby">T.proc.params(<span class="hljs-symbol">arg0:</span> Arg0Type, <span class="hljs-symbol">arg1:</span> Arg1Type, ...).returns(ReturnType)
</code></pre>
<p>This is the type of a <code>Proc</code> (such as a block passed to a method as a <code>&amp;blk</code> parameter) that accepts arguments of types <code>Arg0Type</code>, <code>Arg1Type</code>, etc., and returns <code>ReturnType</code>.</p>
<p>At present, all parameters are assumed to be required positional parameters—<code>T.proc</code> types cannot declare optional nor keyword parameters.</p>
<p>Types of procs are not checked at all at runtime (whereas methods are), and serve only as hints to Sorbet statically (and for documentation).</p>
<p>Here’s a larger example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

<span class="hljs-comment"># (1) Declare the type of a block arg with `T.proc`:</span>
sig { params(<span class="hljs-symbol">blk:</span> T.proc.params(<span class="hljs-symbol">arg0:</span> Integer).void).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
  x = T.let(<span class="hljs-string">'not an int'</span>, T.untyped)

  <span class="hljs-comment"># (2) The `T.proc` annotation is not checked at runtime.</span>
  <span class="hljs-comment">#     (This won't raise even though x is not an Integer)</span>
  <span class="hljs-keyword">yield</span> x
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># (3) Sorbet incorporates the `T.proc` annotation into what it knows statically</span>
foo <span class="hljs-keyword">do</span> <span class="hljs-params">|x|</span>
  T.reveal_type(x) <span class="hljs-comment"># Revealed type: Integer</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="optional-blocks"></a><a href="#optional-blocks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional blocks</h2>
<p>Use <code>T.nilable</code> to declare that a method can take an optional block:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

extend T::Sig

<span class="hljs-comment"># (1) Declare optional block with `T.nilable(...)`:</span>
sig { params(<span class="hljs-symbol">blk:</span> T.nilable(T.proc.void)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
  T.reveal_type(blk)   <span class="hljs-comment"># Revealed type: `T.nilable(T.proc.void)`</span>

  <span class="hljs-comment"># (2) Use `block_given?` to check whether a method was given a block:</span>
  <span class="hljs-keyword">if</span> block_given?
    T.reveal_type(blk) <span class="hljs-comment"># Revealed type: `T.proc.void`</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment"># (3) Equivalently:</span>
  <span class="hljs-keyword">if</span> blk
    T.reveal_type(blk) <span class="hljs-comment"># Revealed type: `T.proc.void`</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Because we used <code>block_given?</code> above, Sorbet will know that outside the <code>if</code> expression <code>blk</code> might be <code>nil</code>, while inside the <code>if</code> it’s not <code>nil</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="annotating-methods-that-use-yield"></a><a href="#annotating-methods-that-use-yield" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotating methods that use <code>yield</code></h2>
<p>Ruby’s <code>yield</code> keyword yields control to the provided block even when a method declaration doesn’t mention a block parameter:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
  <span class="hljs-keyword">yield</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This is valid Ruby, and Sorbet will accept this code too. Implicitly, Sorbet will know that the method might accept a block, but it will treat the block itself as <code>T.untyped</code>. In order to give a signature to this method, the block parameter will need a name:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span> <span class="hljs-comment"># &lt;-</span>
  <span class="hljs-keyword">yield</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>And once it has a name, the method can be given a sig:</p>
<pre><code class="hljs css language-ruby">sig { params(<span class="hljs-symbol">blk:</span> T.proc.returns(Integer)).returns(Integer) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span> <span class="hljs-comment"># &lt;-</span>
  <span class="hljs-keyword">yield</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Note that the <code>yield</code> itself in the method body doesn’t need to change at all. Since every Ruby method can only accept one block, both Ruby and Sorbet are able to connect the <code>yield</code> call to the <code>blk</code> parameter automatically.</p>
<h2><a class="anchor" aria-hidden="true" id="methods-that-do-not-take-blocks"></a><a href="#methods-that-do-not-take-blocks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Methods that do not take blocks</h2>
<p>It’s hard for Sorbet to know whether a method takes a block or not. Technically, Ruby allows passing a block at runtime to <strong>all methods</strong>, regardless of whether that method declares an explicit <code>&amp;blk</code> parameter or uses the <code>yield</code> keyword.</p>
<p>This means that Sorbet can only catch “Method does not take a block” errors when the method definition:</p>
<ul>
<li>has a signature</li>
<li>does not mention a <code>&amp;blk</code> parameter</li>
<li>is defined in a <code># typed: strict</code> file</li>
</ul>
<p>Absent all three conditions, Sorbet allows passing a block to a method that might not actually accept a block.</p>
<h3><a class="anchor" aria-hidden="true" id="why--typed-strict-files"></a><a href="#why--typed-strict-files" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why <code># typed: strict</code> files?</h3>
<p>To ease the adoption in pre-existing Ruby codebases, Sorbet allows methods to use <code>yield</code> but not declare a <code>&amp;blk</code> parameter in <code># typed: true</code> files. We may reconsider this decision in the future, but for now, Sorbet can only be sure that a method does not take a block if the method is defined in a <code># typed: strict</code> file.</p>
<p>Note that this applies to RBI files too: if a method is defined with a signature, that does not mention a <code>&amp;blk</code> parameter, in a <code># typed: strict</code> RBI file, Sorbet will error for attempts to pass a block to the method.</p>
<p>For RBI authors, it’s important to ensure that <code># typed: strict</code> RBIs correctly declare whether a method takes a block or not, or else use <code># typed: true</code> for that RBI file to opt the methods defined in that RBI out of “Method does not take a block” errors.</p>
<h2><a class="anchor" aria-hidden="true" id="prefer-blocks-to-procs-or-lambdas"></a><a href="#prefer-blocks-to-procs-or-lambdas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Prefer blocks to procs or lambdas</h2>
<p>Sorbet’s type inference gives substantial preference to Ruby blocks (<code>f { ... }</code>) over procs and lambdas (<code>f(proc { ... })</code>/ <code>f(-&gt; { ... })</code>). Code making heavy use of procs and lambdas will make it hard to avoid depending on <code>T.untyped</code> accidentally.</p>
<p>Here are some examples:</p>
<pre><code class="hljs css language-ruby">sig { params(<span class="hljs-symbol">blk:</span> T.proc.params(<span class="hljs-symbol">x:</span> Integer).void).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takes_block</span><span class="hljs-params">(&amp;blk)</span></span>; <span class="hljs-keyword">end</span>

sig { params(<span class="hljs-symbol">f:</span> T.proc.params(<span class="hljs-symbol">x:</span> Integer).void).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takes_lambda</span><span class="hljs-params">(f)</span></span>; <span class="hljs-keyword">end</span>

takes_block <span class="hljs-keyword">do</span> <span class="hljs-params">|x|</span>
  T.reveal_type(x) <span class="hljs-comment"># =&gt; Integer ✅</span>
<span class="hljs-keyword">end</span>

takes_lambda(-&gt; (x) <span class="hljs-keyword">do</span>
  T.reveal_type(x) <span class="hljs-comment"># =&gt; T.untyped ‼️</span>
<span class="hljs-keyword">end</span>)

f = -&gt; (x) { x }
T.reveal_type(f) <span class="hljs-comment"># =&gt; T.proc.params(arg0: T.untyped).returns(T.untyped) ‼️</span>
takes_lambda(f)
</code></pre>
<p>For lambdas and procs, sorbet only does return-type inference (not argument type inference).</p>
<p>For blocks, Sorbet doesn’t have to do type inference: it simply reads the type of the block from the associated method.</p>
<p>By contrast, Sorbet computes a type for all non-block arguments (including procs and lambdas) <strong>before</strong> type checking a call to a method. That means that even when written like this:</p>
<pre><code class="hljs css language-ruby">takes_lambda(-&gt; (x) { x })
</code></pre>
<p>Sorbet computes a type for the first positional argument <code>f</code> as if the user had written this:</p>
<pre><code class="hljs css language-ruby">f = -&gt; (x) { x }
takes_lambda(f)
</code></pre>
<p>It attempts to compute a type for <code>f</code> without “looking ahead” at the type of <code>takes_lambda</code>. There’s more on this implementation decision in <a href="https://sorbet.org/docs/why-type-annotations#-for-local-variables">Why does Sorbet sometimes need type annotations for local variables?</a>, but it comes down to a combination of performance and simplicity.</p>
<h3><a class="anchor" aria-hidden="true" id="what-can-i-do-for-better-proc-and-lambda-types"></a><a href="#what-can-i-do-for-better-proc-and-lambda-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What can I do for better proc and lambda types?</h3>
<ul>
<li><p>Use blocks instead, if possible.</p></li>
<li><p>Make a typed wrapper that takes a block and returns a proc or lambda:</p>
<pre><code class="hljs css language-ruby">MyProcType = T.type_alias { T.proc.params(<span class="hljs-symbol">x:</span> Integer).returns(Integer) }

sig { params(<span class="hljs-symbol">blk:</span> MyProcType).returns(MyProcType) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_typed_proc</span><span class="hljs-params">(&amp;blk)</span></span>
  blk
<span class="hljs-keyword">end</span>

f = make_typed_proc { <span class="hljs-params">|x|</span> x }
</code></pre>
<p>This is good because the body of the proc will benefit from well-typed arguments, and the proc type only has to be written once—there is little runtime overhead for this pattern.</p></li>
<li><p>Use a <code>T.let</code> annotation.</p>
<pre><code class="hljs css language-ruby">f = T.let(
  -&gt; (x) { x },
  T.proc.params(<span class="hljs-symbol">x:</span> Integer).returns(Integer)
)
</code></pre>
<p>Using <code>T.let</code> with <code>-&gt;</code> instructs Sorbet to assume that the <code>T.proc</code> annotation holds when typechecking the body of the lambda. Specifically, Sorbet assumes that the lambda arguments have the types specified in the <code>T.let</code> annotation and checks the lambda body to ensure it returns the specified return type.</p>
<p>This only works with Ruby’s <code>-&gt;</code> lambda syntax, with <code>Kernel.lambda</code>, and with <code>Kernel.proc</code> (it doesn’t work when calling the <code>lambda</code> and <code>proc</code> methods on Kernel implicitly, without a receiver).</p>
<pre><code class="hljs css language-ruby">f = T.let(-&gt; () { <span class="hljs-number">0</span> },         T.proc.returns(Integer)) ✅
f = T.let(Kernel.lambda { <span class="hljs-number">0</span> }, T.proc.returns(Integer)) ✅
f = T.let(Kernel.proc { <span class="hljs-number">0</span> },   T.proc.returns(Integer)) ✅

f = T.let(lambda { <span class="hljs-number">0</span> },        T.proc.returns(Integer)) ❌
f = T.let(proc { <span class="hljs-number">0</span> },          T.proc.returns(Integer)) ❌
</code></pre></li>
<li><p>For lambdas, use <code>-&gt; () { ... }</code> or <code>Kernel.lambda { ... }</code> syntax instead of <code>lambda { ... }</code> syntax.</p>
<p>This will ensure that Sorbet treats <code>return</code> inside the lambda as returning from the lambda, not from the enclosing method (which is one main difference that sets lambdas apart from procs/blocks in Ruby).</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="annotating-the-self-type-with-tprocbind"></a><a href="#annotating-the-self-type-with-tprocbind" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotating the self type with <code>T.proc.bind</code></h2>
<p>Many Ruby constructs accept a block argument in one context, but then execute it in a different context entirely. This means that the methods that exist inside the block are not the methods that exist outside the block (like is usually the case).</p>
<p>As an example, this is how Sorbet’s <code>sig</code> pattern works:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># (1) `params` doesn't exist outside the `sig` block:</span>
params(<span class="hljs-symbol">x:</span> Integer).void <span class="hljs-comment"># error: Method `params` does not exist</span>

<span class="hljs-comment"># (2) But `params` does exist inside the `sig` block:</span>
sig <span class="hljs-keyword">do</span>
  params(<span class="hljs-symbol">x:</span> Integer).void <span class="hljs-comment"># ok!</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This also happens a lot with certain Rails APIs, etc. Sorbet has direct support for this sort of pattern using an extra argument on <code>T.proc</code> called <code>.bind</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># (0) We're simplifying how `sig` specifically works a bit here,</span>
<span class="hljs-comment">#     but the general ideas apply.</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">T::Sig</span></span>
  <span class="hljs-comment"># (1) Use `T.proc.bind` to annotate the context in which the block will run</span>
  sig { params(<span class="hljs-symbol">blk:</span> T.proc.bind(T::Private::Methods::DeclBuilder).void).void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sig</span><span class="hljs-params">(&amp;blk)</span></span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># This comes from a private, internal sorbet-runtime API that implements sigs:</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">T::Private::Method::DeclBuilder</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">params</span><span class="hljs-params">(params)</span></span>; <span class="hljs-keyword">end</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">returns</span><span class="hljs-params">(type)</span></span>; <span class="hljs-keyword">end</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">void</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Here’s another example that’s a little more contrived but which shows both the method call site and method definition site:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

<span class="hljs-comment"># (1) Use `.bind(String)` to say "will be run in the context of a String":</span>
sig { params(<span class="hljs-symbol">blk:</span> T.proc.bind(String).returns(String)).returns(String) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
  <span class="hljs-string">"hello"</span>.instance_eval(&amp;blk)
<span class="hljs-keyword">end</span>

upcased = foo <span class="hljs-keyword">do</span>
  <span class="hljs-comment"># (2) Sorbet knows that `self.upcase` is available because of the `.bind`</span>
  <span class="hljs-keyword">self</span>.upcase
<span class="hljs-keyword">end</span>

puts(upcased) <span class="hljs-comment"># =&gt; "HELLO"</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="casting-the-self-type-with-tbind"></a><a href="#casting-the-self-type-with-tbind" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Casting the self type with <code>T.bind</code></h2>
<p>As mentioned above, by default, Sorbet assumes that a block executes in a context where <code>self</code> has the same type as the lexically surrounding scope.</p>
<p>The <code>T.proc.bind</code> annotation (from the previous section) can change this assumption, but is only valid for use on the distinguished <code>&amp;blk</code> parameter of a method:</p>
<ul>
<li>It cannot be used with non-<code>&amp;blk</code> parameters at a call site.</li>
<li>It cannot be used with procs or lambdas that are assigned into a variable, disconnected from any single call site.</li>
</ul>
<p>(This is due to some simplifying architectural choices in the implementation of Sorbet’s type checking algorithm.)</p>
<p>We still might want to ascribe a type to <code>self</code> for non-<code>&amp;blk</code> usages. For example, look at the block passed to <code>before_create</code> below:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span></span>
  before_create <span class="hljs-symbol">:set_pending</span>, <span class="hljs-symbol">if:</span> -&gt; {
    draft? <span class="hljs-comment"># error: Method `draft?` does not exist on `T.class_of(Post)`</span>
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draft?</span></span>
    <span class="hljs-literal">true</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>By default, Sorbet assumes that when <code>draft?</code> runs, <code>self</code> will have type <code>T.class_of(Post)</code>. In reality, <code>before_create</code> will execute the lambda provided to the <code>if</code> argument in a context where the block’s <code>self</code> has type <code>Post</code>.</p>
<p>To type this code accurately, Sorbet requires a <a href="/docs/type-assertions#tbind"><code>T.bind</code> annotation</a> in the lambda:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span></span>
  before_create <span class="hljs-symbol">:set_pending</span>, <span class="hljs-symbol">if:</span> -&gt; {
    T.bind(<span class="hljs-keyword">self</span>, Post)
    draft? <span class="hljs-comment"># OK!</span>
  }

  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0Aclass%20Base%0A%20%20def%20self.before_create(name%2C%20**options)%0A%20%20end%0Aend%0A%0Aclass%20Post%20%3C%20Base%0A%20%20before_create%20%3Aset_pending%2C%20if%3A%20-%3E%20%7B%20T.bind(self%2C%20Post).draft%3F%20%7D%0A%0A%20%20def%20draft%3F%0A%20%20%20%20true%0A%20%20end%0Aend%0A%0Aclass%20Article%20%3C%20Base%0A%20%20before_create%20%3Aset_pending%2C%20if%3A%20-%3E%20%7B%20draft%3F%20%7D%0A%0A%20%20def%20draft%3F%0A%20%20%20%20true%0A%20%20end%0Aend">
→ View on sorbet.run
</a></p>
<p>Like with <code>T.cast</code>, the full range of Sorbet types can be used in the <code>T.bind</code> annotation. For example, here is a more complicated example that uses <code>T.any</code> with <code>T.bind</code>:</p>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0Amodule%20Callbacks%0A%20%20def%20included%28%26block%29%0A%20%20end%0Aend%0A%0Amodule%20Taggable%0A%20%20extend%20Callbacks%0A%0A%20%20included%20do%0A%20%20%20%20T.bind%28self%2C%20T.any%28Post%2C%20Article%29%29%0A%0A%20%20%20%20create_tag!%0A%20%20end%0Aend%0A%0Aclass%20Post%0A%20%20include%20Taggable%0A%0A%20%20def%20create_tag!%0A%20%20end%0Aend%0A%0Aclass%20Article%0A%20%20include%20Taggable%0Aend">
→ View on sorbet.run
</a></p>
<p>For more information on <code>T.bind</code>, see <a href="/docs/type-assertions#tbind">Type Assertions</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="procnew-vs-proc"></a><a href="#procnew-vs-proc" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Proc.new vs proc</h2>
<p>In Ruby there’s several ways to create a Proc: <code>proc</code> and <code>Proc.new</code>. Sorbet handles them differently because of how parameter arity works internally. Basically, you can use <code>T.proc</code> as the type for a <code>proc</code> (or <code>lambda {}</code> or <code>-&gt; {}</code>), but if you create your Proc using <code>Proc.new</code>, then the type is a <code>Proc</code>.</p>
<p>The main downside of the <code>Proc.new</code> approach is that you can’t set argument types on it.</p>
<p>Here’s an example:</p>
<pre><code class="hljs css language-ruby">sig { returns(T.proc.params(<span class="hljs-symbol">a1:</span> Integer).returns(Integer)) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowercase_proc</span></span>
  <span class="hljs-comment"># if you are using `proc`, use `T.proc` in your sig</span>
  <span class="hljs-comment"># this is the preferred approach</span>
  proc {<span class="hljs-params">|n|</span> n * <span class="hljs-number">2</span> }
<span class="hljs-keyword">end</span>

sig { returns(Proc) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proc_dot_new</span></span>
  <span class="hljs-comment"># if you are using `Proc.new`, use `Proc` in your sig</span>
  <span class="hljs-comment"># note that you won't be able to define arguments/return types in your sig</span>
  <span class="hljs-comment"># avoid this approach if possible</span>
  Proc.new {<span class="hljs-params">|n|</span> n * <span class="hljs-number">2</span> }
<span class="hljs-keyword">end</span>
</code></pre>
<p>In general, you’re better off avoiding <code>Proc.new</code> if you can. There’s a <a href="https://docs.rubocop.org/rubocop/cops_style.html#styleproc">rubocop rule</a> you can use to enforce this.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/untyped"><span class="arrow-prev">← </span><span>T.untyped</span></a><a class="docs-next button" href="/docs/abstract"><span>Abstract Classes &amp; Interfaces</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#optional-blocks">Optional blocks</a></li><li><a href="#annotating-methods-that-use-yield">Annotating methods that use <code>yield</code></a></li><li><a href="#methods-that-do-not-take-blocks">Methods that do not take blocks</a><ul class="toc-headings"><li><a href="#why--typed-strict-files">Why <code># typed: strict</code> files?</a></li></ul></li><li><a href="#prefer-blocks-to-procs-or-lambdas">Prefer blocks to procs or lambdas</a><ul class="toc-headings"><li><a href="#what-can-i-do-for-better-proc-and-lambda-types">What can I do for better proc and lambda types?</a></li></ul></li><li><a href="#annotating-the-self-type-with-tprocbind">Annotating the self type with <code>T.proc.bind</code></a></li><li><a href="#casting-the-self-type-with-tbind">Casting the self type with <code>T.bind</code></a></li><li><a href="#procnew-vs-proc">Proc.new vs proc</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer"><svg width="99" height="28" viewBox="0 0 99 28" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M1.98432 20H6.27432C8.44932 20 9.81432 18.905 9.81432 17.03C9.81432 15.665 9.00432 14.72 7.78932 14.39C8.61432 14.105 9.45432 13.415 9.45432 12.035C9.45432 10.235 8.23932 9.23 5.95932 9.23H1.98432V20ZM3.37932 13.85V10.445H5.83932C7.27932 10.445 8.07432 11 8.07432 12.155C8.07432 13.295 7.27932 13.85 5.83932 13.85H3.37932ZM3.37932 15.08H6.21432C7.65432 15.08 8.43432 15.83 8.43432 16.925C8.43432 18.035 7.65432 18.785 6.21432 18.785H3.37932V15.08ZM18.0294 12.155H16.6794V16.88C16.6794 18.185 15.6894 18.92 14.7144 18.92C13.5594 18.92 13.0794 18.17 13.0794 17.06V12.155H11.7294V17.345C11.7294 19.01 12.6744 20.165 14.3544 20.165C15.4644 20.165 16.2294 19.58 16.6794 18.92V20H18.0294V12.155ZM20.5112 10.79H21.9812V9.23H20.5112V10.79ZM21.9212 12.155H20.5712V20H21.9212V12.155ZM25.8247 9.23H24.4747V20H25.8247V9.23ZM28.5882 18.125C28.5882 19.625 29.3532 20.075 30.6882 20.075C31.1382 20.075 31.5282 20.03 31.8732 19.955V18.8C31.5582 18.875 31.3332 18.89 31.0182 18.89C30.3282 18.89 29.9232 18.74 29.9232 17.915V13.31H31.7082V12.155H29.9232V9.86H28.5882V12.155H27.3732V13.31H28.5882V18.125ZM41.0199 20.165C43.1949 20.165 44.4399 18.305 44.4399 16.085C44.4399 13.85 43.1949 12.005 41.0199 12.005C39.9249 12.005 39.0549 12.53 38.5899 13.295V9.23H37.2399V20H38.5899V18.86C39.0549 19.64 39.9249 20.165 41.0199 20.165ZM38.5599 15.815C38.5599 13.985 39.6699 13.19 40.7799 13.19C42.2499 13.19 43.0749 14.39 43.0749 16.085C43.0749 17.765 42.2499 18.98 40.7799 18.98C39.6699 18.98 38.5599 18.17 38.5599 16.37V15.815ZM49.1804 20.855L52.5554 12.155H51.1454L48.9704 18.155L46.7654 12.155H45.3404L48.2504 19.715L47.8754 20.645C47.5604 21.425 47.2454 21.635 46.6604 21.635C46.4354 21.635 46.2704 21.62 46.0154 21.56V22.73C46.2554 22.775 46.4204 22.79 46.7504 22.79C48.1154 22.79 48.7304 22.04 49.1804 20.855Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M98.7993 15.7838C98.7993 12.8786 97.3871 10.5862 94.688 10.5862C91.9774 10.5862 90.3374 12.8786 90.3374 15.7611C90.3374 19.177 92.2735 20.9019 95.0524 20.9019C96.4077 20.9019 97.4327 20.5955 98.2071 20.1643V17.8946C97.4327 18.2804 96.5443 18.5188 95.4168 18.5188C94.3121 18.5188 93.3327 18.1329 93.2074 16.7938H98.7766C98.7766 16.6463 98.7993 16.0561 98.7993 15.7838ZM93.1732 14.7057C93.1732 13.4233 93.9591 12.8899 94.6766 12.8899C95.3713 12.8899 96.1116 13.4233 96.1116 14.7057H93.1732Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M85.9413 10.5862C84.8251 10.5862 84.1076 11.1082 83.709 11.4714L83.561 10.7678H81.0554V24.0001L83.9026 23.3986L83.914 20.187C84.324 20.482 84.9276 20.9019 85.9299 20.9019C87.9685 20.9019 89.8249 19.2678 89.8249 15.6703C89.8135 12.3792 87.9343 10.5862 85.9413 10.5862ZM85.2579 18.4053C84.586 18.4053 84.1874 18.167 83.914 17.8719L83.9026 13.6616C84.1988 13.3325 84.6088 13.1055 85.2579 13.1055C86.2943 13.1055 87.0118 14.2631 87.0118 15.7497C87.0118 17.2704 86.3057 18.4053 85.2579 18.4053Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M77.1377 9.91656L79.9963 9.30374V7L77.1377 7.60147V9.91656Z" fill="white"></path><path d="M79.9963 10.7791H77.1377V20.709H79.9963V10.7791Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M74.074 11.6187L73.8918 10.7789H71.4318V20.7088H74.279V13.9792C74.9509 13.1054 76.0898 13.2642 76.4429 13.3891V10.7789C76.0784 10.6427 74.7459 10.3931 74.074 11.6187Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M68.3796 8.31641L65.6007 8.90653L65.5894 17.9966C65.5894 19.6762 66.8535 20.9132 68.5391 20.9132C69.473 20.9132 70.1563 20.743 70.5321 20.5387V18.235C70.1677 18.3825 68.3682 18.9045 68.3682 17.225V13.1962H70.5321V10.779H68.3682L68.3796 8.31641Z" fill="white"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M60.6807 13.6616C60.6807 13.219 61.0452 13.0488 61.6488 13.0488C62.5143 13.0488 63.6076 13.3098 64.4732 13.7751V11.1082C63.5279 10.7337 62.594 10.5862 61.6488 10.5862C59.3368 10.5862 57.7993 11.7891 57.7993 13.7978C57.7993 16.93 62.1271 16.4306 62.1271 17.7811C62.1271 18.3031 61.6715 18.4734 61.0338 18.4734C60.0885 18.4734 58.8813 18.0875 57.9246 17.5655V20.2664C58.9838 20.7204 60.0543 20.9133 61.0338 20.9133C63.4026 20.9133 65.0313 19.7444 65.0313 17.713C65.0199 14.3312 60.6807 14.9326 60.6807 13.6616Z" fill="white"></path></svg><a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div><div id="csat-extension-config" data-notify="#sorbet-team"></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>