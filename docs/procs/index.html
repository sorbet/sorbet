<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blocks, Procs and Lambda Types · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="```ruby"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blocks, Procs and Lambda Types · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="```ruby"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">Signatures</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">Type Assertions</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow Sensitivity</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">Type Aliases</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types</a></li><li class="navListItem"><a class="navItem" href="/docs/non-forcing-constants">T::NonForcingConstants</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/procs.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Blocks, Procs and Lambda Types</h1></header><article><div><span><pre><code class="hljs css language-ruby">T.proc.params(<span class="hljs-symbol">arg0:</span> Arg0Type, <span class="hljs-symbol">arg1:</span> Arg2Type, ...).returns(ReturnType)
</code></pre>
<p>This is the type of a <code>Proc</code> (such as a block passed to a method as a <code>&amp;blk</code>
parameter) that accepts arguments of types <code>Arg0Type</code>, <code>Arg1Type</code>, etc., and
returns <code>ReturnType</code>.</p>
<p>At present, all parameters are assumed to be required positional parameters. We
may add support for optional or keyword parameters in the future, if there is
demand.</p>
<p>Types of procs are not checked at all at runtime (whereas methods are), and
serve only as hints to <code>srb</code> statically (and for documentation).</p>
<p>Here’s a larger example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

<span class="hljs-comment"># (1) Declare the type of a block arg with `T.proc`:</span>
sig {params(<span class="hljs-symbol">blk:</span> T.proc.params(<span class="hljs-symbol">arg0:</span> Integer).void).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
  x = T.let(<span class="hljs-string">'not an int'</span>, T.untyped)

  <span class="hljs-comment"># (2) The `T.proc` annotation is not checked at runtime.</span>
  <span class="hljs-comment">#     (This won't raise even though x is not an Integer)</span>
  <span class="hljs-keyword">yield</span> x
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># (3) Sorbet incorporates the `T.proc` annotation into what it knows statically</span>
foo <span class="hljs-keyword">do</span> <span class="hljs-params">|x|</span>
  T.reveal_type(x) <span class="hljs-comment"># Revealed type: Integer</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="optional-blocks"></a><a href="#optional-blocks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional blocks</h2>
<p>Use <code>T.nilable</code> to declare that a method can take an optional block:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

extend T::Sig

<span class="hljs-comment"># (1) Declare optional block with `T.nilable(...)`:</span>
sig {params(<span class="hljs-symbol">blk:</span> T.nilable(T.proc.void)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
  T.reveal_type(blk)   <span class="hljs-comment"># Revealed type: `T.nilable(T.proc.void)`</span>

  <span class="hljs-comment"># (2) Use `block_given?` to check whether a method was given a block:</span>
  <span class="hljs-keyword">if</span> block_given?
    T.reveal_type(blk) <span class="hljs-comment"># Revealed type: `T.proc.void`</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment"># (3) Equivalently:</span>
  <span class="hljs-keyword">if</span> blk
    T.reveal_type(blk) <span class="hljs-comment"># Revealed type: `T.proc.void`</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Because we used <code>block_given?</code> above, Sorbet will know that outside the <code>if</code>
expression <code>blk</code> might be <code>nil</code>, while inside the <code>if</code> it’s not <code>nil</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="annotating-methods-that-use-yield"></a><a href="#annotating-methods-that-use-yield" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotating methods that use <code>yield</code></h2>
<p>Ruby’s <code>yield</code> keyword yields control to the provided block even when a method
declaration doesn’t mention a block parameter:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
  <span class="hljs-keyword">yield</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This is valid Ruby, and Sorbet will accept this code too. Implicitly, Sorbet
will know that the method might accept a block, but it will treat the block
itself as <code>T.untyped</code>. In order to give a signature to this method, the block
parameter will need a name:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span> <span class="hljs-comment"># &lt;-</span>
  <span class="hljs-keyword">yield</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>And once it has a name, the method can be given a sig:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">blk:</span> T.proc.returns(Integer)).returns(Integer)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span> <span class="hljs-comment"># &lt;-</span>
  <span class="hljs-keyword">yield</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Note that the <code>yield</code> itself in the method body doesn’t need to change at all.
Since every Ruby method can only accept one block, both Ruby and Sorbet are able
to connect the <code>yield</code> call to the <code>blk</code> parameter automatically.</p>
<h2><a class="anchor" aria-hidden="true" id="annotating-the-self-type-with-tprocbind"></a><a href="#annotating-the-self-type-with-tprocbind" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Annotating the self type with <code>T.proc.bind</code></h2>
<p>Many Ruby constructs accept a block argument in one context, but then execute it
in a different context entirely. This means that the methods that exist inside
the block are not the methods that exist outside the block (like is usually the
case).</p>
<p>As an example, this is how Sorbet’s <code>sig</code> pattern works:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># (1) `params` doesn't exist outside the `sig` block:</span>
params(<span class="hljs-symbol">x:</span> Integer).void <span class="hljs-comment"># error: Method `params` does not exist</span>

<span class="hljs-comment"># (2) But `params` does exist inside the `sig` block:</span>
sig <span class="hljs-keyword">do</span>
  params(<span class="hljs-symbol">x:</span> Integer).void <span class="hljs-comment"># ok!</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This also happens a lot with certain Rails APIs, etc. Sorbet has direct support
for this sort of pattern using an extra argument on <code>T.proc</code> called <code>.bind</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># (0) We're simplifying how `sig` specifically works a bit here,</span>
<span class="hljs-comment">#     but the general ideas apply.</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">T::Sig</span></span>
  <span class="hljs-comment"># (1) Use `T.proc.bind` to annotate the context in which the block will run</span>
  sig {params(<span class="hljs-symbol">blk:</span> T.proc.bind(T::Private::Methods::DeclBuilder).void).void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sig</span><span class="hljs-params">(&amp;blk)</span></span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># This comes from a private, internal sorbet-runtime API that implements sigs:</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">T::Private::Method::DeclBuilder</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">params</span><span class="hljs-params">(params)</span></span>; <span class="hljs-keyword">end</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">returns</span><span class="hljs-params">(type)</span></span>; <span class="hljs-keyword">end</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">void</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Here’s another example that’s a little more contrived but which shows both the
method call site and method definition site:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

<span class="hljs-comment"># (1) Use `.bind(String)` to say "will be run in the context of a String":</span>
sig {params(<span class="hljs-symbol">blk:</span> T.proc.bind(String).returns(String)).returns(String)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
  <span class="hljs-string">"hello"</span>.instance_eval(&amp;blk)
<span class="hljs-keyword">end</span>

upcased = foo <span class="hljs-keyword">do</span>
  <span class="hljs-comment"># (2) Sorbet knows that `self.upcase` is available because of the `.bind`</span>
  <span class="hljs-keyword">self</span>.upcase
<span class="hljs-keyword">end</span>

puts(upcased) <span class="hljs-comment"># =&gt; "HELLO"</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="casting-the-self-type-with-tbind"></a><a href="#casting-the-self-type-with-tbind" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Casting the self type with <code>T.bind</code></h2>
<p>As mentioned above, by default, Sorbet assumes that a block executes in a
context where <code>self</code> has the same type as the lexically surrounding scope.</p>
<p>The <code>T.proc.bind</code> annotation (from the previous section) can change this
assumption, but is only valid for use on the distinguished <code>&amp;blk</code> parameter of a
method:</p>
<ul>
<li>It cannot be used with non-<code>&amp;blk</code> parameters at a call site.</li>
<li>It cannot be used with procs or lambdas that are assigned into a variable,
disconnected from any single call site.</li>
</ul>
<p>(This is due to some simplifying architectural choices in the implementation of
Sorbet’s type checking algorithm.)</p>
<p>We still might want to ascribe a type to <code>self</code> for non-<code>&amp;blk</code> usages. For
example, look at the block passed to <code>before_create</code> below:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span></span>
  before_create <span class="hljs-symbol">:set_pending</span>, <span class="hljs-symbol">if:</span> -&gt; {
    draft? <span class="hljs-comment"># error: Method `draft?` does not exist on `T.class_of(Post)`</span>
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draft?</span></span>
    <span class="hljs-literal">true</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>By default, Sorbet assumes that when <code>draft?</code> runs, <code>self</code> will have type
<code>T.class_of(Post)</code>. In reality, <code>before_create</code> will execute the lambda provided
to the <code>if</code> argument in a context where the block’s <code>self</code> has type <code>Post</code>.</p>
<p>To type this code accurately, Sorbet requires a
<a href="/docs/type-assertions#tbind"><code>T.bind</code> annotation</a> in the lambda:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Post</span></span>
  before_create <span class="hljs-symbol">:set_pending</span>, <span class="hljs-symbol">if:</span> -&gt; {
    T.bind(<span class="hljs-keyword">self</span>, Post)
    draft? <span class="hljs-comment"># OK!</span>
  }

  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0Aclass%20Base%0A%20%20def%20self.before_create(name%2C%20**options)%0A%20%20end%0Aend%0A%0Aclass%20Post%20%3C%20Base%0A%20%20before_create%20%3Aset_pending%2C%20if%3A%20-%3E%20%7B%20T.bind(self%2C%20Post).draft%3F%20%7D%0A%0A%20%20def%20draft%3F%0A%20%20%20%20true%0A%20%20end%0Aend%0A%0Aclass%20Article%20%3C%20Base%0A%20%20before_create%20%3Aset_pending%2C%20if%3A%20-%3E%20%7B%20draft%3F%20%7D%0A%0A%20%20def%20draft%3F%0A%20%20%20%20true%0A%20%20end%0Aend">
→ View on sorbet.run
</a></p>
<p>Like with <code>T.cast</code>, the full range of Sorbet types can be used in the <code>T.bind</code>
annotation. For example, here is a more complicated example that uses <code>T.any</code>
with <code>T.bind</code>:</p>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0Amodule%20Callbacks%0A%20%20def%20included%28%26block%29%0A%20%20end%0Aend%0A%0Amodule%20Taggable%0A%20%20extend%20Callbacks%0A%0A%20%20included%20do%0A%20%20%20%20T.bind%28self%2C%20T.any%28Post%2C%20Article%29%29%0A%0A%20%20%20%20create_tag!%0A%20%20end%0Aend%0A%0Aclass%20Post%0A%20%20include%20Taggable%0A%0A%20%20def%20create_tag!%0A%20%20end%0Aend%0A%0Aclass%20Article%0A%20%20include%20Taggable%0Aend">
→ View on sorbet.run
</a></p>
<p>For more information on <code>T.bind</code>, see
<a href="/docs/type-assertions#tbind">Type Assertions</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="procnew-vs-proc"></a><a href="#procnew-vs-proc" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Proc.new vs proc</h2>
<p>In Ruby there’s several ways to create a Proc: <code>proc</code> and <code>Proc.new</code>. Sorbet
handles them differently because of how parameter arity works internally.
Basically, you can use <code>T.proc</code> as the type for a <code>proc</code> (or <code>lambda {}</code> or
<code>-&gt; {}</code>), but if you create your Proc using <code>Proc.new</code>, then the type is a
<code>Proc</code>.</p>
<p>The main downside of the <code>Proc.new</code> approach is that you can’t set argument
types on it.</p>
<p>Here’s an example:</p>
<pre><code class="hljs css language-ruby">sig {returns(T.proc.params(<span class="hljs-symbol">a1:</span> Integer).returns(Integer))}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lowercase_proc</span></span>
  <span class="hljs-comment"># if you are using `proc`, use `T.proc` in your sig</span>
  <span class="hljs-comment"># this is the preferred approach</span>
  proc {<span class="hljs-params">|n|</span> n * <span class="hljs-number">2</span> }
<span class="hljs-keyword">end</span>

sig {returns(Proc)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">proc_dot_new</span></span>
  <span class="hljs-comment"># if you are using `Proc.new`, use `Proc` in your sig</span>
  <span class="hljs-comment"># note that you won't be able to define arguments/return types in your sig</span>
  <span class="hljs-comment"># avoid this approach if possible</span>
  Proc.new {<span class="hljs-params">|n|</span> n * <span class="hljs-number">2</span> }
<span class="hljs-keyword">end</span>
</code></pre>
<p>In general, you’re better off avoiding <code>Proc.new</code> if you can. There’s a
<a href="https://docs.rubocop.org/rubocop/0.92/cops_style.html#styleproc">rubocop rule</a>
you can use to enforce this.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/untyped"><span class="arrow-prev">← </span><span>T.untyped</span></a><a class="docs-next button" href="/docs/abstract"><span>Abstract Classes &amp; Interfaces</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#optional-blocks">Optional blocks</a></li><li><a href="#annotating-methods-that-use-yield">Annotating methods that use <code>yield</code></a></li><li><a href="#annotating-the-self-type-with-tprocbind">Annotating the self type with <code>T.proc.bind</code></a></li><li><a href="#casting-the-self-type-with-tbind">Casting the self type with <code>T.bind</code></a></li><li><a href="#procnew-vs-proc">Proc.new vs proc</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer">© 2021 Stripe · <a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>