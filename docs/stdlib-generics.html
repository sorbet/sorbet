<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Arrays, Hashes, and Generics in the Standard Library · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="The Sorbet syntax for type annotations representing arrays, hash maps, and other"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Arrays, Hashes, and Generics in the Standard Library · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="The Sorbet syntax for type annotations representing arrays, hash maps, and other"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ↔ Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/why-type-annotations">Why type annotations?</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">sig</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations (non-sig)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">T.let, T.cast, T.must, T.bind</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types (Integer, String)</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types (T.nilable)</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types (T.any)</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow-Sensitivity (is_a?, nil?)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">T.type_alias</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness (T.absurd)</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types (T.all)</a></li><li class="navListItem"><a class="navItem" href="/docs/non-forcing-constants">T::NonForcingConstants</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/generics">Generics</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/stdlib-generics.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Arrays, Hashes, and Generics in the Standard Library</h1></header><article><div><span><p>The Sorbet syntax for type annotations representing arrays, hash maps, and other
containers defined in the Ruby standard library looks different from other
<a href="/docs/class-types">class types</a> despite the fact that Ruby uses classes to
represent these values, too. Here’s the syntax Sorbet uses:</p>
<table>
<thead>
<tr><th>Type</th><th>Example value</th></tr>
</thead>
<tbody>
<tr><td><code>T::Array[Integer]</code></td><td><code>[1, 2, 3]</code></td></tr>
<tr><td><code>T::Array[String]</code></td><td><code>[&quot;hello&quot;, &quot;goodbye&quot;]</code></td></tr>
<tr><td><code>T::Hash[Symbol, Integer]</code></td><td><code>{key: 0}</code></td></tr>
<tr><td><code>T::Hash[String, Float]</code></td><td><code>{&quot;key&quot; =&gt; 0.0}</code></td></tr>
<tr><td><code>T::Set[Integer]</code></td><td><code>Set[1, 2, 3]</code></td></tr>
<tr><td><code>T::Range[Integer]</code></td><td><code>0..10</code></td></tr>
<tr><td><code>T::Enumerable[Integer]</code></td><td><em>interface implemented by many types</em></td></tr>
<tr><td><code>T::Enumerator[Integer]</code></td><td>[1, 2, 3].each</td></tr>
<tr><td><code>T::Enumerator::Lazy[Integer]</code></td><td>[1, 2, 3].each.lazy</td></tr>
</tbody>
</table>
<h2><a class="anchor" aria-hidden="true" id="why-the-t-prefix"></a><a href="#why-the-t-prefix" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why the <code>T::</code> prefix?</h2>
<p>Sorbet uses syntax like <code>MyClass[Elem]</code> for type arguments passed to
<a href="/docs/generics">generic classes</a>. All Sorbet type annotations are backwards
compatible with normal Ruby syntax, and this is no exception. In normal Ruby,
<code>MyClass[Elem]</code> would correspond to a call to a method named <code>[]</code> defined on
<code>MyClass</code>.</p>
<p>When creating user-defined generic classes, the <code>sorbet-runtime</code> gem
automatically defines this method so that the type annotation syntax works at
runtime.</p>
<p>But for classes in the Ruby standard library that Sorbet retroactively defined
as generic classes, the <code>[]</code> method will not always be defined at runtime. One
potential option would have been to use <code>sorbet-runtime</code> to monkey patch the
standard library so that the <code>[]</code> method is defined for generic classes, but
some of these Ruby standard library classes <strong>already</strong> define a meaningful <code>[]</code>
method. For example:</p>
<pre><code class="hljs css language-ruby">Array[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-comment"># =&gt; evaluates to the array `[1, 2, 3]`</span>

Set[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]
<span class="hljs-comment"># =&gt; evaluates to the set containing 1, 2, and 3o</span>

Hash[<span class="hljs-symbol">:key1</span>, <span class="hljs-number">1</span>, <span class="hljs-symbol">:key2</span>, <span class="hljs-number">2</span>]
<span class="hljs-comment"># =&gt; evaluates to the hash `{key1: 1, key2: 2}`</span>
</code></pre>
<p>To avoid clobbering any existing <code>[]</code> method on these standard library classes,
Sorbet defines classes in the <code>T::</code> namespace that mirror the names of classes
in the standard library.</p>
<blockquote>
<p>Note that this mapping is not automatic: Sorbet has special-cased each
individual class in the table above inside Sorbet (it is not possible to use
merely prepend <code>T::</code> to the name of any class that has been defined as a
generic type in an <a href="/docs/rbi">RBI file</a>).</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="generic-class-without-type-arguments"></a><a href="#generic-class-without-type-arguments" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>“Generic class without type arguments”</h2>
<p>For backwards compatibility reasons during Sorbet’s original rollout, Sorbet
sometimes allows generic classes defined in the Ruby standard library to appear
in type annotations <em>without</em> being provided type arguments:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-comment">#        ^^^^ important</span>

T.let([], Array) <span class="hljs-comment"># no error</span>
</code></pre>
<p>versus:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: strict</span>

T.let([], Array)
<span class="hljs-comment">#         ^^^^^ error: Generic class without type arguments</span>
</code></pre>
<p>When this happens, Sorbet defaults all missing type arguments to <code>T.untyped</code>.</p>
<p>This exception is made only for classes in the Ruby standard library. For all
other generic classes, Sorbet requires that a generic class is provided all of
its required type arguments, even in <code># typed: false</code> files.</p>
<p>This behavior may change in the future, and we strongly discourage relying on it
intentionally.</p>
<h2><a class="anchor" aria-hidden="true" id="generics-and-runtime-checks"></a><a href="#generics-and-runtime-checks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generics and runtime checks</h2>
<p>Recall that Sorbet is not only a static type checker, but also a system for
<a href="/docs/runtime">validating types at runtime</a>.</p>
<p>However, Sorbet completely erases <em>generic type arguments</em> at runtime. When
Sorbet sees a signature like <code>T::Array[Integer]</code>, at runtime it will <strong>only</strong>
check whether an argument has class <code>Array</code>, but not whether every element of
that array is also an <code>Integer</code> at runtime.</p>
<p>This also means that if the element type of an array has type
<a href="/docs/untyped"><code>T.untyped</code></a>, Sorbet will not report a static error, nor will
Sorbet report a runtime error.</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">xs:</span> T::Array[Integer]).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(xs)</span></span>; <span class="hljs-keyword">end</span>

untyped_str_array = T::Array[T.untyped].new(<span class="hljs-string">'first'</span>, <span class="hljs-string">'second'</span>)
foo(untyped_str_array)
<span class="hljs-comment">#   ^^^^^^^^^^^^^^^^^ no static error, AND no runtime error!</span>
</code></pre>
<p>(Also note that unlike other languages that implement generics via type erasure,
Sorbet does not insert runtime casts that preserve type safety at runtime.)</p>
<p>Another consequence of having erased generics is that things like this will not
work:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">xs:</span> T.any(T::Array[Integer], T::Array[String])).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(xs)</span></span>
  <span class="hljs-keyword">if</span> xs.is_a?(T::Array[Integer]) <span class="hljs-comment"># error!</span>
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">elsif</span> xs.is_a?(T::Array[String]) <span class="hljs-comment"># error!</span>
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Sorbet will attempt to detect cases where it looks like this is happening and
report a static error, but it cannot do so in all cases.</p>
<blockquote>
<p><strong>Note</strong>: Sorbet used to take these type arguments into account during runtime
type-checking, but this turned out to be a common and difficult-to-debug
source of performance problems, frequently turning a fast, constant-time
algorithm (e.g., <code>Hash</code> lookup) into a linear scan checking all element types.</p>
<p>In order to verify that an array contained the values it claimed it did, the
Sorbet runtime used to recursively check the type of every member of a
collection, which would take a long time for arrays or hashes of a
sufficiently large size. Consequently, this behavior has been removed.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="standard-library-generics-and-variance"></a><a href="#standard-library-generics-and-variance" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Standard library generics and variance</h2>
<p>Note that all the classes in the Ruby standard library that Sorbet knows about
are <strong>covariant</strong> in their generic type members. Variance is is discussed in the
docs for <a href="/docs/generics">Generic Classes and Methods</a>.</p>
<p>Implementing covariant classes in the Ruby standard library is a compromise. It
means that things like this typecheck:</p>
<pre><code class="hljs css language-ruby">sig {returns(T::Array[Integer])}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">returns_ints</span>;</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">xs:</span> T::Array[T.any(Integer, String)]).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takes_ints_or_strings</span><span class="hljs-params">(xs)</span></span>; <span class="hljs-keyword">end</span>

xs = returns_ints
takes_ints_or_strings(xs) <span class="hljs-comment"># no error</span>
</code></pre>
<p>This makes it easy to get the most common Ruby usage patterns to type check
without jumping through hoops.</p>
<p><strong>However</strong>, having things like arrays and hash maps in Ruby be covariant means
that the type checker wilfully says certain programs type check even when they
have glaring type errors. For example:</p>
<pre><code class="hljs css language-ruby">xs = T.let([<span class="hljs-number">0</span>], T::Array[Integer])
nil_xs = T.let(xs, T::Array[T.nilable(Integer)])
nil_xs[<span class="hljs-number">0</span>] = <span class="hljs-literal">nil</span>

T.reveal_type(xs.fetch(<span class="hljs-number">0</span>)) <span class="hljs-comment"># type: Integer (!)</span>
puts xs.fetch(<span class="hljs-number">0</span>)           <span class="hljs-comment"># =&gt; nil        (!)</span>
</code></pre>
<p>In this example, we start with <code>xs</code> having type <code>T::Array[Integer]</code>. We then
upcast it to a <code>T::Array[T.nilable(Integer)]</code>. This is the power of
covariance—this would not have been allowed had arrays been made invariant.</p>
<p>Sorbet allows <code>nil_xs[0] = nil</code> because the type of <code>nil_xs</code> says that it’s fine
for the array to contain <code>nil</code> values.</p>
<p>But that’s a contradiction! <code>nil_xs</code> and <code>xs</code> are merely different names for the
same underlying storage. Later if someone were to go back and read the first
element of <code>xs</code>, Sorbet would claim that they’re getting back an <code>Integer</code>, but
in fact, they’d be getting back a <code>nil</code>.</p>
<p>Sorbet is not the only type system to implement covariant arrays. Notably:
TypeScript uses the same approach. This decision was largely motivated by
getting as much Ruby code to typecheck when initially developing and rolling out
Sorbet on large, existing codebases.</p>
<h2><a class="anchor" aria-hidden="true" id="whats-next"></a><a href="#whats-next" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What’s next?</h2>
<ul>
<li><p><a href="/docs/class-types">Class Types</a></p>
<p>Every Ruby class and module doubles as a type in Sorbet. Class types supersede
the notion some other languages have of “primitive” types. For example,
<code>&quot;abc&quot;</code> is an instance of the <code>String</code> class, and so <code>&quot;abc&quot;</code> has type
<code>String</code>.</p></li>
<li><p><a href="/docs/generics">Generic Classes and Methods</a></p>
<p>Types do not have to belong in the Ruby standard library to be declared as
generic types. Read more about how to define custom generic classes and
methods.</p></li>
</ul>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/class-types"><span class="arrow-prev">← </span><span>Class Types (Integer, String)</span></a><a class="docs-next button" href="/docs/nilable-types"><span>Nilable Types (T.nilable)</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#why-the-t-prefix">Why the <code>T::</code> prefix?</a></li><li><a href="#generic-class-without-type-arguments">&quot;Generic class without type arguments&quot;</a></li><li><a href="#generics-and-runtime-checks">Generics and runtime checks</a></li><li><a href="#standard-library-generics-and-variance">Standard library generics and variance</a></li><li><a href="#whats-next">What's next?</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer">© 2022 Stripe · <a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>