<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Sorbet Error Reference · Sorbet</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;style&gt;"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Sorbet Error Reference · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="&lt;style&gt;"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-card@2x.png"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://sorbet.org/blog/atom.xml" title="Sorbet Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://sorbet.org/blog/feed.xml" title="Sorbet Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try</a></li><li class=""><a href="/en/community" target="_self">Community</a></li><li class=""><a href="https://github.com/sorbet/sorbet" target="_self">GitHub</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Troubleshooting</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/metrics">Tracking Adoption</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/vscode">Visual Studio Code</a></li><li class="navListItem"><a class="navItem" href="/docs/from-typescript">TypeScript ↔ Sorbet</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/why-type-annotations">Why type annotations?</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">sig</a></li><li class="navListItem"><a class="navItem" href="/docs/type-annotations">Type Annotations (non-sig)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">T.let, T.cast, T.must, T.bind</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types (Integer, String)</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Arrays &amp; Hashes</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types (T.nilable)</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types (T.any)</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow-Sensitivity (is_a?, nil?)</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">T.type_alias</a></li><li class="navListItem"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness (T.absurd)</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">T::Struct</a></li><li class="navListItem"><a class="navItem" href="/docs/tenum">T::Enum</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Blocks, Procs, &amp; Lambdas</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes &amp; Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/final">Final Methods &amp; Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/override-checking">Override Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/sealed">Sealed Classes</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/attached-class">T.attached_class</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types (T.all)</a></li><li class="navListItem"><a class="navItem" href="/docs/non-forcing-constants">T::NonForcingConstants</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Experimental Features</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/requires-ancestor">Requiring Ancestors</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/sorbet/sorbet/edit/master/website/docs/error-reference.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Sorbet Error Reference</h1></header><article><div><span><style>
#missing-doc-for-error-code-box.is-hidden {
  display: none;
}
</style>
<div class="is-hidden red" id="missing-doc-for-error-code-box">
<p><a class="anchor" aria-hidden="true" id="missing-doc-for-error-code-scroll"></a></p>
<blockquote>
<p><strong>Heads up</strong>: There aren’t any docs yet for <span id="missing-error-code">this
error code</span>. If you have suggestions for what would have helped you
solve this problem, click the “Edit” button above to contribute! Otherwise,
try using the search above to find an answer.</p>
</blockquote>
</div>
<blockquote>
<p><strong>Note</strong>: This list is not exhaustive! Some errors are very context dependent
and other error codes are not common enough to know how to generally suggest
help. Contributions to this list are welcome!</p>
</blockquote>
<p>This is one of three docs aimed at helping answer common questions about Sorbet:</p>
<ol>
<li><a href="/docs/troubleshooting">Troubleshooting</a></li>
<li><a href="/docs/faq">Frequently Asked Questions</a></li>
<li><a href="/docs/error-reference">Sorbet Error Reference</a> (this doc)</li>
</ol>
<p>This page contains tips and tricks for common errors from <code>srb</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="1001"></a><a href="#1001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1001</h2>
<p>Sorbet has crashed. Please <a href="https://github.com/sorbet/sorbet/issues">report an issue</a>!</p>
<h2><a class="anchor" aria-hidden="true" id="1003"></a><a href="#1003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1003</h2>
<p>Sorbet has an internal limitation on how deep a chain of class aliases can be:</p>
<pre><code class="hljs css language-ruby">A1 = Integer
A2 = A1
<span class="hljs-comment"># ...</span>
A42 = A41
A43 = A42 <span class="hljs-comment"># error: Too many alias expansions</span>
</code></pre>
<p>It’s meant to guard against cases where Sorbet might get stuck in an infinite
loop attempting to dealias these class aliases.</p>
<p>If you encounter this bug in the wild (i.e., not just for a contrived example,
but a real-world use case), please share with the Sorbet team. We’d like to see
what mode of use triggered this behavior, and either add a test to Sorbet or
tweak how Sorbet works to support the use case.</p>
<h2><a class="anchor" aria-hidden="true" id="1004"></a><a href="#1004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1004</h2>
<p>Sorbet couldn’t find a file.</p>
<h2><a class="anchor" aria-hidden="true" id="2001"></a><a href="#2001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2001</h2>
<p>There was a Ruby syntax error. Sorbet was unable to parse the source code. If
you encounter this error but your code is accepted by Ruby itself, this is a bug
in our parser; please <a href="https://github.com/sorbet/sorbet/issues">report an issue</a> to us so we can address it.</p>
<p>The only intentional break with Ruby compatibility is that method names that are
keywords have some limitations with multi-line code, as explained in <a href="https://github.com/sorbet/sorbet/pull/1993">#1993</a>,
and should not be reported.</p>
<h2><a class="anchor" aria-hidden="true" id="2002"></a><a href="#2002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2002</h2>
<p>Starting in Ruby 3.0, Ruby uses the <code>_1</code>, <code>_2</code>, etc. syntax for block arguments:</p>
<pre><code class="hljs css language-ruby">xs.map {_1.to_s}

<span class="hljs-comment"># ^ this is equivalent to:</span>

xs.map { <span class="hljs-params">|x|</span> x.to_s }
</code></pre>
<p>Because of this, <code>_1</code> and similar variables are not allowed as normal variable
names. Pick another variable name, for example: <code>_x1</code> or <code>_arg1</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="2003"></a><a href="#2003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2003</h2>
<p>If you’re seeing this error code, it means that Sorbet already emitted a parse
error for the file, but found some extra information that might help point out
the root cause of a syntax error. For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    <span class="hljs-keyword">if</span> x
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This Ruby snippet does not parse, but the reason why is confusing. Because Ruby
does not care about indentation, it will try to consune <code>end</code> keywords eagerly
if there is something available to match. In this example, the first <code>end</code>
matches with <code>if</code> and the second matches with <code>def</code> and so Sorbet will report
<code>unexpected token &quot;end of file&quot;</code> because the <code>class A</code> definition was not
matched with an <code>end</code> token.</p>
<p>But given the indentation structure present in the original program, it’s more
likely that the <code>if x</code> statement is unclosed. Thus, in some cases, Sorbet will
provide extra “Hint:” diagnostics that point out things that might be the root
cause.</p>
<p>It’s important to note that <strong>these hints are imperfect</strong>—fixing them might not
actually fix the real parse error. Instead, they’re provided as a way to help
recover from the real parse error.</p>
<p>As with all Sorbet error messages, if one of these hint error messages is
confusing or misleading, please <a href="https://github.com/sorbet/sorbet/issues">report an issue</a> to let us know.</p>
<h2><a class="anchor" aria-hidden="true" id="2004"></a><a href="#2004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2004</h2>
<p>Starting in Ruby 3.0, Ruby uses the <code>_1</code>, <code>_2</code>, etc. syntax for block arguments:</p>
<pre><code class="hljs css language-ruby">xs.map {_1.to_s}

<span class="hljs-comment"># ^ this is equivalent to:</span>

xs.map { <span class="hljs-params">|x|</span> x.to_s }
</code></pre>
<p>Because of this, <code>_1</code> and similar variables are not allowed as normal variable
names. Pick another variable name, for example: <code>_x1</code> or <code>_arg1</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="3001"></a><a href="#3001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3001</h2>
<p>Sorbet doesn’t support singleton definitions outside of the class itself:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; MyClass <span class="hljs-comment"># error: `class &lt;&lt; EXPRESSION` is only supported for `class &lt;&lt; self`</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The workaround is to move the definition inside the <code>MyClass</code> class itself:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; self</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
      <span class="hljs-comment"># ...</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Sometimes, <code>EXPRESSION</code> is not a constant literal like in what follows:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; some_variable</span>
  <span class="hljs-keyword">include</span> Foo
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, it is possible to directly call <code>include</code> on the the singleton
class of <code>EXPRESSION</code>, but it should be done with <strong>utmost caution</strong>, as Sorbet
will not consider the include and provide a less accurate analysis (see also
<a href="#4002">#4002</a>):</p>
<pre><code class="hljs css language-rb">some_variable.singleton_class.<span class="hljs-keyword">include</span>(Foo)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3002"></a><a href="#3002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3002</h2>
<p>Sorbet is limited to C++ <code>INT_MAX</code>:</p>
<pre><code class="hljs css language-rb">puts <span class="hljs-number">11377327221391349843</span> + <span class="hljs-number">1</span> <span class="hljs-comment"># error: Unsupported integer literal: 11377327221391349843</span>
</code></pre>
<p>A possible workaround is to use a string and <code>to_i</code>:</p>
<pre><code class="hljs css language-rb">puts <span class="hljs-string">"11377327221391349843"</span>.to_i + <span class="hljs-number">1</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3003"></a><a href="#3003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3003</h2>
<p>Sorbet does not support certain Ruby features, like the flip flop operator and
the <code>redo</code> keyword. If you feel strongly that Sorbet support these features,
please open an issue.</p>
<p>Unfortunately, there is no workaround for this issue other than asking Sorbet to
ignore the file (which forces the <em>entire</em> file to be ignored, including any
methods and constants defined in it), or rewriting the file to not use the
unsupported Ruby feature.</p>
<p>If you do decide to ignore the file entirely, you will likely need to use an
<a href="/docs/rbi">RBI file</a> to let Sorbet know about any classes and methods defined in
the ignored file.</p>
<h2><a class="anchor" aria-hidden="true" id="3004"></a><a href="#3004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3004</h2>
<p>There was an error parsing a float literal in Sorbet. Specifically, we asked a
C++ library to parse a Ruby float literal string to a float, and it returned a
<code>NaN</code> value.</p>
<p>If you are seeing this error, it likely represents a bug in Sorbet. Please
report an issue at <a href="https://github.com/sorbet/sorbet/issues">https://github.com/sorbet/sorbet/issues</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="3005"></a><a href="#3005" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3005</h2>
<p>Sorbet does not support using operators like <code>&amp;&amp;=</code> or <code>||=</code> when the target of
the operator is a constant literal.</p>
<p>Note that Ruby itself will report a warning for such usage:</p>
<pre><code class="hljs css language-ruby">A = <span class="hljs-literal">nil</span>
A <span class="hljs-params">||</span>= <span class="hljs-number">1</span>
<span class="hljs-comment"># =&gt; warning: already initialized constant A</span>
</code></pre>
<p>If you absolutely must reassign a constant using the current value of the
constant, rewrite the code to use <code>const_defined?</code> and <code>const_set</code>:</p>
<pre><code class="hljs css language-ruby">A = <span class="hljs-literal">nil</span>
<span class="hljs-keyword">unless</span> Object.const_defined?(<span class="hljs-symbol">:A</span>) &amp;&amp; A
  Object.const_set(<span class="hljs-symbol">:A</span>, <span class="hljs-number">1</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3007"></a><a href="#3007" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3007</h2>
<p>Using <code>yield</code> in a method body means that a method implicitly takes a block
argument. In <code># typed: strict</code> files, such methods are required to explicitly
name the block argument to make the contract clear:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
  <span class="hljs-keyword">yield</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This is required even if the block is only ever used by way of <code>yield</code>, and
never with something like <code>blk.call</code>.</p>
<p><strong>Why?</strong> The distinguishing factor of <code># typed: strict</code> is that every method has
an explicit interface with a signature. It’s equally important to be explicit
about the block argument, if present. For more, see the docs on
<a href="/docs/static#file-level-granularity-strictness-levels">strictness levels</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="3008"></a><a href="#3008" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3008</h2>
<p>Sorbet does not support the <code>undef</code> keyword. Sorbet assumes that the set of all
classes, modules, methods, and constants is static throughout the lifetime of a
program. It does not attempt to model the way that a Ruby program might mutate
itself by deleting constants or methods at runtime.</p>
<p>For this reason, the <code>undef</code> node is not supported.</p>
<p>Currently, this error is only reported at <code># typed: strict</code> or higher, though in
the future this might move to lower strictness levels. It does mean that
currently it’s possible to silence this error by downgrading the file containing
the <code>undef</code> to <code># typed: true</code> or lower.</p>
<p>Note that regardless of whether Sorbet reports an error for using <code>undef</code>, it
has no meaning on what Sorbet considers to be defined or not defined. Sorbet
will not report errors for calls to a method that doesn’t exist because it has
been undefined.</p>
<h2><a class="anchor" aria-hidden="true" id="3009"></a><a href="#3009" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3009</h2>
<p>Sorbet does not support certain kinds of complicated block parameter
destructuring patterns. In most cases, it is possible to rewrite these to use
destructuring assignments inside the block itself:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ----- BAD -----</span>

xs = [[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">42</span>]
xs.<span class="hljs-keyword">then</span> <span class="hljs-keyword">do</span> <span class="hljs-params">|(x, *args), y|</span>
  <span class="hljs-comment">#             ^^^^^ error: Unsupported rest args in destructure</span>
  p x    <span class="hljs-comment"># =&gt; 0</span>
  p args <span class="hljs-comment"># =&gt; [1, 2, 3]</span>
  p y    <span class="hljs-comment"># =&gt; 42</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># ----- Use this instead -----</span>

xs.<span class="hljs-keyword">then</span> <span class="hljs-keyword">do</span> <span class="hljs-params">|arg0, y|</span>
  x, *args = arg<span class="hljs-number">0</span>

  p x     <span class="hljs-comment"># =&gt; 0</span>
  p args  <span class="hljs-comment"># =&gt; [1, 2, 3]</span>
  p y     <span class="hljs-comment"># =&gt; 42</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3010"></a><a href="#3010" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3010</h2>
<p>Methods defined in <a href="/docs/rbi">RBI files</a> are not allowed to have code in their
bodies.</p>
<p>The only exception is for instance variable assignments (like <code>@x = ...</code>), which
are allowed so that RBI files may declare the existence of instance variables
and their types.</p>
<h2><a class="anchor" aria-hidden="true" id="3011"></a><a href="#3011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3011</h2>
<p>There was a Hash literal with duplicated keys.</p>
<pre><code class="hljs css language-ruby">{<span class="hljs-symbol">my_key:</span> <span class="hljs-number">1</span>, <span class="hljs-symbol">my_key:</span> <span class="hljs-number">2</span>} <span class="hljs-comment"># error: `my_key` is duplicated</span>
</code></pre>
<p>This error can also be caused when trying to write a <code>sig</code> for a method with
duplicated parameter names:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">_:</span> String, <span class="hljs-symbol">_:</span> Integer).void} <span class="hljs-comment"># error: `_` is duplicated</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-number">_</span>, <span class="hljs-number">_</span>)</span></span>; <span class="hljs-keyword">end</span>
</code></pre>
<p>To write a <code>sig</code> for this method, rename the method’s parameters to have unique
names:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">_a:</span> String, <span class="hljs-symbol">_b:</span> Integer).void} <span class="hljs-comment"># ok</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(_a, _b)</span></span>; <span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3501"></a><a href="#3501" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3501</h2>
<p>Sorbet has special support for understanding Ruby’s <code>attr_reader</code>,
<code>attr_writer</code>, and <code>attr_accessor</code> methods. For this support to work, it must be
able to see the name of the attribute <strong>syntactically</strong>, which means that the
argument must be a <code>String</code> or <code>Symbol</code> literal.</p>
<p>If you are attempting to dynamically compute the name of an <code>attr_*</code> method, you
must either:</p>
<ol>
<li>Downgrade the file to <code># typed: false</code>, or</li>
<li>Hide <code>attr_*</code> method call from Sorbet by using something like
<code>public_send(:attr_reader, name)</code> (instead of <code>attr_reader name</code>)</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="3502"></a><a href="#3502" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3502</h2>
<p><code>T::InterfaceWrapper</code> is deprecated and should not be used.</p>
<h2><a class="anchor" aria-hidden="true" id="3503"></a><a href="#3503" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3503</h2>
<p>Ruby has separate syntax for marking instance methods and singleton class
methods private:</p>
<pre><code class="hljs css language-ruby">private <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">some_instance_method</span>;</span> <span class="hljs-keyword">end</span>
private_class_method <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">some_singleton_class_method</span>;</span> <span class="hljs-keyword">end</span>
</code></pre>
<p>Note that the <code>self.</code> keyword in the method declaration changes the method from
being an instance method to being a class method. In Ruby this <code>self.</code> prefix is
similar to the <code>static</code> keyword on method definitions in languages like C++ or
Java.</p>
<h2><a class="anchor" aria-hidden="true" id="3504"></a><a href="#3504" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3504</h2>
<p>The signature of an <code>attr_reader</code>, <code>attr_writer</code>, or <code>attr_accessor</code> method
cannot have any <code>T.type_parameter</code> in it.</p>
<p>These methods get and set instance variables on the underlying class, while the
<code>T.type_parameter</code> in the signature would only be in method scope.</p>
<h2><a class="anchor" aria-hidden="true" id="3505"></a><a href="#3505" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3505</h2>
<p>The <code>module_function</code> helper declares that an instance method on a module should
be duplicated onto the class’s singleton class.</p>
<p>The <code>module_function</code> must be given an argument that is <strong>syntactically</strong>
either:</p>
<ul>
<li>a method def</li>
<li>a <code>String</code> or <code>Symbol</code> literal with the name of a method</li>
</ul>
<p>This argument must be provided syntactically because Sorbet has special handling
for <code>module_function</code>, and this special logic must be able to see the exact name
of the method that is being defined via <code>module_function</code>.</p>
<p>To silence this error, either:</p>
<ul>
<li>Refactor the code to use <code>module_function</code> with only calls to method
definitions or literals, or</li>
<li>Downgrade the file to <code># typed: false</code> or lower, or</li>
<li>Use <code>send(:module_function, ...)</code> to hide the call to <code>module_function</code> from
Sorbet.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="3506"></a><a href="#3506" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3506</h2>
<p>Enums declared with <code>T::Enum</code> are special. A <code>T::Enum</code> must have all of its enum
values defined in the <code>enums do</code> block inside an enum, and it’s not allowed to
have any extra constants defined on the class (i.e., constants that don’t hold
values of the enum).</p>
<p><strong>Why?</strong> Consistency, readability, and simplicity of implementation at runtime.</p>
<p>This includes type aliases. If you’d like to define a type alias consisting of a
set of enum values, the type alias must be declared outside of the <code>T::Enum</code>
subclass itself.</p>
<p>Note that enums can still have instance variables and methods defined on them.
For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Direction</span> &lt; T::Enum</span>
  enums <span class="hljs-keyword">do</span>
    Up = new
    Down = new
    Left = new
    Right = new
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">vertical</span></span>
    @vertical <span class="hljs-params">||</span>= [Up, Down].freeze
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3507"></a><a href="#3507" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3507</h2>
<p>The syntax for <code>test_each</code> looks like this:</p>
<pre><code class="hljs css language-ruby">test_each([<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>]) <span class="hljs-keyword">do</span> <span class="hljs-params">|x|</span>
  it <span class="hljs-string">'test'</span> <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>For more examples of valid syntax,
<a href="https://github.com/sorbet/sorbet/blob/master/test/testdata/rewriter/minitest_tables.rb">see the tests</a>.</p>
<p>There are some limitations on how <code>test_each</code> can be used:</p>
<p>The block given to <code>test_each</code> must accept at least one argument (except when
using <code>test_each_hash</code>, it must be able to take exactly two arguments).</p>
<p>The body of the <code>test_each</code>'s block must contain only <code>it</code> blocks, because of
limitations in Sorbet. Sorbet models <code>it</code> blocks by translating them to method
definitions under the hood, and method definitions do not have access to
variables outside of their scope.</p>
<p>Usually this comes up with variable destructuring:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- BAD EXAMPLE --</span>
test_each(values) <span class="hljs-keyword">do</span> <span class="hljs-params">|value|</span>
  x, y = compute_x_y(value)
  it <span class="hljs-string">'example 1'</span> <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">end</span>
  it <span class="hljs-string">'example 2'</span> <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This can be fixed by worked around by writing the assignment into each <code>it</code>
block directly, or by computing it ahead of time:</p>
<pre><code class="hljs css language-ruby">test_each(values) <span class="hljs-keyword">do</span> <span class="hljs-params">|value|</span>
  it <span class="hljs-string">'example 1'</span> <span class="hljs-keyword">do</span>
    x, y = compute_x_y(value)
  <span class="hljs-keyword">end</span>
  it <span class="hljs-string">'example 2'</span> <span class="hljs-keyword">do</span>
    x, y = compute_x_y(value)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="hljs css language-ruby">new_values = values.map <span class="hljs-keyword">do</span> <span class="hljs-params">|value|</span>
  x, y = compute_x_y(value)
  [value, x, y]
<span class="hljs-keyword">end</span>
test_each(new_values) <span class="hljs-keyword">do</span> <span class="hljs-params">|value, x, y|</span>
  it <span class="hljs-string">'example 1'</span> <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">end</span>
  it <span class="hljs-string">'example 2'</span> <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="3508"></a><a href="#3508" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3508</h2>
<p>The argument to the <code>foreign:</code> attribute on a <code>prop</code> declaration must be a
lambda function. This prevents the other model class from needing to be loaded
eagerly. Use the autocorrect to fix the error.</p>
<h2><a class="anchor" aria-hidden="true" id="3509"></a><a href="#3509" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3509</h2>
<p>The argument to the <code>computed_by</code> argument on a prop must be a <code>Symbol</code> literal
(i.e., syntactically, so that Sorbet can analyze it without performing any
inference).</p>
<h2><a class="anchor" aria-hidden="true" id="3510"></a><a href="#3510" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3510</h2>
<p>The return type of the <code>initialize</code> method in Ruby is never used. Under the
hood, a call to <code>new</code> on a class in Ruby looks something like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">new</span><span class="hljs-params">(...)</span></span>
  instance = alloc
  _discarded = instance.initialize(...)
  instance
<span class="hljs-keyword">end</span>
</code></pre>
<p>If you’d like to make a custom factory method for your class, define a custom
singleton class method.</p>
<h2><a class="anchor" aria-hidden="true" id="3511"></a><a href="#3511" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3511</h2>
<p>Accessor methods defined with <code>Struct.new</code> must not end with <code>=</code>, because the
generated setter method will then be given an invalid name ending with <code>==</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="3512"></a><a href="#3512" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3512</h2>
<p><code>T.nilable(T.untyped)</code> is just <code>T.untyped</code>, because <code>nil</code> is a valid value of
type <code>T.untyped</code> (along with all other values).</p>
<h2><a class="anchor" aria-hidden="true" id="3702"></a><a href="#3702" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3702</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>Package definitions must be formatted like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Opus::Foo</span> &lt; PackageSpec</span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this example, <code>Opus::Foo</code> is the name of the package, and <code>PackageSpec</code>
explicitly declares that this class definition is a package spec.</p>
<h2><a class="anchor" aria-hidden="true" id="3703"></a><a href="#3703" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3703</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>Each package must have only one definition. A package definition is the place
where there is a line like <code>class Opus::Foo &lt; PackageSpec</code> in a <code>__package.rb</code>
file.</p>
<h2><a class="anchor" aria-hidden="true" id="3704"></a><a href="#3704" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3704</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>Sorbet found an <code>import</code> in a <code>__package.rb</code> file, but the imported constant did
not exist.</p>
<h2><a class="anchor" aria-hidden="true" id="3705"></a><a href="#3705" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3705</h2>
<blockquote>
<p><strong>TODO</strong> This error code is not yet documented.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="3706"></a><a href="#3706" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3706</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>All <code>import</code> and <code>export</code> lines in a <code>__package.rb</code> file must have constant
literals as their argument. Doing arbitrary computation of imports and exports
is not allowed in <code>__package.rb</code> files.</p>
<p>Also note that all <code>import</code> declarations must be unique, with no duplicated
imports.</p>
<h2><a class="anchor" aria-hidden="true" id="3707"></a><a href="#3707" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3707</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p><code>__package.rb</code> files must declare exactly one package.</p>
<h2><a class="anchor" aria-hidden="true" id="3709"></a><a href="#3709" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3709</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>A package cannot import itself. Double check which files and/or packages you
intended to modify, as you’ve likely made a typo.</p>
<h2><a class="anchor" aria-hidden="true" id="3710"></a><a href="#3710" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3710</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>Even though <code>__package.rb</code> files use Ruby syntax, they do not allow arbitrary
Ruby code. The fact that they use Ruby syntax is a convenience so that:</p>
<ul>
<li>package declarations get syntax highlighting in all Ruby editors</li>
<li>tooling like Sorbet and RuboCop work on <code>__package.rb</code> files out of the box</li>
<li>Sorbet can support things like jump-to-definition inside <code>__package.rb</code> files</li>
</ul>
<p>But despite that, <code>__package.rb</code> files must be completely statically analyzable,
which means most forms of Ruby expressions are not allowed in these files.</p>
<h2><a class="anchor" aria-hidden="true" id="3711"></a><a href="#3711" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3711</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>Package files must be <code># typed: strict</code>. If you are in the process of migrating
a codebase to use the packager mode and want to sometimes ignore a
<code>__package.rb</code> file, use the <code>--ignore=__package.rb</code> command line flag which
will ignore all files whose name matches <code>__package.rb</code> exactly, in any folder.</p>
<h2><a class="anchor" aria-hidden="true" id="3712"></a><a href="#3712" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3712</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>Package names must not contain underscores. Internally, the packager assumes it
can use the underscore character to join components of a package name together.
For example, internally the package uses names like <code>Opus_Foo</code> to represent the
package <code>Opus::Foo</code>. If underscores were allowed in package names,
<code>Opus_Foo_Bar</code> could represent a package called <code>Opus::Foo_Bar</code>, <code>Opus_Foo::Bar</code>
or <code>Opus::Foo::Bar</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="3713"></a><a href="#3713" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3713</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>All code inside a package must live within the namespace declared by it’s
enclosing <code>__package.rb</code> file. Note that since packages are allowed to nest
inside each other, sometimes you might have attempted to add code in a folder
that you didn’t realize was actually managed by a nested package.</p>
<p>If you’re seeing this error and surprised, double check which folders have
<code>__package.rb</code> files in them, and the names of the packages declared by them.</p>
<h2><a class="anchor" aria-hidden="true" id="3714"></a><a href="#3714" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3714</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>This error arises when it’s unclear which import actually provides a constant,
which in turn usually happens with nested packages: given a constant <code>A::B::C</code>
and a package that imports both the packages <code>A</code> and <code>A::B</code>, it’s difficult to
tell without deep examination which actually exports <code>A::B::C</code>.</p>
<p>In these cases, it’s best to refactor the packages so they are clearly
delineated: instead of <code>A</code> and <code>A::B</code>, it might be best to figure out what
behavior lives in <code>A</code> but not <code>A::B</code> and move it to a new package entirely, like
<code>A::X</code> (and then update the import structure as needed).</p>
<p>This error can also be produced when trying to import a name which is a prefix
of the nested package: for example, importing <code>A</code> when your package name is
<code>A::B</code>.</p>
<p>Again, this probably implies you should try to move away from the nested package
structure, and move the contents of <code>A</code> that aren’t in a nested package into
another less ambiguous package.</p>
<h2><a class="anchor" aria-hidden="true" id="3715"></a><a href="#3715" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3715</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>The <code>export_for_test</code> directive is used to say, “Make this constant from the
non-test namespace available in the test namespace for the same package.” That
means it only makes sense to <code>export_for_test</code> constants from the non-test
namespace.</p>
<p>Trying to apply this directive to a constant defined in the <code>Test::</code> namespace
will result in this error.</p>
<p>If you’re trying to export a constant from the test namespace to be used in
other packages, then just use <code>export</code>. Otherwise, these lines can be safely
deleted.</p>
<h2><a class="anchor" aria-hidden="true" id="3716"></a><a href="#3716" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3716</h2>
<blockquote>
<p>This error is specific to Stripe’s custom <code>--stripe-packages</code> definition. If
you are at Stripe, please see <a href="http://go/modularity">go/modularity</a> for more.</p>
</blockquote>
<p>This error means that you’re exporting a constant redundantly. In Stripe
Packages mode, exporting a constant <code>A::B</code> will export anything accessible
underneath <code>A::B</code>. That means that if you try to export <code>A::B</code> and <code>A::B::C</code>,
you’ll get this error—the latter export is redundant, as it’s implied by export
<code>A::B</code>.</p>
<p>To fix this error, simply remove the more specific export.</p>
<h2><a class="anchor" aria-hidden="true" id="4001"></a><a href="#4001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4001</h2>
<p>Sorbet parses the syntax of <code>include</code> and <code>extend</code> declarations, even in
<code># typed: false</code> files. Recall from the
<a href="/docs/static#file-level-granularity-strictness-levels">strictness levels</a> docs
that all constants in a Sorbet codebase must resolve, even at <code># typed: false</code>.
Parsing <code>include</code> blocks is required for this, so incorrect usages of <code>include</code>
are reported when encountered.</p>
<h2><a class="anchor" aria-hidden="true" id="4002"></a><a href="#4002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4002</h2>
<p>Sorbet requires that every <code>include</code> references a constant literal. For example,
this is an error, even in <code># typed: false</code> files:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span></span>
  rand.round == <span class="hljs-number">0</span> ? A : B
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  <span class="hljs-keyword">include</span> x  <span class="hljs-comment"># error: `include` must be passed a constant literal</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Non-constant literals make it hard to impossible to determine the complete
inheritance hierarchy in a codebase. Sorbet must know the complete inheritance
hierarchy of a codebase in order to check that a variable is a valid instance of
a type.</p>
<p>It is possible to silence this error with <code>T.unsafe</code>, but it should be done with
<strong>utmost caution</strong>, as Sorbet will not consider the include and provide a less
accurate analysis:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">x</span></span>
  rand.round == <span class="hljs-number">0</span> ? A : B
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  T.unsafe(<span class="hljs-keyword">self</span>).<span class="hljs-keyword">include</span> x
<span class="hljs-keyword">end</span>
</code></pre>
<p>Which might create unexpected errors:</p>
<pre><code class="hljs css language-ruby">c = C.new

c.a <span class="hljs-comment"># error: Method `a` does not exist on `C`</span>
c.b <span class="hljs-comment"># error: Method `b` does not exist on `C`</span>

T.let(C, A) <span class="hljs-comment"># error: Argument does not have asserted type `A`</span>
T.let(C, B) <span class="hljs-comment"># error: Argument does not have asserted type `B`</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="4003"></a><a href="#4003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4003</h2>
<p>Sorbet parses the syntax of <code>include</code> and <code>extend</code> declarations, even in
<code># typed: false</code> files. Recall from the
<a href="/docs/static#file-level-granularity-strictness-levels">strictness levels</a> docs
that all constants in a Sorbet codebase must resolve, even at <code># typed: false</code>.
Parsing <code>include</code> blocks is required for this, so incorrect usages of <code>include</code>
are reported when encountered.</p>
<h2><a class="anchor" aria-hidden="true" id="4006"></a><a href="#4006" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4006</h2>
<p>The <code>super</code> keyword in Ruby will call the method with the same name on the
nearest ancestor (whether on a mixed-in module or the superclass).</p>
<p>This method only makes sense to call inside the body of a method, not inside a
class or file top-level.</p>
<h2><a class="anchor" aria-hidden="true" id="4010"></a><a href="#4010" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4010</h2>
<p>When using Sorbet, try to avoid redefining a method. A method is redefined when
a method of the same name is defined in the same class (note that Sorbet
completely supports overriding methods, where two methods have the same name but
one is in a parent class and one in a child class).</p>
<p>If redefining a method is unavoidable, the arity of the new method must match
the previous method’s arity exactly. A method’s arity includes how many
positional arguments a method has, which keyword arguments it takes, etc.</p>
<p>Determining the arity of the previous method can sometimes be tricky, especially
when the previous method was defined dynamically by a DSL. In these cases, the
easiest way to determine a method’s arity is to find a place where that method
is <strong>called</strong>, hover over it using Sorbet’s <a href="/docs/vscode">editor integration</a>, and
copy the displayed method definition.</p>
<p>It’s worth noting that this error occurs particularly frequently in RBI files,
especially autogenerated RBI files. Consider a case like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- some_gem.rbi --</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeGem</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x = <span class="hljs-literal">nil</span>, y = <span class="hljs-literal">nil</span>)</span></span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># -- autogenerated/some_gem.rbi --</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeGem</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*args)</span></span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, two RBIs define conflicting definitions for <code>SomeGem#foo</code> because
the arity of <code>x, y</code> does not match the arity of <code>*args</code>. (This frequently
happens because, say, the gem wants to do custom parameter checking so that in
certain cases <code>x</code> or <code>y</code> is actually required.) The <code>autogenerated/</code> RBI file
was generated by using Ruby’s reflection APIs to ask for the arity of the method
as seen by the Ruby VM, while the other RBI was hand-written by the gem
maintainer.</p>
<p>In cases like these, usually the solution is to remove the <code>foo</code> definition from
<code>autogenerated/some_gem.rbi</code>, which can usually be accomplished by regenerating
the RBI.</p>
<p><strong>Note</strong>: The arity of a method does not include types, only names and kinds of
its parameters. For example:</p>
<pre><code class="hljs css language-ruby">sig {returns(Integer)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
sig {returns(String)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
</code></pre>
<p>In this example, both <code>foo</code> methods have the same arity (they take no arguments,
or are “nullary”), so no error is raised about redefining a method.</p>
<p>But in this case, where their signatures specify different types, the behavior
is unspecified. Sorbet <strong>usually</strong> takes the types from the “last” signature,
but which signature is “last” is implementation defined when when the two method
definitions happen in two separate files. This includes the case when both a
Ruby source file (<code>*.rb</code>) and an RBI file (<code>*.rbi</code>) specify a signature for a
method.</p>
<p>That Sorbet supports method redefinitions, including providing multiple
signatures for a method definition across multiple files, and that this error is
<strong>only</strong> reported at <code># typed: true</code> and above is an accident of history, and
part of the reason why Sorbet strongly discourages using method redefinitions.</p>
<p>One alternative is to mark the original method <code>private</code> and define a new method
with a new name, instead of redefining the old method. Another alternative is to
use Sorbet’s <a href="/docs/vscode">editor integration</a> to rename the old method, declare
that old method <code>private</code>, and define a new method with the original name.</p>
<h2><a class="anchor" aria-hidden="true" id="4011"></a><a href="#4011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4011</h2>
<p>There are multiple definitions for the same type member within a given class or
module.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>
  extend T::Generic

  Elem = type_member
  Elem = type_member <span class="hljs-comment"># error: Duplicate type member</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>You can fix this by removing the second definition of the type member:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span>
  extend T::Generic

  Elem = type_member <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="4012"></a><a href="#4012" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4012</h2>
<p>A <code>class</code> was redefined as a <code>module</code> or <em>vice versa</em> in two separate locations.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># file_a.rb</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># file_b.rb</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Foo</span></span>
<span class="hljs-keyword">end</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0A%23%20file_a.rb%0Aclass%20Foo%0Aend%0A%0A%23%20file_b.rb%0Amodule%20Foo%0Aend">→
View on sorbet.run</a></p>
<p>You can fix this error by ensuring that both definitions are declared as
<code>class</code>es, ensuring both definitions are declared as <code>module</code>s, or renaming
either definition so they no longer conflict.</p>
<h2><a class="anchor" aria-hidden="true" id="4013"></a><a href="#4013" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4013</h2>
<p>The <code>interface!</code> annotation is reserved for modules. To include abstract methods
in a class, mark the class <code>abstract!</code> instead.</p>
<h2><a class="anchor" aria-hidden="true" id="4014"></a><a href="#4014" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4014</h2>
<p>Sorbet does not support dynamic constant references. All constants must be plain
constant literals.</p>
<p>If you are adopting Sorbet in your codebase and get stuck dealing with how to
avoid using a particular dynamic constant reference, you might want to ask
someone in <a href="/en/community">the Sorbet community</a> whether they have encountered
the problem before. Members of the Sorbet community frequently answer questions
either on Slack or Stack Overflow.</p>
<p><strong>Why is it this way?</strong> Sorbet has a simple architecture which has been chosen
to optimize for performance in large codebases. Specifically, Sorbet only knows
which method is being called during its inference phase. The inference phase
requires that a complete symbol table (listing all classes, all the methods that
class owns, and all the methods’ types) has been built already. Thus building
this symbol table cannot depend on knowing which methods are defined.</p>
<p>This is also a philosophical belief that Ruby codebases are easier for
programmers to understand when constant references are simple.</p>
<h2><a class="anchor" aria-hidden="true" id="4015"></a><a href="#4015" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4015</h2>
<p>This error usually comes when a class or module is dynamically defined and
stored into a constant, like this:</p>
<pre><code class="hljs css language-ruby">A = ...
A::B = <span class="hljs-number">1</span>
</code></pre>
<p>where <code>...</code> is some expression which computes a class or module. Sorbet can’t
know statically what this <code>...</code> code does (and for example even if could assume
that it’s defining a class, Sorbet can’t know what methods or constants it has).
Therefore, Sorbet does not support this pattern.</p>
<h2><a class="anchor" aria-hidden="true" id="4016"></a><a href="#4016" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4016</h2>
<p><code>type_member</code> and <code>type_template</code> cannot be used at the top-level of a file.
Instead, they must be used inside a class or module definition.</p>
<h2><a class="anchor" aria-hidden="true" id="4019"></a><a href="#4019" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4019</h2>
<p>This error is only reported when running Sorbet with the <code>--stripe-mode</code> command
line flag.</p>
<p>A class defines behavior in multiple files when at least two files would need to
be run in order to completely load that class. A class definition that only
serves as a namespace for inner definitions is not considered to have behavior.
For example, in this example module <code>A</code> has behavior in two files:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- file1.rb --</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># -- file2.rb --</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>However, in this example, module <code>A</code> does not have any behavior:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- file1.rb --</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A::B</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># -- file2.rb --</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A::B</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The limitations around what constitutes “defining behavior” is intertwined with
which files would have to be loaded for a class (like <code>A</code> above) to be fully
loaded. In <code>--stripe-mode</code>, there must be at most one file to require to fully
load a class.</p>
<h2><a class="anchor" aria-hidden="true" id="4021"></a><a href="#4021" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4021</h2>
<p>The syntax for specifying type bounds when using <code>type_member</code> and
<code>type_template</code> has changed. The old syntax looked used a method call with
keyword args:</p>
<pre><code class="hljs css language-ruby">type_member(<span class="hljs-symbol">fixed:</span> ...)
</code></pre>
<p>while the new syntax uses a block that returns a <code>Hash</code> literal:</p>
<pre><code class="hljs css language-ruby">type_member {{<span class="hljs-symbol">fixed:</span> ...}}
</code></pre>
<p>(Note that any variance annotation like <code>:in</code> or <code>:out</code> is still specified as
the first positional argument.)</p>
<p>This new syntax mimics the syntax for <code>T.type_alias</code>, and shares the same
motivation: generics in Sorbet are completely erased at runtime, so it’s silly
to have to pay the runtime price of computing the runtime types passed to
<code>:fixed</code>, <code>:upper</code>, and <code>:lower</code>. In codebases that heavily autoload constants,
it’s also easy for <code>type_member</code> definitions to cause constants to be loaded
earlier than they might have been otherwise (potentially introducing load-time
cyclic references).</p>
<p>The first version of Sorbet on RubyGems to support the new syntax is 0.5.9889.
It accepts both syntaxes side by side, so you can use it while incrementally
migrating your codebase to the new syntax.</p>
<p>This error includes an autocorrect you can run to automatically migrate to the
new syntax:</p>
<pre><code class="hljs">srb tc --isolate-error-code=<span class="hljs-number">4021</span> --<span class="hljs-built_in">auto</span>correct
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5001"></a><a href="#5001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5001</h2>
<p>Sorbet cannot resolve references to dynamic constants. The common case occurs
when a constant is dynamically referenced through the singleton class of <code>self</code>:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCachable</span> &lt; Cachable</span>
  CACHE_KEY_PREFIX = <span class="hljs-string">"my_cachable_"</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cache_key</span></span>
    <span class="hljs-keyword">self</span><span class="hljs-class">.<span class="hljs-keyword">class</span>::<span class="hljs-title">CACHE_KEY_PREFIX</span> + <span class="hljs-title">identifier</span></span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This code can by made statically analysable by using a singleton method to
reference the constant:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCachable</span> &lt; Cachable</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cache_key</span></span>
    <span class="hljs-keyword">self</span><span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">cache_key_prefix</span> + <span class="hljs-title">identifier</span></span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-class"><span class="hljs-keyword">class</span> &lt;&lt; self</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cache_key_prefix</span></span>
      <span class="hljs-string">"my_cachable_"</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5002"></a><a href="#5002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5002</h2>
<p>This means that the typechecker has been unable to resolve a reference to a
constant (e.g., a Ruby class). Most commonly, this indicates that there’s a
typo.</p>
<p>First, try confirming whether the code runs successfully. Does the code raise an
“uninitialized constant” error when run? If so, Sorbet caught a bug! Try finding
out why that constant is actually uninitialized.</p>
<p>If it isn’t a typo, then there are a few other things to look at. If it looks
like the constant is related to a gem, maybe one of these helps:</p>
<ul>
<li><p>Is it coming from a gem? Sorbet does not look through the gem’s source code.
Instead, there must be an <code>*.rbi</code> file for this gem. Try finding the <code>*.rbi</code>
corresponding to this gem, and searching through it for the constant.</p>
<p>For more information, see <a href="/docs/rbi">RBI files</a>. If you are at Stripe, please
instead see <a href="http://go/types/rbi">http://go/types/rbi</a>.</p></li>
<li><p>If the gem was recently updated, its <code>*.rbi</code> might need to be regenerated.
Each RBI file has a line at the top which can be copy / pasted to re-generate
the file when the underlying gem has changed.</p></li>
<li><p>When deleting constants, sometimes they are still referenced from an
autogenerated <code>*.rbi</code> file. If that’s the case, consider deleting the constant
or regenerating the file.</p></li>
</ul>
<p>Another thing it could be: Sorbet explicitly does not support resolving
constants through ancestors (both mixins or superclasses).</p>
<p>Concretely, here’s an example of code rejected and accepted by Sorbet:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  MY_CONST = <span class="hljs-number">91</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent;</span> <span class="hljs-keyword">end</span>

Child::MY_CONST    <span class="hljs-comment"># error</span>
Parent::MY_CONST   <span class="hljs-comment"># ok</span>
</code></pre>
<p>Alternatively, if it’s much more preferable to access the constant on the child,
we can set up an explicit alias:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  MY_CONST = <span class="hljs-number">91</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  MY_CONST = Parent::MY_CONST
<span class="hljs-keyword">end</span>

Child::MY_CONST    <span class="hljs-comment"># ok</span>
Parent::MY_CONST   <span class="hljs-comment"># ok</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5003"></a><a href="#5003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5003</h2>
<p>Sorbet failed to parse a method signature. For more documentation on valid <code>sig</code>
syntax, see <a href="/docs/sigs">Method Signatures</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5004"></a><a href="#5004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5004</h2>
<p>Sorbet failed to parse a Ruby expression as a valid Sorbet type annotation.
Sorbet supports many type annotations—use the sidebar to find relevant docs on
the kinds of valid Sorbet type annotations.</p>
<h2><a class="anchor" aria-hidden="true" id="5005"></a><a href="#5005" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5005</h2>
<p>A class or instance variable is defined in the wrong context.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    @@class_var = T.let(<span class="hljs-number">10</span>, Integer)
    @x = T.let(<span class="hljs-number">10</span>, Integer)
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>
</code></pre>
<p>There are two such errors in the above. In the first, <code>@@class_var</code> is declared
outside of the class scope. In the second, <code>@x</code> is declared outside of the
<code>initialize</code> method.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5006"></a><a href="#5006" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5006</h2>
<p>An instance variable has been redeclared with another type.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>
    @x = T.let(<span class="hljs-number">10</span>, Integer)
    @x = T.let(<span class="hljs-string">"x"</span>, String)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5008"></a><a href="#5008" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5008</h2>
<p>A class was defined as the subclass of a <code>type_alias</code>. It also occurs if a
<code>type_alias</code> mixin is used in a class.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
A = T.type_alias {Integer}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &lt; A;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error: Superclasses and mixins may not be type aliases</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">M</span>;</span> <span class="hljs-keyword">end</span>

AliasModule = T.type_alias {M}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  <span class="hljs-keyword">include</span> AliasModule <span class="hljs-comment"># error: Superclasses and mixins may not be type aliases</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5011"></a><a href="#5011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5011</h2>
<p>A class inherits from itself either directly or through an inheritance chain.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &lt; A;</span> <span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> &lt; C;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt; B;</span> <span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5012"></a><a href="#5012" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5012</h2>
<p>A class was changed to inherit from a different superclass.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt; A;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> &lt; B;</span> <span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5013"></a><a href="#5013" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5013</h2>
<p>A class or instance variable declaration used <code>T.cast</code> when it should use
<code>T.let</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  @@x = T.cast(<span class="hljs-number">10</span>, Integer)
<span class="hljs-keyword">end</span>
</code></pre>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<p>To instead use <code>T.cast</code> as a runtime-only type check (that is, neither as a
statically-checked assertion nor as an instance variable declaration), assign
the cast result to an intermediate variable:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  x = T.cast(<span class="hljs-number">10</span>, Integer)
  @@x = x
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5014"></a><a href="#5014" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5014</h2>
<p>Given code like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  extend T::Generic
  Foo = type_member
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  extend T::Generic
<span class="hljs-keyword">end</span>
</code></pre>
<p>We need to change our code to redeclare the type member in the child class too:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  extend T::Generic
  Foo = type_member
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  extend T::Generic
  Foo = type_member
<span class="hljs-keyword">end</span>
</code></pre>
<p>The same thing holds for type templates.</p>
<h2><a class="anchor" aria-hidden="true" id="5015"></a><a href="#5015" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5015</h2>
<p><a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">Variance</a>
is a type system concept that controls how generics interact with subtyping.</p>
<p>If a <code>type_member</code> is declared as covariant (<code>:out</code>) in a parent class or
module, it must be declared as either covariant or invariant in any children of
that class or module. (A <code>type_member</code> with no variance annotation is
invariant.)</p>
<p>Similarly if a <code>type_member</code> is declared as contravariant (<code>:in</code>) in a parent
class or module, it must be declared as either contravariant or invariant in any
children.</p>
<p>To see why, consider this example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Parent</span></span>
  extend T::Generic
  X = type_member(<span class="hljs-symbol">:out</span>)
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Child</span></span>
  extend T::Generic
  <span class="hljs-keyword">include</span> Parent

  X = type_member(<span class="hljs-symbol">:in</span>) <span class="hljs-comment"># error: variance mismatch</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>If Sorbet were to allow this, Sorbet would fail to catch type errors that it
would need to be able to catch. To see why, consider this chain of <code>T.let</code>
statements, all of which have no error:</p>
<pre><code class="hljs css language-ruby">x1 = Child[T.any(String, Symbol)].new

<span class="hljs-comment"># `Child::X` is contravariant, so "String &lt;: T.any(String, Symbol)"</span>
<span class="hljs-comment"># implies "Child[T.any(String, Symbol)] &lt;: Child[String]"</span>
x2 = T.let(x1, Child[String])

<span class="hljs-comment"># `String` is equivalent to `String`, so Child[String] &lt;: Parent[String]</span>
x3 = T.let(x2, Parent[String])

<span class="hljs-comment"># `Parent::X` is covariant, so "String &lt;: T.any(String, Integer)"</span>
<span class="hljs-comment"># implies "Parent[String] &lt;: Parent[T.any(String, Integer)]"</span>
x4 = T.let(x3, Parent[T.any(Integer, String)])
</code></pre>
<p>Given the above definitions, with <code>Parent::X</code> being covariant and <code>Child::X</code>
being contravariant, each subsequent <code>T.let</code> checks out, with the reasons being
specified.</p>
<p>But that’s a contradiction! We were able to make a conclusion that we know is
false. If we had jumped straight from where we started to where we finished,
Sorbet would report an error:</p>
<pre><code class="hljs css language-ruby">y1 = Child[T.any(String, Symbol)].new
T.let(y1, Parent[T.any(Integer, String)])
<span class="hljs-comment">#     ^^ error: Argument does not have asserted type</span>
</code></pre>
<p>This is because <code>T.any(Integer, String)</code> is neither a subtype nor a supertype of
<code>T.any(Symbol, String)</code>, the types are completely incompatible.</p>
<p>To avoid introducing contradictions like this into the type system, Sorbet
requires that the variance on parent and child classes matches.</p>
<p><a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0Amodule%20Parent%0A%20%20extend%20T%3A%3AGeneric%0A%20%20X%20%3D%20type_member%28%3Aout%29%0Aend%0A%0Amodule%20Child%0A%20%20extend%20T%3A%3AGeneric%0A%20%20include%20Parent%0A%0A%20%20X%20%3D%20type_member%28%3Ain%29%0Aend%0A%0Ax1%20%3D%20Child%5BT.any%28String%2C%20Symbol%29%5D.new%0A%0A%23%20%60Child%3A%3AX%60%20is%20contravariant%2C%20so%20%22String%20%3C%3A%20T.any%28String%2C%20Symbol%29%22%0A%23%20implies%20%22Child%5BT.any%28String%2C%20Symbol%29%5D%20%3C%3A%20Child%5BString%5D%22%0Ax2%20%3D%20T.let%28x1%2C%20Child%5BString%5D%29%0A%0A%23%20%60String%60%20is%20equivalent%20to%20%60String%60%2C%20so%20Child%5BString%5D%20%3C%3A%20Parent%5BString%5D%0Ax3%20%3D%20T.let%28x2%2C%20Parent%5BString%5D%29%0A%0A%23%20%60Parent%3A%3AX%60%20is%20covariant%2C%20so%20%22String%20%3C%3A%20T.any%28String%2C%20Integer%29%22%0A%23%20implies%20%22Parent%5BString%5D%20%3C%3A%20Parent%5BT.any%28String%2C%20Integer%29%5D%22%0Ax4%20%3D%20T.let%28x3%2C%20Parent%5BT.any%28Integer%2C%20String%29%5D%29%0A%0Ay1%20%3D%20Child%5BT.any%28String%2C%20Symbol%29%5D.new%0AT.let%28y1%2C%20Parent%5BT.any%28Integer%2C%20String%29%5D%29">→ View full example on sorbet.run</a></p>
<h2><a class="anchor" aria-hidden="true" id="5016"></a><a href="#5016" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5016</h2>
<p>Sorbet does not allow classes to be covariant nor contravariant.</p>
<p><strong>Why?</strong> The design of generic classes and interfaces in Sorbet was heavily
inspired by the design of C#. This exact question has been answered for C# by
Eric Lippert, who worked on the design and implementation of C# for many years.</p>
<p>→
<a href="https://stackoverflow.com/questions/2733346/why-isnt-there-generic-variance-for-classes-in-c-sharp-4-0/2734070#2734070">Why isn’t there variance for generic classes?</a></p>
<p>The answer concludes that the main selling point of having covariant classes is
to make immutable generic classes, at the cost of a more complex implementation
of generics.</p>
<h2><a class="anchor" aria-hidden="true" id="5017"></a><a href="#5017" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5017</h2>
<p>The <code>type_member</code> and <code>type_template</code> declarations from a parent class must all
be repeated in the same order in a child class (and before any newly-added type
members belonging only to the child class).</p>
<p>One non-obvious way this error can manifest is via code generation tooling. If a
tool attempts to generate <code>type_member</code> declarations using runtime reflection,
but does them out of order, that will confuse Sorbet. Ask the owner of the code
generator for help resolving the problem.</p>
<h2><a class="anchor" aria-hidden="true" id="5018"></a><a href="#5018" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5018</h2>
<p>A child class defined a normal constant with a name that was already in use as a
<code>type_member</code> in the parent class. For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  extend T::Generic

  X = type_member
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  X = <span class="hljs-number">0</span> <span class="hljs-comment"># error!</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this example, since <code>X</code> is declared as a <code>type_member</code> in the parent, it must
also be declared as a <code>type_member</code> in the child, and cannot be changed to some
other kind of constant in the child.</p>
<h2><a class="anchor" aria-hidden="true" id="5019"></a><a href="#5019" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5019</h2>
<p>Abstract methods must not have bodies. For more information, see
<a href="/docs/abstract">Abstract Classes and Interfaces</a>. Despite these methods not having
a body, Sorbet’s <a href="/docs/runtime">runtime support</a> via the <code>sorbet-runtime</code> gem will
convert these methods to raise. For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">IService</span></span>
  extend T::Sig
  extend T::Helpers
  interface!

  sig {abstract.returns(String)}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">port</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyService</span></span>
  <span class="hljs-keyword">include</span> IService
  <span class="hljs-comment"># For sake of example, let's "forget" to implement `port`</span>
  <span class="hljs-comment"># (Sorbet would report a static error here)</span>
<span class="hljs-keyword">end</span>

MyService.new.port <span class="hljs-comment"># raises an exception at runtime:</span>

<span class="hljs-comment"># example.rb:16:</span>
<span class="hljs-comment">#   The method `port` on `IService` is declared as `abstract`.</span>
<span class="hljs-comment">#   It does not have an implementation.</span>
</code></pre>
<p>So you do not need to manually insert a <code>raise</code> inside the body of an abstract
method.</p>
<p>If you would like to define a method in an abstract class or interface with a
default implementation, use the <code>overridable</code> annotation on the signature:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractService</span></span>
  extend T::Sig

  <span class="hljs-comment"># Default port of 8080, but can be overridden in the child class.</span>
  sig {overridable.returns(String)}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">port</span>;</span> <span class="hljs-string">'8080'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5020"></a><a href="#5020" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5020</h2>
<p>There are a few constraints around how methods like <code>include</code>, <code>extend</code>,
<code>mixes_in_class_methods</code> <a href="/docs/abstractd">(docs)</a>, and <code>requires_ancestor</code>
<a href="/docs/requires-ancestor">(docs)</a> work.</p>
<ul>
<li><code>include</code> and <code>extend</code> must be given a constant that Sorbet can <em>statically</em>
see resolve to a <code>module</code>. If a codebase is using metaprogramming to define
constants that are later mixed with these methods, the codebase must either:
<ul>
<li>Ensure that all relevant <code>include</code> and <code>extend</code> targets are statically
defined in <code>*.rb</code> or <code>*.rbi</code> files that are not being ignored, or</li>
<li>Hide the <code>include</code> or <code>extend</code> invocations from Sorbet by using
<a href="/docs/static"><code># typed: ignore</code> sigils</a> to ignore the entire file, or</li>
<li>Hide only the individual call from Sorbet statically using something like
<code>send(:include, ...)</code>.</li>
</ul></li>
<li><code>mixes_in_class_methods</code> and <code>requires_ancestor</code> must only be declared in a
<code>module</code>, not a <code>class</code>. Classes are never mixed into other classes or
modules, so these methods would have no meaning in a class.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="5021"></a><a href="#5021" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5021</h2>
<p>Sorbet requires that classes or modules which define <code>abstract</code> methods are also
marked as abstract using either <code>abstract!</code> or <code>interface!</code>.</p>
<p>For more information, see <a href="/docs/abstract">Abstract Classes and Interfaces</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5022"></a><a href="#5022" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5022</h2>
<p>Sorbet requires that modules marked <code>interface!</code> must only have abstract
methods. To have a module with some abstract methods and some implemented
methods, use <code>abstract!</code> in the module instead.</p>
<p>Apart from this error message, there is otherwise essentially no difference
between abstract modules and interface modules. <code>interface!</code> is provided mostly
as a way for the author of a piece of code to declare intent to the reader more
than anything else.</p>
<h2><a class="anchor" aria-hidden="true" id="5023"></a><a href="#5023" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5023</h2>
<p>Some modules require specific functionality in the receiving class to work. For
example <code>Enumerable</code> needs a <code>each</code> method in the target class.</p>
<p>Failing example in
<a href="https://sorbet.run/#class%20Example%0A%20%20include%20Enumerable%0Aend">sorbet.run</a>:</p>
<pre><code class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span>
  <span class="hljs-symbol">include</span> <span class="hljs-symbol">Enumerable</span>
<span class="hljs-symbol">end</span>
</code></pre>
<p>To fix this, implement the required abstract methods in your class to provide
the required functionality.</p>
<p>Passing example in
<a href="https://sorbet.run/#class%20Example%0A%20%20include%20Enumerable%0A%0A%20%20def%20each(%2526blk)%0A%0A%20%20end%0Aend">sorbet.run</a>:</p>
<pre><code class="hljs"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span>
  <span class="hljs-symbol">include</span> <span class="hljs-symbol">Enumerable</span>

  <span class="hljs-symbol">def</span> <span class="hljs-symbol">each</span>(&amp;<span class="hljs-symbol">blk</span>)
  <span class="hljs-symbol">end</span>
<span class="hljs-symbol">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5024"></a><a href="#5024" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5024</h2>
<p>This error usually happens when attempting to define a cyclic type alias:</p>
<pre><code class="hljs css language-ruby">X = T.type_alias {X} <span class="hljs-comment"># error: Unable to resolve right hand side of type alias</span>
</code></pre>
<p>Note that Sorbet does not support making recursive type aliases. To make a
recursively-defined data structure, see
<a href="/docs/sealed#approximating-algebraic-data-types">Approximating algebraic data types</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5025"></a><a href="#5025" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5025</h2>
<p>Sorbet does not currently support type aliases in generic classes.</p>
<p>This limitation was crafted early in the development of Sorbet to entirely
sidestep problems that can arise in the design of a type system leading to
unsoundness. (Sorbet users curious about type system design may wish to read
<a href="https://lptk.github.io/programming/2019/09/13/type-projection.html">What is Type Projection in Scala, and Why is it Unsound?</a>.)</p>
<p>We are likely to reconsider lifting this limitation in the future, but have no
immediate plans yet.</p>
<p>As a workaround, define type aliases somewhere else. Unfortunately this does
mean it is not currently possible to define type aliases that reference type
members defined by a generic class.</p>
<h2><a class="anchor" aria-hidden="true" id="5026"></a><a href="#5026" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5026</h2>
<p>Various classes in the standard library have been defined as generic classes
retroactively, not via Sorbet’s built-in support for generics. Sorbet’s usual
mechanism for defining custom generic classes is to define the <code>[]</code> method on
the generic class’s singleton class, so that syntax like
<code>MyGenericClass[Integer]</code> is valid code at runtime.</p>
<p>However for various stdlib generic classes, this syntax is already taken. For
example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># BAD EXAMPLE</span>

Array[Integer]
<span class="hljs-comment"># =&gt; evaluates at runtime to `[Integer]`</span>
<span class="hljs-comment"># (i.e. a list with one element: the `Integer` class object)</span>
</code></pre>
<p>To use these standard library classes in type annotations, prefix the generic
class’s name with <code>T::</code>, like this:</p>
<pre><code class="hljs css language-ruby">sig {returns(T::Array[Integer])}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> [<span class="hljs-number">0</span>]; <span class="hljs-keyword">end</span>
</code></pre>
<p>For more information, see
<a href="/docs/stdlib-generics">Arrays, Hashes, and Generics in the Standard Library</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5028"></a><a href="#5028" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5028</h2>
<p>In <code># typed: strict</code> files, Sorbet requires that all constants are annotated
with a <code>T.let</code>.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<p>See also: <a href="#6002">6002</a>, <a href="#7017">7017</a>, <a href="#7027">7027</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5030"></a><a href="#5030" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5030</h2>
<p>A constant cannot store a reference to itself, like this:</p>
<pre><code class="hljs css language-ruby">X = X
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5031"></a><a href="#5031" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5031</h2>
<p>Constants are not allowed to resolve through type aliases. For example, this is
an error:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  X = <span class="hljs-number">0</span>
<span class="hljs-keyword">end</span>

AliasToA = T.type_alias {A}

AliasToA::X <span class="hljs-comment"># error: not allowed</span>
</code></pre>
<p><strong>Why</strong>? A number of reasons:</p>
<ul>
<li><p>Type aliases do not always store references to plain classes. For example,
sometimes type aliases store references to types like <code>T.nilable(A)</code>. Sorbet
doesn’t allow resolving constants through type aliases for the same reason
that it doesn’t allow writing <code>T.nilable(A)::X</code>.</p></li>
<li><p>The runtime representation of type aliases do not behave like constants at
runtime, so <code>AliasToA::X</code> would not actually resolve to <code>A::X</code> at runtime.</p></li>
</ul>
<p>If the type alias is merely an alternate name for an existing constant, use a
class alias not a type alias:</p>
<pre><code class="hljs css language-ruby">AliasToA = A
AliasToA::A <span class="hljs-comment"># allowed</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5032"></a><a href="#5032" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5032</h2>
<p>See the docs for error code <a href="#5020">5020</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5033"></a><a href="#5033" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5033</h2>
<p>Final methods cannot be overridden by definition. See
<a href="/docs/final">Final Methods, Classes, and Modules</a> for more information.</p>
<p>The error code 5033 is raised only statically, but it is worth noting that
attempting to the override of a final method statically but still have the
method overridden at runtime will not work—Sorbet’s runtime support for <code>final</code>
methods prevents methods from being overridden at runtime as well. This is
intentional. Final methods cannot even be overridden or redefined by mocks or
stubs in a test suite.</p>
<h2><a class="anchor" aria-hidden="true" id="5034"></a><a href="#5034" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5034</h2>
<p>Sorbet does not support creating normal Ruby constant aliases to type aliases.
Once a type alias is created, all subsequent aliases must also be type aliases.</p>
<p>Concretely, this is not allowed:</p>
<pre><code class="hljs css language-ruby">A = T.type_alias {Integer}
B = A <span class="hljs-comment"># error: Reassigning a type alias is not allowed</span>
</code></pre>
<p>while this is:</p>
<pre><code class="hljs css language-ruby">A = T.type_alias {Integer}
B = T.type_alias {A}
</code></pre>
<p>(Why? This is due to design tradeoffs to enforce stronger internal invariants.
Basically, Sorbet can emit more reliable warnings when users declare their
intent to create a new type alias.)</p>
<h2><a class="anchor" aria-hidden="true" id="5035"></a><a href="#5035" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5035</h2>
<p>A method was marked <code>override</code>, but sorbet was unable to find a method in the
class’s ancestors that would be overridden. Ensure that the method being
overridden exists in the ancestors of the class defining the <code>override</code> method,
or remove <code>override</code> from the signature that’s raising the error. See
<a href="/docs/override-checking">Override Checking</a> for more information about <code>override</code>.</p>
<p>If the parent method definitely exists at runtime, it might be hidden in a
<a href="static#file-level-granularity-strictness-levels"><code># typed: ignore</code></a> file.
Sorbet will not see it and this error will be raised. In that case you will need
to either raise the <code>typed</code> sigil of that file above <code>ignore</code>, or generate an
<a href="rbi">RBI file</a> that contains signatures for the classes and methods that file
defines.</p>
<h2><a class="anchor" aria-hidden="true" id="5036"></a><a href="#5036" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5036</h2>
<p>See <a href="#5014">5014</a>. 5036 is the same error as <a href="#5014">5014</a> but slightly modified
to allow more common Ruby idioms to pass by in <code># typed: true</code> (5036 is only
reported in <code># typed: strict</code>).</p>
<h2><a class="anchor" aria-hidden="true" id="5037"></a><a href="#5037" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5037</h2>
<p>Sorbet must be able to statically resolve a method to create an alias to it.</p>
<p>Here, the method is created through a DSL called <code>data_accessor</code> which defines
methods at runtime through meta-programming:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">data_accessor</span><span class="hljs-params">(key)</span></span>
    define_method(key) <span class="hljs-keyword">do</span>
      data[key]
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &lt; Base</span>
  data_accessor <span class="hljs-symbol">:foo</span>

  alias_method <span class="hljs-symbol">:bar</span>, <span class="hljs-symbol">:foo</span> <span class="hljs-comment"># error: Can't make method alias from `bar` to non existing method `foo`</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>One way to make those methods visible statically is to add a declaration for
them in an <a href="https://sorbet.org/docs/rbi">RBI file</a>. For example, we can write
our definitions as RBI under <code>sorbet/rbi/shims/foo.rbi</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># sorbet/rbi/shims/foo.rbi</span>
<span class="hljs-comment"># typed: true</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Sometimes, Sorbet will complain about an alias to a method coming from an
included modules. For example, here <code>bar</code> is coming from the inclusion of <code>Bar</code>
but Sorbet will complain about the method not existing anyway:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Bar</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-keyword">include</span> Bar

  alias_method <span class="hljs-symbol">:foo</span>, <span class="hljs-symbol">:bar</span> <span class="hljs-comment"># error: Can't make method alias from `foo` to non existing method `bar`</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>It’s because Sorbet resolves method aliases before it resolves includes. You can
see an example of this behaviour
<a href="https://sorbet.run/#%23%20typed%3A%20true%0A%0Amodule%20Bar%0A%20%20def%20bar%3B%20end%0Aend%0A%0Amodule%20Foo%0A%20%20include%20Bar%0A%0A%20%20alias_method%20%3Afoo%2C%20%3Abar%20%23%20aliases%20are%20resolved%20before%20includes%2C%20so%20%60bar%60%20is%20not%20found%20yet%0A%0A%20%20def%20baz%0A%20%20%20%20bar%20%23%20includes%20are%20resolved%20when%20we%20analyze%20this%20code%0A%20%20end%0Aend">here</a>.
To workaround this limitation, we can replace the <code>alias_method</code> by a real
method definition:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-keyword">include</span> Bar

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    bar
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5038"></a><a href="#5038" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5038</h2>
<p>When Sorbet detects that a file is using <code>sig</code> syntax for methods, it requires
an explicit <code># typed:</code> sigil. The default <code># typed:</code> sigil in Sorbet is
<code># typed: false</code>, so if you would like to add signatures in a method but change
nothing else about how Sorbet checks your codebase, add <code># typed: false</code> to the
top of the file.</p>
<p>However, note that Sorbet will not check the method body’s implementation
against the signature at <code># typed: false</code>. When you see this error, it’s
<strong>strongly recommended</strong> that you additionally upgrade the file to at least
<code># typed: true</code>.</p>
<p>Regardless of whether the file where this error was reported is <code># typed: false</code>
or <code># typed: true</code>, all other <code># typed: true</code> files in the codebase where Sorbet
detects a call to this method will still be checked against this method’s
signature.</p>
<p>To summarize:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- a.rb --</span>
<span class="hljs-comment"># typed: false</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig
  sig {params(<span class="hljs-symbol">x:</span> Integer).returns(String)}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">int_to_string</span><span class="hljs-params">(x)</span></span>
    x <span class="hljs-comment"># no static error!</span>
      <span class="hljs-comment"># (this file is `# typed: false`)</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># -- b.rb --</span>
<span class="hljs-comment"># typed: true</span>

a = A.new
res = a.int_to_string(<span class="hljs-string">'not an int'</span>) <span class="hljs-comment"># error: Expected `Integer` but got `String`</span>

res + <span class="hljs-number">1</span> <span class="hljs-comment"># error: Expected `String` but found `Integer`</span>
</code></pre>
<p>For more information on these typedness levels, see
<a href="/docs/static">Enabling Static Checks</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5039"></a><a href="#5039" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5039</h2>
<p>Sorbet relies on running inference in a method to be able to reveal the type of
an expression with <code>T.reveal_type</code>. For performance reasons, Sorbet skips
running inference in any file that is <code># typed: false</code>, because none of the
other inference-related errors will be reported at that typedness level.</p>
<p>To use <code>T.reveal_type</code> in a file, upgrade the file to <code># typed: true</code> or above.</p>
<p>For more information on typedness levels, see
<a href="/docs/static">Enabling Static Checks</a>.<br>
For more information on <code>T.reveal_type</code>, see <a href="/docs/troubleshooting">Troubleshooting</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5040"></a><a href="#5040" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5040</h2>
<p>Overloading a method (by providing multiple signatures for the method) is only
allowed for methods defined in the Ruby standard library. The definitions for
the Ruby standard library live inside Sorbet’s textual and binary payload, and
cannot be updated by Sorbet end-users except by sending a pull request to Sorbet
(see
<a href="/docs/faq#it-looks-like-sorbets-types-for-the-stdlib-are-wrong">this FAQ entry for more</a>).</p>
<p>Note that even within the type definitions for the Ruby standard library,
overloads in Sorbet come with substantial and somewhat fundamental limitations.</p>
<p>When attempting to define methods that would require overloading to properly
type them, users are strongly recommended to instead define multiple separate
methods. For example, instead of defining a method like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># BAD example, will not typecheck</span>

sig {params(<span class="hljs-symbol">idx:</span> Integer, <span class="hljs-symbol">raise_if_not_found:</span> TrueClass).returns(String)}
sig {params(<span class="hljs-symbol">idx:</span> Integer).returns(T.nilable(String))}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_element</span><span class="hljs-params">(idx, raise_if_not_found)</span></span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This attempts to define a <code>get_element</code> method that normally returns
<code>T.nilable(String)</code> when called like <code>get_element(0)</code>, but will instead always
return <code>String</code> or raise an exception if called like <code>get_element(0, true)</code>.</p>
<p>The idea is that these are conceptually two different methods, which is the
suggestion for how to refactor the code:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">idx:</span> Integer).returns(T.nilable(String))}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_element</span><span class="hljs-params">(idx)</span></span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>

sig {params(idx).returns(String)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_element_or_raise</span><span class="hljs-params">(idx)</span></span>
  elem = get_element(idx)
  <span class="hljs-keyword">case</span> elem
  <span class="hljs-keyword">when</span> NilClass <span class="hljs-keyword">then</span> raise <span class="hljs-string">"No element found at index <span class="hljs-subst">#{idx}</span>"</span>
  <span class="hljs-keyword">else</span> elem
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>We recommend such a refactoring even when attempting to write sigs for methods
defined in gems outside the standard library.</p>
<p>If this workaround will not work in your case, the final alternative is to
either omit a signature for the method in question (or define an explicit
signature where all parameters that cannot be typed accurately use <code>T.untyped</code>).</p>
<p><strong>Why are overloads not well-supported in Sorbet?</strong></p>
<p>Consider how overloading works in typed, compiled languages like C++ or Java;
each overload is a separate method. They actually have separate implementations,
are type checked separately, compile (with link-time name mangling) to separate
symbols in the compiled object, and the compiler knows how to resolve each call
site to a specific overload ahead of time, either statically or dynamically via
virtual dispatch.</p>
<p>Meanwhile, Ruby itself doesn’t have overloading—there’s only ever one method
registered with a given name in the VM, regardless of what arguments it accepts.
That complicates things. It becomes unclear how Sorbet should typecheck the body
of the method (against all sigs? against one sig? against the component-wise
union of their arguments?). There’s no clear answer, and anything we choose will
be bound to confuse or surprise someone.</p>
<p>Also because Sorbet doesn’t control whether the method can be dispatched to,
even if it were going to make a static claim about whether the code type checks,
it doesn’t get to control which (fake) overload will get dispatched to at the
call site (again: there’s only one version of the method in the VM).</p>
<p>Finally this choice is somewhat philosophical: codebases that make heavy use of
overloading (even in typed languages where overloading is supported) tend to be
harder for readers to understand at a glance. The above workaround of defining
multiple methods with unique names solves this readability problem, because now
each overload has a descriptive name.</p>
<h2><a class="anchor" aria-hidden="true" id="5041"></a><a href="#5041" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5041</h2>
<p>See <a href="/docs/tstruct#structs-and-inheritance">T::Struct: Structs and inheritance</a> for
more information.</p>
<h2><a class="anchor" aria-hidden="true" id="5042"></a><a href="#5042" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5042</h2>
<p>Sorbet does not allow defining a <code>private</code> method in an <code>interface!</code>. Note that
this limitation is lifted if the <code>module</code> is declared <code>abstract!</code> not
<code>interface</code>.</p>
<p>The justification for why this is an error has been lost to the sands of time.
It seems reasonable to implement support for this.</p>
<p><a href="https://github.com/sorbet/sorbet/issues/5687">https://github.com/sorbet/sorbet/issues/5687</a></p>
<h2><a class="anchor" aria-hidden="true" id="5043"></a><a href="#5043" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5043</h2>
<p>The syntax for declaring type aliases has changed. What used to be written like
this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># BAD</span>
X = T.type_alias(Integer)
</code></pre>
<p>must now be written like this, with a block argument instead of a positional
argument:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># GOOD</span>
X = T.type_alias {Integer}
</code></pre>
<p>The new syntax avoids incurring eagerly evaluating the right-hand side of the
type alias, potentially forcing one or more constants to be autoloaded before
they would otherwise be required. This improves load-time performance in
lazily-loaded environments (usually: development environments) and also prevents
certain Sorbet usage patterns from introducing load-time cyclic references.</p>
<h2><a class="anchor" aria-hidden="true" id="5044"></a><a href="#5044" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5044</h2>
<p>As background reading, you may first want to read more about variance—see the
docs for error code <a href="#5015">5015</a> and <a href="#5016">5016</a>.</p>
<p>When a type member is declared normally, without any variance annotation, it is
invariant. It can then appear either in the <code>params</code> list or the <code>returns</code> of a
method’s signature, but then prevents using subtyping on that type member. For
example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">IBox</span></span>
  extend T::Generic
  Elem = type_member
<span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">x:</span> IBox[Integer]).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(x)</span></span>
  T.let(x, IBox[T.any(Integer, String)]) <span class="hljs-comment"># error: Argument does not have asserted type</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this example, even though <code>Integer</code> is a subtype of <code>T.any(Integer, String)</code>,
<code>IBox[Integer]</code> is not a subtype of <code>IBox[T.any(Integer, String)]</code> because
<code>Elem</code> has not been declared as <code>:out</code> nor <code>:in</code>, and is thus <strong>invariant</strong>.</p>
<p>To allow code like this, we can declare <code>Elem</code> using <code>:out</code>, but this comes at
the restriction of only being able to use <code>Elem</code> in <strong>out positions</strong>. An out
position is named as such because it’s the position of a method’s output, like a
method signature’s <code>returns</code>, though there are other out positions as well. As
an intuition, all positions in a signature where the value is produced by a
method are out positions. This includes values yielded to lambda functions and
block arguments.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ...</span>

  Elem = type_member(<span class="hljs-symbol">:out</span>)

  sig {abstract.returns(Elem)}
  <span class="hljs-comment">#                     ^^^^ out position</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">value</span>;</span> <span class="hljs-keyword">end</span>

  sig <span class="hljs-keyword">do</span>
    type_parameters(<span class="hljs-symbol">:U</span>)
      .params(
        <span class="hljs-symbol">blk:</span> T.proc.params(<span class="hljs-symbol">val:</span> Elem).returns(T.type_parameter(<span class="hljs-symbol">:U</span>))
      )
      .returns(T.type_parameter(<span class="hljs-symbol">:U</span>))
  <span class="hljs-keyword">end</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">with_value</span><span class="hljs-params">(&amp;blk)</span></span>
    <span class="hljs-keyword">yield</span> value
  <span class="hljs-keyword">end</span>

<span class="hljs-comment"># ...</span>
</code></pre>
<p><a href="https://sorbet.run/#%23%20typed%3A%20strict%0Aextend%20T%3A%3ASig%0A%0Amodule%20IImmutableBox%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20T%3A%3AGeneric%0A%20%20abstract!%0A%0A%20%20Elem%20%3D%20type_member%28%3Aout%29%0A%0A%20%20sig%20%7Babstract.returns%28Elem%29%7D%0A%20%20def%20value%3B%20end%0A%0A%20%20sig%20do%0A%20%20%20%20type_parameters%28%3AU%29%0A%20%20%20%20%20%20.params%28%0A%20%20%20%20%20%20%20%20blk%3A%20T.proc.params%28val%3A%20Elem%29.returns%28T.type_parameter%28%3AU%29%29%0A%20%20%20%20%20%20%29%0A%20%20%20%20%20%20.returns%28T.type_parameter%28%3AU%29%29%0A%20%20end%0A%20%20def%20with_value%28%26blk%29%0A%20%20%20%20yield%20value%0A%20%20end%0Aend%0A%0Aclass%20IBox%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20T%3A%3AGeneric%0A%20%20include%20IImmutableBox%0A%0A%20%20Elem%20%3D%20type_member%0A%0A%20%20sig%20%7Bparams%28value%3A%20Elem%29.void%7D%0A%20%20def%20initialize%28value%29%0A%20%20%20%20%40value%20%3D%20value%0A%20%20end%0A%0A%20%20sig%20%7Boverride.returns%28Elem%29%7D%0A%20%20def%20value%3B%20%40value%3B%20end%0Aend%0A%0Asig%20%7Bparams%28immutable_box%3A%20IImmutableBox%5BInteger%5D%29.void%7D%0Adef%20example%28immutable_box%29%0A%20%20x%20%3D%20immutable_box.value%0A%20%20T.reveal_type%28x%29%0A%0A%20%20immutable_box.with_value%20do%20%7Celem%7C%0A%20%20%20%20T.reveal_type%28elem%29%0A%20%20end%0Aend">→ View full example on sorbet.run</a></p>
<p>The intuition for <strong>in positions</strong> is flipped: they’re all positions that would
correspond to an input to the function, instead of all things that the function
produces. This includes the direct arguments of the method, as well as the
return values of any lambda functions or blocks passed into the method.</p>
<p>If it helps, some type system actually formalize the type of a function as a
generic something like this:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Fn</span></span>
  extend T::Sig
  extend T::Generic
  interface!

  Input = type_member(<span class="hljs-symbol">:in</span>)
  Output = type_member(<span class="hljs-symbol">:out</span>)

  sig {abstract.params(<span class="hljs-symbol">input:</span> Input).returns(Oputput)}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span><span class="hljs-params">(input)</span></span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Recall that only modules (not classes) may have covariant and contravariant type
members—classes are limited to only invariant type members. For more, see the
docs for error code <a href="#5016">5016</a>.</p>
<blockquote>
<p><strong>Note</strong> that <code>T.attached_class</code> is actually modeled as a covariant (<code>:out</code>)
<code>type_template</code> defined automatically on all singleton classes, which means
that <code>T.attached_class</code> can only be used in <code>:out</code> positions.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="5045"></a><a href="#5045" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5045</h2>
<p>This error regards misuse of user-defined generic classes. This error is
reported even at <code># typed: true</code>. Otherwise, the error explanation is the same
as for error code <a href="#5046">5046</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5046"></a><a href="#5046" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5046</h2>
<p>Generic classes must be passed all their generic type arguments when being used
as types. For example:</p>
<pre><code class="hljs css language-ruby">T.let([], Array)              <span class="hljs-comment"># error</span>
T.let([], T::Array[Integer])  <span class="hljs-comment"># ok</span>
</code></pre>
<p>Many classes in the standard library are generic classes
(<a href="/docs/stdlib-generics">see here</a>), and must be passed type arguments, including
<code>Array</code> and <code>Hash</code>. Any user-defined generic classes must similarly be provided
type arguments when used.</p>
<p>For legacy reasons relating to the initial rollout of Sorbet, misuse of generics
defined in the standard library error are only reported at <code># typed: strict</code>,
despite being reported at <code># typed: true</code> for all user-defined generic classes.
(In an ideal world, it would have always been reported at <code># typed: true</code>, and
we might change this in the future.)</p>
<h2><a class="anchor" aria-hidden="true" id="5047"></a><a href="#5047" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5047</h2>
<p>A class or module tried to inherit, include, or extend a final class or module.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Final</span></span>
  extend T::Helpers
  final!
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bad</span> &lt; Final;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5048"></a><a href="#5048" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5048</h2>
<p>A class or module was declared as final, but a method in the class or module was
not explicitly declared as final with a final <code>sig</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>
  extend T::Helpers
  final!

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">no_sig</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>

  extend T::Sig

  sig {void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">non_final_sig</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error</span>

  sig(<span class="hljs-symbol">:final</span>) {void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">final_sig</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># good</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5049"></a><a href="#5049" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5049</h2>
<p>Parameters given type annotations in a method signature must be provided in the
same order they appear in the method definition, even for keyword parameters for
which order would not usually be required. This is for readability and
consistency.</p>
<p>Also, all optional keyword parameters must come after all required keyword
parameters.</p>
<h2><a class="anchor" aria-hidden="true" id="5050"></a><a href="#5050" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5050</h2>
<p>Sealed classes (or modules) can only be inherited (or included/extended) in the
same file as the parent.</p>
<p>For more information, see <a href="/docs/sealed">Sealed Classes</a></p>
<h2><a class="anchor" aria-hidden="true" id="5051"></a><a href="#5051" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5051</h2>
<p>See <a href="/docs/override-checking">Override Checking</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5052"></a><a href="#5052" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5052</h2>
<p>When providing bounds for a type member with <code>lower</code> and <code>upper</code>, the lower type
bound must be a subtype of (or equivalent to) the <code>upper</code> type bound.</p>
<p>Otherwise, it would never be possible to instantiate the generic type because
the bounds would never be satisfiable.</p>
<h2><a class="anchor" aria-hidden="true" id="5053"></a><a href="#5053" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5053</h2>
<p>For classes that subclass generic classes, the child’s lower and upper bound
must still be within the lower and upper bound range specified by the parent
class.</p>
<p>This problem can come up from time to time when the parent class uses <code>fixed</code>
when it meant to use <code>upper</code>. For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntOrStringBox</span></span>
  extend T::Generic
  Elem = type_member {{<span class="hljs-symbol">fixed:</span> T.any(Integer, String)}}
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntBox</span> &lt; IntOrStringBox</span>
  Elem = type_member {{<span class="hljs-symbol">fixed:</span> Integer}} <span class="hljs-comment"># error, incompatible bound</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case we’d like <code>IntBox</code> to be a subclass of <code>IntOrString</code> box, but since
we’re using <code>fixed</code> Sorbet prevents us.</p>
<p>A fix is to use only <code>upper</code> instead:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntOrStringBox</span></span>
  extend T::Generic
  Elem = type_member {{<span class="hljs-symbol">upper:</span> T.any(Integer, String)}}
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntBox</span> &lt; IntOrStringBox</span>
  Elem = type_member {{<span class="hljs-symbol">upper:</span> Integer}}
<span class="hljs-keyword">end</span>
</code></pre>
<p>But this does come at the slight cost that now all type annotations that used to
be using <code>IntOrStringBox</code> without any generic type arguments must now provide
one:</p>
<pre><code class="hljs css language-ruby">T.let(IntBox[Integer].new, IntOrStringBox) <span class="hljs-comment"># error: Generic class without type arguments</span>
</code></pre>
<p>The fix is to change all occurrences of <code>IntOrStringBox</code> without type arguments
to specify <code>IntOrStringBox[T.any(Integer, String)]</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="5054"></a><a href="#5054" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5054</h2>
<p>Use of <code>implementation</code> has been replaced by <code>override</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="5055"></a><a href="#5055" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5055</h2>
<p>Sorbet does not consider a class “fully resolved” until all of its type members
have also been fully resolved. Sorbet cannot fully resolve a type member in a
class until all constants mentioned in its right-hand side have been fully
resolved. So if any of those right-hand-side constants are themselves generic
classes, Sorbet will detect a loop and report this error. Concretely:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig
  extend T::Generic

  X = type_member {{<span class="hljs-symbol">fixed:</span> B}} <span class="hljs-comment"># error: A::X is involved in a cycle</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>
  extend T::Sig
  extend T::Generic

  X = type_member {{<span class="hljs-symbol">fixed:</span> A}} <span class="hljs-comment"># error: B::X is involved in a cycle</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5056"></a><a href="#5056" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5056</h2>
<p>The <code>T.experimental_attached_class</code> syntax has been stabilized and is now
<code>T.attached_class</code>. Use the provided autocorrect to migrate.</p>
<h2><a class="anchor" aria-hidden="true" id="5057"></a><a href="#5057" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5057</h2>
<p>Static methods (like <code>self.foo</code>) can never be mixed into another class or
module. Both <code>include</code> and <code>extend</code> only mix that module’s <em>instance</em> methods
onto the target class or module. Classes can inherit static methods from their
superclass, but only classes (not modules) can be superclasses.</p>
<p>Thus, a static, abstract method on a module is impossible to implement, and thus
is a no-op.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyMixin</span></span>
  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>

  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">self</span>.<span class="hljs-title">bar</span>;</span> <span class="hljs-keyword">end</span> <span class="hljs-comment"># error: Static methods in a module cannot be abstract</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Some alternatives:</p>
<ul>
<li><p>Use <code>mixes_in_class_methods</code>, which declares to Sorbet that when a module is
included, some other module should be extended into the target class.
<a href="/docs/abstract">Full documentation here</a>. This is the preferred option.</p></li>
<li><p>Separate the interface into two modules. Include one and extend the other in
all the places where</p></li>
<li><p>Change the abstract module to an abstract class, and update all downstream
references to inherit from this class instead of including the original
module.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="5058"></a><a href="#5058" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5058</h2>
<p>It’s an error to use <code>T.attached_class</code> to describe the type of method
parameters. See the
<a href="/docs/attached-class#tattached_class-as-an-argument">T.attached_class</a>
documentation for a more thorough description of why this is.</p>
<h2><a class="anchor" aria-hidden="true" id="5059"></a><a href="#5059" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5059</h2>
<p>The syntax for the second argument to <code>T::NonForcingConstants.non_forcing_is_a?</code>
is much more constrained than what Sorbet allows for when resolving arbitrary
constant literals.</p>
<p>For more information, see <a href="/docs/non-forcing-constants">T::NonForcingConstants</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="5060"></a><a href="#5060" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5060</h2>
<p>When applying a type argument to a generic class, the type argument must be
between any <code>lower</code> and <code>upper</code> bound declared by the <code>type_member</code> (or
<code>type_template</code>) declaration for that type parameter.</p>
<h2><a class="anchor" aria-hidden="true" id="5061"></a><a href="#5061" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5061</h2>
<p>A constant was marked private with Ruby’s <code>private_constant</code> method, which means
it’s only valid to access that constant directly, with no constant literal
prefix scope:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  X = <span class="hljs-number">0</span>
  private_constant <span class="hljs-symbol">:X</span>

  X <span class="hljs-comment"># ok</span>

  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Inner</span></span>
    X <span class="hljs-comment"># ok</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

A::X <span class="hljs-comment"># error</span>
</code></pre>
<p>If you must access the private constant, you will have to use <code>.const_get</code> to
both hide the constant access from Sorbet and appease the Ruby VM:</p>
<pre><code class="hljs css language-ruby">A.const_get(<span class="hljs-symbol">:X</span>)
</code></pre>
<p>Note that this technique should be used very sparingly, and many codebases have
lint rules or other coding conventions discouraging or even preventing the use
of <code>const_get</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="5062"></a><a href="#5062" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5062</h2>
<p>Invalid syntax for <code>requires_ancestor</code>. See
<a href="/docs/requires-ancestor">Requiring Ancestors</a> for more information.</p>
<h2><a class="anchor" aria-hidden="true" id="5063"></a><a href="#5063" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5063</h2>
<p>Useless <code>requires_ancestor</code>, because the given class or module is already an
ancestor. See <a href="/docs/requires-ancestor">Requiring Ancestors</a> for more information.</p>
<h2><a class="anchor" aria-hidden="true" id="5064"></a><a href="#5064" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5064</h2>
<p>Using the <code>requires_ancestor</code> method, module <code>Bar</code> has indicated to Sorbet that
it can only work properly if it is explicitly included along module <code>Foo</code>. In
this example, we see that while module <code>Bar</code> is included in <code>MyClass</code>, <code>MyClass</code>
does not include <code>Foo</code>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Bar</span></span>
  extend T::Helpers

  requires_ancestor { Foo }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span></span>
    foo
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-comment"># error: `MyClass` must include `Foo` (required by `Bar`)</span></span>
  <span class="hljs-keyword">include</span> Bar
<span class="hljs-keyword">end</span>
</code></pre>
<p>The solution is to include <code>Foo</code> in <code>MyClass</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span></span>
  <span class="hljs-keyword">include</span> Foo
  <span class="hljs-keyword">include</span> Bar
<span class="hljs-keyword">end</span>
</code></pre>
<p>Other potential (albeit less common) sources of this error code are classes that
are required to have some class as an ancestor:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Bar</span></span>
  extend T::Helpers

  requires_ancestor { Foo }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span></span>
    foo
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySuperClass</span></span>
  extend T::Helpers
  <span class="hljs-keyword">include</span> Bar

  abstract!
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &lt; MySuperClass <span class="hljs-comment"># error: `MyClass` must inherit `Foo` (required by `Bar`)</span></span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Ensuring <code>MyClass</code> inherits from <code>Foo</code> at some point will fix the error:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySuperClass</span> &lt; Foo</span>
  extend T::Helpers
  <span class="hljs-keyword">include</span> Bar

  abstract!
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> &lt; MySuperClass</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="5065"></a><a href="#5065" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5065</h2>
<p>Unsatisfiable <code>requires_ancestor</code>. See
<a href="/docs/requires-ancestor">Requiring Ancestors</a> for more information.</p>
<h2><a class="anchor" aria-hidden="true" id="5067"></a><a href="#5067" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5067</h2>
<p>A class’s superclass (the <code>Parent</code> in <code>class Child &lt; Parent</code>) must be statically
resolvable to a class, not a module.</p>
<h2><a class="anchor" aria-hidden="true" id="5068"></a><a href="#5068" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5068</h2>
<p>Sorbet requires that class or module definitions be namespaced unambiguously.
For example, in this code:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span></span>
  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B::C</span></span>
   <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The definition B::C is ambiguous. In Ruby’s runtime, it resolves to B::C (and
not A::B::C). However, things are different in the presence of a pre-declared
filler namespace like below:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">A</span></span>
  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B::C</span></span>
   <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, the definition resolves to A::B::C in Ruby’s runtime.</p>
<p>By default, Sorbet assumes the presence of filler namespaces while typechecking,
regardless of whether they are explicitly predeclared like in the second
example. This means that in Sorbet’s view, the definition resolves to A::B::C in
either case.</p>
<p>In Stripe’s codebase, this is generally not a problem at runtime, as we use
Sorbet’s own autoloader generation to pre-declare filler namespaces, keeping the
Ruby runtime’s behavior equivalent to Sorbet. However, the autoloader has some
edge cases, which can often cause deviations between Ruby’s runtime and Sorbet.
This error helps guard against these issues.</p>
<h2><a class="anchor" aria-hidden="true" id="5069"></a><a href="#5069" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5069</h2>
<p>There must be exactly one statement in a method signature (possibly a single
chain of methods).</p>
<p>Sorbet used to allow syntax like</p>
<pre><code class="hljs css language-ruby">sig <span class="hljs-keyword">do</span>
  params(<span class="hljs-symbol">x:</span> Integer)
  returns(Integer)
<span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>; x; <span class="hljs-keyword">end</span>
</code></pre>
<p>where the body of the <code>sig</code> block was allowed to have multiple methods not
connected by a method call chain.</p>
<p>Use the provided autocorrect to convert the old syntax to the new syntax.</p>
<h2><a class="anchor" aria-hidden="true" id="5070"></a><a href="#5070" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5070</h2>
<p><code>T.nilable(T.untyped)</code> is just <code>T.untyped</code>, because <code>nil</code> is a valid value of
type <code>T.untyped</code> (along with all other values).</p>
<h2><a class="anchor" aria-hidden="true" id="5071"></a><a href="#5071" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>5071</h2>
<p>Providing a <code>.bind</code> when using <code>T.proc</code> is only valid on a method’s single block
argument (<code>&amp;blk</code>), not on all arguments. The <code>.bind</code> is not actually a type
annotation, but instead an instruction to the type inference algorithm about how
to typecheck the body of the block. Type checking for the body of the block
provided to a method call happens <strong>after</strong> type checking all other arguments,
while type checking for lambda functions and procs passed as positional or
keyword arguments happens <strong>before</strong> the proc value is checked against the
<code>T.proc</code> type. For example:</p>
<pre><code class="hljs css language-ruby">sig <span class="hljs-keyword">do</span>
  params(
    <span class="hljs-symbol">f:</span> T.proc.returns(Integer),
    <span class="hljs-symbol">blk:</span> T.proc.returns(Integer),
  )
  .void
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(f, &amp;blk)</span></span>
<span class="hljs-keyword">end</span>

f = -&gt;() {<span class="hljs-number">0</span>} <span class="hljs-comment"># lambda is type checked here, before running type inference on</span>
             <span class="hljs-comment"># the `example` call below.</span>
example(f) <span class="hljs-keyword">do</span> <span class="hljs-comment"># call to `example` is typechecked next</span>
  <span class="hljs-number">1</span> <span class="hljs-comment"># block body is typechecked last</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Since the definition of the lambda <code>f</code> is typechecked entirely before the call
to <code>example</code> is typechecked, no <code>.bind</code> annotation on any of <code>example</code>'s
positional or keyword arguments would actually affect how the lambda is
typechecked.</p>
<h2><a class="anchor" aria-hidden="true" id="6001"></a><a href="#6001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6001</h2>
<p>Certain Ruby keywords like <code>break</code>, <code>next</code>, and <code>retry</code> can only be used inside
a Ruby block.</p>
<h2><a class="anchor" aria-hidden="true" id="6002"></a><a href="#6002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6002</h2>
<p>In <code># typed: strict</code> files, Sorbet requires that all instance and class
variables are annotated with a <code>T.let</code>.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>.</p>
<p>See also: <a href="#5028">5028</a>, <a href="#7017">7017</a>, <a href="#7028">7028</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="6004"></a><a href="#6004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6004</h2>
<p>In order to statically check <a href="exhaustiveness">exhaustiveness</a>, Sorbet provides
<code>T.absurd</code>, which lets people opt into exhaustiveness checks.</p>
<p><code>T.absurd</code> must be given a variable. If not, like in this example, it reports an
error:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- bad example --</span>

sig {returns(T.any(Integer, String))}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">returns_int_or_string</span>;</span> <span class="hljs-number">0</span>; <span class="hljs-keyword">end</span>

<span class="hljs-keyword">case</span> returns_int_or_string
<span class="hljs-keyword">when</span> Integer <span class="hljs-keyword">then</span> puts <span class="hljs-string">'got int'</span>
<span class="hljs-keyword">when</span> String <span class="hljs-keyword">then</span> puts <span class="hljs-string">'got string'</span>
<span class="hljs-comment"># error! `returns_int_or_string` is not a variable!</span>
<span class="hljs-keyword">else</span> T.absurd(returns_int_or_string)
<span class="hljs-keyword">end</span>
</code></pre>
<p>While it looks like <code>returns_int_or_string</code> is the name of a variable, it’s
actually a method call (Ruby allows method calls to omit parentheses). To fix
this error, store the result of calling <code>returns_int_or_string</code> in a variable,
and use that variable with the <code>case</code> and <code>T.absurd</code>:</p>
<pre><code class="hljs css language-ruby">sig {returns(T.any(Integer, String))}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">returns_int_or_string</span>;</span> <span class="hljs-number">0</span>; <span class="hljs-keyword">end</span>

<span class="hljs-comment"># calls returns_int_or_string, stores result in x</span>
x = returns_int_or_string

<span class="hljs-keyword">case</span> x
<span class="hljs-keyword">when</span> Integer <span class="hljs-keyword">then</span> puts <span class="hljs-string">'got int'</span>
<span class="hljs-keyword">when</span> String <span class="hljs-keyword">then</span> puts <span class="hljs-string">'got string'</span>
<span class="hljs-keyword">else</span> T.absurd(x)
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="6005"></a><a href="#6005" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>6005</h2>
<p><code>T.bind</code> can only be called on <code>self</code>, syntactically.</p>
<p>To perform type assertions on non-<code>self</code> things, use <code>T.let</code> or <code>T.cast</code>.</p>
<p>See <a href="/docs/type-assertions">Type Assertions</a> for more.</p>
<h2><a class="anchor" aria-hidden="true" id="7001"></a><a href="#7001" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7001</h2>
<p>Sorbet does not allow reassigning a variable to a different type within a loop
or block. (Note that we model blocks similarly to loops, as in general they may
execute 0, 1, or more times). Due to implementation constraints, Sorbet does not
permit this behavior.</p>
<p>A prototypical example of code that might trigger this is code that sets a
variable to <code>nil</code>, and then updates it if some value is found inside a loop:</p>
<pre><code class="hljs css language-ruby">found = <span class="hljs-literal">nil</span>

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  found = elem <span class="hljs-keyword">if</span> want?(elem)
<span class="hljs-keyword">end</span>
</code></pre>
<p>In most cases, we can fix this error by declaring the type of the loop variable
outside the loop using <code>T.let</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># This is a type annotation that explicitly widens the type:</span>
found = T.let(<span class="hljs-literal">nil</span>, T.nilable(String))

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  found = elem <span class="hljs-keyword">if</span> want?(elem)
<span class="hljs-keyword">end</span>
</code></pre>
<p><strong>But my variable does not change its type, it is always a <code>Boolean</code>!</strong></p>
<p>In Ruby, there is no <code>Boolean</code> type. Instead, there are <code>FalseClass</code> and
<code>TrueClass</code> types, the union of which defines
<a href="/docs/class-types#booleans"><code>T::Boolean</code> type as a union type</a>.</p>
<p>When Sorbet encounters a variable declaration like <code>x = true</code>, it infers the
type of <code>x</code> as <code>TrueClass</code>. An assignment to <code>x</code> later on in the same block such
as <code>x = false</code> would imply that the variable is reassigned to a different type
(namely, to <code>FalseClass</code> in this case).</p>
<p>For this reason, a loop such as the following triggers an error:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Declares `found_valid` with type `FalseClass`</span>
found_valid = <span class="hljs-literal">false</span>

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  <span class="hljs-comment"># Might change the type of `found_valid` to `TrueClass`</span>
  found_valid = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> valid?(elem) <span class="hljs-comment"># error: Changing the type of a variable in a loop</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The fix, again, is to use <code>T.let</code> to widen the type to <code>T::Boolean</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Declare `found_valid` with type `T::Boolean`</span>
found_valid = T.let(<span class="hljs-literal">false</span>, T::Boolean)

list.each <span class="hljs-keyword">do</span> <span class="hljs-params">|elem|</span>
  <span class="hljs-comment"># Does not change the type of `found_valid`</span>
  found_valid = <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> valid?(elem) <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7002"></a><a href="#7002" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7002</h2>
<p>This is a standard type mismatch. A method’s <code>sig</code> declares one type, but the
actual value didn’t match. For example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-string">'str'</span> + <span class="hljs-symbol">:sym</span>  <span class="hljs-comment"># error: Expected `String` but found `Symbol(:"sym")` for argument `arg0`</span>
</code></pre>
<p>Even still, sometimes these errors can be rather confusing. Consider using
<a href="/docs/troubleshooting"><code>T.reveal_type</code></a> to pin down the origin of why Sorbet
thinks the types are what it says.</p>
<p><strong>Why does Sorbet think this is <code>nil</code>? I just checked that it’s not!</strong></p>
<p>That’s a <a href="flow-sensitive#limitations-of-flow-sensitivity">great question</a>, and
probably the most common question people have when using Sorbet!</p>
<p>It’s answered here:
<a href="flow-sensitive#limitations-of-flow-sensitivity">Limitations of flow-sensitivity</a></p>
<h2><a class="anchor" aria-hidden="true" id="7003"></a><a href="#7003" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7003</h2>
<p>This error indicates a call to a method we believe does not exist (a la Ruby’s
<code>NoMethodError</code> exception). Some steps to debug:</p>
<ol>
<li><p>Double check that the code actually runs, either in the REPL, in CI, or with
manual tests. If the method doesn’t actually exist when run, Sorbet caught a
bug!</p></li>
<li><p>Even if the method exists when run, Sorbet still might report an error
because the method won’t <strong>always</strong> be there. For example, maybe the value
is <a href="/docs/nilable-types">nilable</a>, or we have a <a href="/docs/union-types">union</a> of a
handful of different types.</p></li>
<li><p>Many times, methods are defined dynamically in Ruby. Sorbet cannot see
methods defined with <code>define_method</code>. Sorbet also can’t see methods defined
using Ruby’s <code>included</code> + <code>other.extend(self)</code> pattern. For such dynamically
defined methods, Sorbet requires <code>*.rbi</code> files which define the method
statically.</p>
<p>See the <a href="/docs/rbi">RBI</a> docs for how to regenerate the <code>*.rbi</code> files.</p></li>
<li><p><a class="anchor" aria-hidden="true" id="include-kernel"></a>Sorbet will
complain about this code:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span>;</span> <span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">x:</span> MyModule).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  x.<span class="hljs-literal">nil</span>? <span class="hljs-comment"># error: Method `nil?` does not exist on `MyModule`</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The <code>nil?</code> method is defined on <code>Kernel</code> in Ruby. <code>Kernel</code> is included in
<code>Object</code> (which classes default to inheriting from), but not on
<code>BasicObject</code> (which classes can optionally inherit from).</p>
<p>The solution is to <code>include Kernel</code> in our module:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-keyword">include</span> Kernel
<span class="hljs-keyword">end</span>
</code></pre></li>
<li><p>Sorbet will complain about this code:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> puts <span class="hljs-string">'hello'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>The issue is similar to the above: <code>puts</code> is defined on <code>Kernel</code>, which is
not necessarily included in our module. For this situation, there are
actually two fixes:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Option 1: include Kernel</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-keyword">include</span> Kernel

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> puts <span class="hljs-string">'hello'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># Option 2: Kernel.puts</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> Kernel.puts <span class="hljs-string">'hello'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre></li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="7004"></a><a href="#7004" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7004</h2>
<p>This error indicates that a method has been called with incorrect parameters.
There are a few cases where this can occur:</p>
<ul>
<li>Too many parameters</li>
<li>Not enough parameters</li>
<li>Trying to pass parameters that don’t exist</li>
<li>Missing required parameters</li>
<li>Positional parameters used when the method expects named parameters, and vice
versa</li>
</ul>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-symbol">x:</span> <span class="hljs-literal">nil</span>)</span></span>; <span class="hljs-keyword">end</span>

foo(<span class="hljs-number">1</span>) <span class="hljs-comment"># error</span>
foo(<span class="hljs-symbol">y:</span> <span class="hljs-number">1</span>) <span class="hljs-comment"># error</span>
foo(<span class="hljs-symbol">x:</span> <span class="hljs-number">1</span>) <span class="hljs-comment"># ok</span>
foo() <span class="hljs-comment"># ok</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-symbol">x:</span>)</span></span>; <span class="hljs-keyword">end</span>

bar() <span class="hljs-comment"># error</span>
bar(<span class="hljs-number">1</span>) <span class="hljs-comment"># error</span>
bar(<span class="hljs-symbol">x:</span> <span class="hljs-number">1</span>) <span class="hljs-comment"># ok</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7005"></a><a href="#7005" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7005</h2>
<p>Sorbet detected a mismatch between the declared return type for the method and
the type of the returned value:</p>
<pre><code class="hljs css language-rb">sig { returns(Integer) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">answer</span></span>
  <span class="hljs-string">"42"</span> <span class="hljs-comment"># error: Expected `Integer` but found `String("42")` for method result type</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Here we specified in the signature that <code>find</code> returns an instance of
<code>Configuration</code>, yet the returned value might be <code>nil</code>:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  @lookup[name] <span class="hljs-comment"># error: Expected `Configuration` but found `T.nilable(Configuration)` for method result type</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>A possible solution, if we are <em>certain</em> that <code>name</code> is in the <code>@lookup</code> hash,
is to use <code>T.must</code> when returning the value:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  T.must(@lookup[name])
<span class="hljs-keyword">end</span>
</code></pre>
<p>In some cases, we’re already being cautious and perform some checks before
returning yet Sorbet still complains about the return type:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  raise ArgumentError, <span class="hljs-string">"Configuration <span class="hljs-subst">#{name}</span> not found"</span> <span class="hljs-keyword">unless</span> @lookup.key?(name)
  @lookup[name] <span class="hljs-comment"># error: Expected `Configuration` but found `T.nilable(Configuration)` for method result type</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>While this code is correct, Sorbet cannot assume the state of <code>@lookup</code> didn’t
change between the <code>key?</code> check and the <code>[]</code> read. To fix this, we can take
advantage of flow-typing to make the whole method work without inline type
annotations:</p>
<pre><code class="hljs css language-rb">sig { params(<span class="hljs-symbol">name:</span> String).returns(Configuration) }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(name)</span></span>
  config = @lookup[name]
  raise ArgumentError, <span class="hljs-string">"Configuration <span class="hljs-subst">#{name}</span> not found"</span> <span class="hljs-keyword">unless</span> config
  config
<span class="hljs-keyword">end</span>
</code></pre>
<p>By using a local variable, we allow Sorbet to assert that <code>config</code> is never
nilable past the <code>raise</code> instruction.</p>
<h2><a class="anchor" aria-hidden="true" id="7006"></a><a href="#7006" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7006</h2>
<p>In Sorbet, it is an error to have provably unreachable code. Because Sorbet is
<a href="/docs/flow-sensitive">sensitive to control flow</a> in a program, Sorbet can not only
track what types each variable has within all the branches of a conditional, but
also whether any given branch could be executed at all.</p>
<p>Erroring for dead or unreachable code is generally a way to prevent bugs. People
don’t usually expect that some branch of code is never taken; usually dead code
errors come from simple typos or misunderstandings about how Ruby works. In
particular: the only two “falsy” values in Ruby are <code>nil</code> and <code>false</code>.</p>
<p>Note if you intend for code to be dead because you’ve exhausted all the cases
and are trying to raise in the default case, use <code>T.absurd</code> to assert that a
case analysis is exhaustive. See <a href="/docs/exhaustiveness">Exhaustiveness Checking</a>
for more information.</p>
<p>Sometimes, dead code errors can be hard to track down. The best way to pinpoint
the cause of a dead code error is to wrap variables or expressions in
<code>T.reveal_type(...)</code> to validate the assumptions that a piece of code is making.
For more troubleshooting tips, see <a href="/docs/troubleshooting">Troubleshooting</a>.</p>
<p>If for whatever reason it’s too hard to track down the cause of a dead code
error, it’s possible to silence it by making a variable or expression
“unanalyzable,” aka untyped. (When something is untyped, Sorbet will do very
limited flow-sensitivity analysis compared to if Sorbet knows the type. To make
something unanalyzable, we can wrap it in <code>T.unsafe(...)</code>:</p>
<pre><code class="hljs css language-ruby">x = <span class="hljs-literal">false</span>

<span class="hljs-keyword">if</span> x
  puts <span class="hljs-string">'hello!'</span> <span class="hljs-comment"># error: This code is unreachable</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">if</span> T.unsafe(x)
  puts <span class="hljs-string">'hello!'</span> <span class="hljs-comment"># ok</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this (contrived) example, Sorbet knows statically that <code>x</code> is always <code>false</code>
and so our <code>puts</code> within the first <code>if</code> is never reachable. On the other hand,
Sorbet allows the second <code>if</code> because we’ve explicitly made <code>x</code> unanalyzable
with <code>T.unsafe(...)</code>. T.unsafe is one of a handful of
<a href="/docs/troubleshooting#escape-hatches">escape hatches</a> built into Sorbet.</p>
<h2><a class="anchor" aria-hidden="true" id="7007"></a><a href="#7007" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7007</h2>
<p>Sorbet can statically assert that the value passed into a <code>T.let</code> does not match
the expected type:</p>
<pre><code class="hljs css language-rb">x = T.let(<span class="hljs-number">1</span>, String) <span class="hljs-comment"># error: Argument does not have asserted type `String`</span>
</code></pre>
<p>Because of the way default values are desugared by Sorbet, this error also
occurs when Sorbet finds a mistmatch between the type specified for a parameter
in the signature and the default value provided in the method.</p>
<p>In this case, the signature states that <code>category</code> type is a <code>Category</code>, yet we
try to use <code>nil</code> as default value:</p>
<pre><code class="hljs css language-ruby">sig { params(<span class="hljs-symbol">name:</span> String, <span class="hljs-symbol">category:</span> Category).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">publish_item</span><span class="hljs-params">(name, category = <span class="hljs-literal">nil</span>)</span></span> <span class="hljs-comment"># error: Argument does not have asserted type `Category`</span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>If <code>category</code> value is <code>nil</code> by default, maybe we should make it so its type is
nilable:</p>
<pre><code class="hljs css language-ruby">sig { params(<span class="hljs-symbol">name:</span> String, <span class="hljs-symbol">category:</span> T.nilable(Category)).void }
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">publish_item</span><span class="hljs-params">(name, category = <span class="hljs-literal">nil</span>)</span></span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7009"></a><a href="#7009" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7009</h2>
<p>This error occurs when a value is used in place of a type. There are many
different situations where this can happen; one example is given below:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span></span>
  extend T::Generic

  E = type_member
<span class="hljs-keyword">end</span>

Box[<span class="hljs-literal">true</span>].new <span class="hljs-comment"># error: Unexpected bare `TrueClass` value found in type position</span>
</code></pre>
<p>More generally, Sorbet draws a distinction between places in a program where
Ruby values are allowed, and places where Sorbet type syntax is allowed. For
example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ----- Arbitrary type syntax allowed -----</span>
T.let(<span class="hljs-number">0</span>, T.any(Integer, String))
<span class="hljs-comment">#        ^^^^^^^^^^^^^^^^^^^^^^</span>
sig {returns(T.any(Integer, String))}
<span class="hljs-comment">#            ^^^^^^^^^^^^^^^^^^^^^^</span>
T::Array[T.any(Integer, String)].new
<span class="hljs-comment">#        ^^^^^^^^^^^^^^^^^^^^^^</span>


<span class="hljs-comment"># ----- Arbitrary type syntax NOT allowed -----</span>

<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>
<span class="hljs-keyword">when</span> T.any(Integer, String)
<span class="hljs-comment">#    ^^^^^^^^^^^^^^^^^^^^^^</span>
<span class="hljs-keyword">end</span>

x.is_a?(T.any(Integer, String))
<span class="hljs-comment">#       ^^^^^^^^^^^^^^^^^^^^^^</span>
</code></pre>
<p>Only valid Sorbet types are allowed in type positions. Arbitrary Sorbet types
are not allowed in most places where Ruby expects a normal value.</p>
<blockquote>
<p><strong>Note</strong>: Historically this error message has been one of the more confusing
Sorbet errors, and over time we have added special cases to detect common
points of confusion. If you’re reading this because you found the error
message confusing, please consider sharing your example with the Sorbet team
so we can further improve the error message.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="7010"></a><a href="#7010" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7010</h2>
<p>Sorbet found a reference to a generic type with the wrong number of type
arguments.</p>
<p>Here we defined <code>MyMap</code> as a generic class expecting two type parameters
<code>KeyType</code> and <code>ValueType</code> but we try to instantiate it with only one type
argument:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMap</span></span>
  extend T::Generic

  KeyType = type_member
  ValueType = type_member

  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>

MyMap[String].new <span class="hljs-comment"># error: Wrong number of type parameters for `MyMap`. Expected: `2`, got: `1`</span>
</code></pre>
<p>Unless a type member was <code>fixed</code>, it is always required to pass the correct
amount of type arguments. <code>T.untyped</code> can also be used if the type is not
relevant at this point:</p>
<pre><code class="hljs css language-rb">MyMap[String, Integer].new
MyMap[String, String].new
MyMap[String, T.untyped].new
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7011"></a><a href="#7011" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7011</h2>
<p>Historically, users seeing this error has represented finding a bug in Sorbet
(or at least finding a test case for which there could be a better error
message). Consider searching for similar bugs at
<a href="https://github.com/sorbet/sorbet/issues">https://github.com/sorbet/sorbet/issues</a> or reporting a new one.</p>
<h2><a class="anchor" aria-hidden="true" id="7013"></a><a href="#7013" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7013</h2>
<p>Sorbet detected that an instance variable was reassigned with different types:</p>
<pre><code class="hljs css language-rb"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  extend T::Sig

  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span></span>
    @x = T.let(<span class="hljs-number">0</span>, Integer)
  <span class="hljs-keyword">end</span>

  sig { void }
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>
    @x = <span class="hljs-string">'not an integer'</span> <span class="hljs-comment"># error: Expected `Integer` but found `String("not an integer")` for field</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>If the instance variable can hold both an <code>Integer</code> and a <code>String</code>, maybe the
type specified with <code>T.let</code> should be enlarged:</p>
<pre><code class="hljs css language-ruby">@x = T.let(<span class="hljs-number">0</span>, T.any(Integer, String))
</code></pre>
<p>Similarly, Sorbet will reject constants reassigned with different types:</p>
<pre><code class="hljs css language-rb">FOO = <span class="hljs-number">42</span> <span class="hljs-comment"># error: Expected `String("Hello, world!")` but found `Integer(42)` for field</span>
FOO = <span class="hljs-string">"Hello, world!"</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7014"></a><a href="#7014" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7014</h2>
<p>Sorbet has a special method called <code>T.reveal_type</code> which can be useful for
debugging. <code>T.reveal_type(expr)</code> will report an error in the output of <code>srb tc</code>
that shows what the static component of Sorbet thinks the result type of <code>expr</code>
is.</p>
<p>Making this an error is nice for two reasons:</p>
<ul>
<li><p>It makes our internal implementation easier 😅 We don’t have some special-case
messages and then error messages. The only thing Sorbet prints under normal
circumstances are error messages.</p></li>
<li><p>It serves as a reminder to remove <code>T.reveal_type</code> before committing a change.
Since it’s a proper error, Sorbet will exit with non-zero status until it’s
removed.</p></li>
</ul>
<p>For more information, see <a href="/docs/troubleshooting">Troubleshooting</a>.</p>
<blockquote>
<p>Looking for how to assert that an expression has a certain type? Check out
<a href="/docs/type-assertions">Type Assertions</a>.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="7015"></a><a href="#7015" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7015</h2>
<p>Certain forms of <code>T.let</code>, <code>T.cast</code>, and <code>T.must</code> calls are redundant. Follow the
suggestion in the error message to fix—these errors should have an autocorrect
you can apply to automatically fix the error.</p>
<h2><a class="anchor" aria-hidden="true" id="7016"></a><a href="#7016" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7016</h2>
<p>Sorbet has special handling for certain methods in the standard library, like
<code>Array#flatten</code>. This method takes an optional <code>depth</code> argument, and will only
flatten nested arrays that deep if passed:</p>
<pre><code class="hljs css language-ruby">[[[[<span class="hljs-number">1</span>]]]].flatten(<span class="hljs-number">2</span>)

<span class="hljs-comment"># ERROR</span>
depth = T.let(<span class="hljs-number">2</span>, Integer)
[[[[<span class="hljs-number">1</span>]]]].flatten(depth)
</code></pre>
<p>Unfortunately, Sorbet can only perform this analysis when the depth is static.
If Sorbet cannot see the exact value of the depth and instead only sees a type
of <code>Integer</code> for the depth argument, it reports an error.</p>
<p>Either:</p>
<ol>
<li>Refactor the code so that Sorbet can see the exact depth value, or</li>
<li>Use <code>T.unsafe</code> to hide the method call from Sorbet.</li>
</ol>
<pre><code class="hljs css language-ruby">depth = T.let(<span class="hljs-number">2</span>, Integer)
<span class="hljs-comment"># `T.unsafe` disables static type checking for this call site,</span>
<span class="hljs-comment"># including the flatten depth check</span>
T.unsafe([[[[<span class="hljs-number">1</span>]]]]).flatten(depth)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7017"></a><a href="#7017" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7017</h2>
<p>In typed: strict files, Sorbet requires that all methods are annotated with a
<code>sig</code>. In a <code># typed: true</code> file Sorbet implicitly assumes that definitions
without types are <code>T.untyped</code>, but in a <code># typed: strict</code> file, Sorbet will no
longer make this implicit assumption.</p>
<p>You can still add a <code>sig</code> which declares the arguments or return as <code>T.untyped</code>,
so <code># typed: strict</code> does not outright ban <code>T.untyped</code>. The upside is that usage
of <code>T.untyped</code> is more explicit, which makes it easier to drive the number of
occurrences down. If you’re seeing this warning, there’s no time like the
present to add proper types to your public-facing API (i.e., your top-level
constant and method definitions)!</p>
<p>For how to fix, see <a href="/docs/sigs">Method Signatures</a>.</p>
<p>See also: <a href="#5028">5028</a>, <a href="#6002">6002</a>, <a href="#7028">7028</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="7018"></a><a href="#7018" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7018</h2>
<p>At <code>typed: strong</code>, Sorbet no longer allows <code>T.untyped</code> as the intermediate
result of any method call. This effectively means that Sorbet knew the type
statically for 100% of calls within a file. This sigil is rarely used—usually
the only files that are <code># typed: strong</code> are RBI files and files with empty
class definitions. Most Ruby files that actually do interesting things will have
errors in <code># typed: strong</code>. Support for <code>typed: strong</code> files is minimal, as
Sorbet changes regularly and new features often bring new <code>T.untyped</code>
intermediate values.</p>
<h2><a class="anchor" aria-hidden="true" id="7019"></a><a href="#7019" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7019</h2>
<p>Sorbet does not have great support for splats right now.</p>
<p>In general, when considering taking a variable number of arguments, consider
instead taking a single argument that’s an array instead of a “rest” arg:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ----- AVOID THIS ----------------------------</span>
sig {params(<span class="hljs-symbol">xs:</span> Integer).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*xs)</span></span>; <span class="hljs-keyword">end</span>

xs = Array.new(<span class="hljs-number">3</span>) {<span class="hljs-params">|i|</span> i}
foo(*xs)
<span class="hljs-comment"># ---------------------------------------------</span>

<span class="hljs-comment"># ----- Do this instead -----------------------</span>

sig {params(<span class="hljs-symbol">ys:</span> T::Array[Integer]).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">(ys)</span></span>; <span class="hljs-keyword">end</span>

ys = Array.new(<span class="hljs-number">3</span>) {<span class="hljs-params">|i|</span> i}
bar(ys)
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<p>If it is not possible to refactor the code, the current work around is to use
<code>T.unsafe</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ----- WORST CASE ----------------------------</span>
<span class="hljs-comment"># Prefer the solution described above</span>

sig {params(<span class="hljs-symbol">xs:</span> Integer).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(*xs)</span></span>; <span class="hljs-keyword">end</span>

xs = Array.new(<span class="hljs-number">3</span>) {<span class="hljs-params">|i|</span> i}
T.unsafe(<span class="hljs-keyword">self</span>).foo(xs)
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7020"></a><a href="#7020" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7020</h2>
<p>Note that method-level generics (i.e., those declared by using <code>type_parameters</code>
inside a <code>sig</code>) are a somewhat unstable feature. If you encounter this error and
believe it to represent a bug in Sorbet, first check the
<a href="https://github.com/sorbet/sorbet/issues">Sorbet bug tracker</a> to see if a
similar-looking error has already been reported. If no such bug exists, feel
free to open an issue.</p>
<h2><a class="anchor" aria-hidden="true" id="7021"></a><a href="#7021" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7021</h2>
<p>The called method declares a block parameter that is not <code>T.nilable</code> (making the
block argument required), but a block was not passed when it was called.</p>
<p>This can be fixed by either passing a block to the method, or changing the
method’s signature for the block parameter from <code>T.proc...</code> to
<code>T.nilable(T.proc...)</code> (and then changing the method to deal with a nilable
block parameter).</p>
<h2><a class="anchor" aria-hidden="true" id="7022"></a><a href="#7022" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7022</h2>
<p>When run with the <code>--suggest-typed</code> command line argument, Sorbet will suggest
upgrading or downgrading <code># typed:</code> sigils in all files in the project to the
highest level possible that would still have no errors. If the project starts
off with no errors initially, this should have the effect of only upgrading
sigils.</p>
<p>Accept the provided autocorrect suggestion to commit the upgrades (using the
<code>--autocorrect</code> flag).</p>
<h2><a class="anchor" aria-hidden="true" id="7023"></a><a href="#7023" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7023</h2>
<p>This error occurs when a method is passed in a <code>Proc</code> object that Sorbet does
not know the arity for statically.</p>
<p>One instance where this can happen is when using <code>method</code>, since the arity of
method corresponding to the symbol is unknown. This can be fixed by passing in a
block with the correct arity:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: strict</span>

extend T::Sig

sig {params(<span class="hljs-symbol">blk:</span> T.proc.params(<span class="hljs-symbol">arg0:</span> String).void).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># ----- AVOID THIS ----------------------------</span>
foo(&amp;method(<span class="hljs-symbol">:puts</span>))
<span class="hljs-comment"># ---------------------------------------------</span>

<span class="hljs-comment"># ----- Do this instead -----------------------</span>
foo <span class="hljs-keyword">do</span> <span class="hljs-params">|arg0|</span>
    method(<span class="hljs-symbol">:puts</span>).call(arg<span class="hljs-number">0</span>)
<span class="hljs-keyword">end</span>
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7024"></a><a href="#7024" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7024</h2>
<p>This error occurs when a generic argument is passed in as a block parameter.</p>
<p>In <code># typed: strict</code> files, using a parameter from a method that does not have a
signature will cause this issue to be reported. Adding a signature to the method
will fix the issue.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: strict</span>

extend T::Sig

<span class="hljs-comment"># ----- This will error -----------------------</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(&amp;blk)</span></span>
    proc(&amp;blk)
<span class="hljs-keyword">end</span>
<span class="hljs-comment"># ---------------------------------------------</span>

<span class="hljs-comment"># ----- This will not error -------------------</span>
sig {params(<span class="hljs-symbol">blk:</span> T.untyped).returns(T.untyped)}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bar</span><span class="hljs-params">(&amp;blk)</span></span>
    proc(&amp;blk)
<span class="hljs-keyword">end</span>
<span class="hljs-comment"># ---------------------------------------------</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7026"></a><a href="#7026" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7026</h2>
<p>Sorbet detected that it was possible for <code>T.absurd</code> to be reached. This usually
means that something that was meant to cover all possible cases of a union type
did not cover all the cases.</p>
<p>See <a href="/docs/exhaustiveness">Exhaustiveness Checking</a> for more information.</p>
<h2><a class="anchor" aria-hidden="true" id="7027"></a><a href="#7027" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7027</h2>
<p>In <code># typed: strict</code> files, Sorbet requires that all constants are annotated
with a <code>T.let</code>.</p>
<p>For how to fix, see <a href="/docs/type-annotations">Type Annotations</a>, or accept the
autocorrect suggestion associated with this error.</p>
<p>See also: <a href="#5028">5028</a>, <a href="#6002">6002</a>, <a href="#7017">7017</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="7030"></a><a href="#7030" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7030</h2>
<p>This error is consistently used when the user is trying (implicitly or
explicitly) to call some method on a Sorbet type (e.g. <code>T::Array[Integer]</code>)
which would actually return a Sorbet-runtime representation of a type.</p>
<p>This error generally occurs when generic types are used in pattern matching:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_value</span><span class="hljs-params">(input)</span></span>
  <span class="hljs-keyword">case</span> input
  <span class="hljs-keyword">when</span> Integer
    input
  <span class="hljs-keyword">when</span> T::Array[Integer] <span class="hljs-comment"># error: Call to method `===` on `T::Array[Integer]` mistakes a type for a value</span>
    input.first
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Since generic types are erased at runtime, this construct would never work when
the program executed. Replace the generic type <code>T::Array[Integer]</code> by the erased
type <code>Array</code> so the runtime behavior is correct:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_value</span><span class="hljs-params">(input)</span></span>
  <span class="hljs-keyword">case</span> input
  <span class="hljs-keyword">when</span> Integer
    input
  <span class="hljs-keyword">when</span> Array
    input.first
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7031"></a><a href="#7031" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7031</h2>
<p>Private methods in Ruby behave somewhat differently from private methods in
other statically typed languages. You may want to read more about
<a href="https://www.rubyguides.com/2018/10/method-visibility/">method visibility in Ruby</a>
first. The tl;dr is that private methods can only be called when the receiver is
<strong>syntactically</strong> <code>self</code> (or omitted):</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span></span>
  private <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">in_parent</span></span>
    foo      <span class="hljs-comment"># OK</span>
    <span class="hljs-keyword">self</span>.foo <span class="hljs-comment"># OK</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> &lt; Parent</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">in_child</span></span>
    foo      <span class="hljs-comment"># OK</span>
    <span class="hljs-keyword">self</span>.foo <span class="hljs-comment"># OK</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

Parent.new.foo <span class="hljs-comment"># error!</span>
Child.new.foo  <span class="hljs-comment"># error!</span>
</code></pre>
<p>This makes private methods in Ruby behave more like protected methods in other
object-oriented languages.</p>
<p>To fix this error, either:</p>
<ol>
<li>Avoid calling the private method entirely, or</li>
<li>Update the method definition to not be private, or</li>
<li>Use <code>.send(:foo, ...)</code> to ask Ruby to call the method ignoring visibility
checks.</li>
</ol>
<blockquote>
<p><strong>Note</strong>: It’s not possible to silence this error using <code>T.unsafe</code>. Wrapping
the receiver in <code>T.unsafe</code> will in fact hide the method call from Sorbet
statically, but because method visibility is checked <strong>syntactically</strong>, even
using <code>T.unsafe(self).foo</code> will cause a call to a private method <code>foo</code> to be
rejected by the Ruby VM at runtime.</p>
<p>If you must call a private method and also silence any type errors from
calling it, you must use <code>self.send(:foo)</code> instead.</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="7032"></a><a href="#7032" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7032</h2>
<p>When passing type arguments to generic classes, to use <a href="/docs/shapes">shape types</a>,
use curly brackets around the keys and values of the shape type:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># CORRECT</span>
T::Array[{<span class="hljs-symbol">key:</span> Integer}].new

<span class="hljs-comment"># BAD</span>
T::Array[<span class="hljs-symbol">key:</span> Integer].new
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7033"></a><a href="#7033" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7033</h2>
<p><strong>Note</strong>: this error is only reported when Sorbet is passed the
<code>--ruby3-keyword-args</code> command line flag. For further information about Ruby 3
and keyword args, see the
<a href="https://www.ruby-lang.org/en/news/2019/12/12/separation-of-positional-and-keyword-arguments-in-ruby-3-0/">official blog post</a>.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

sig {params(<span class="hljs-symbol">x:</span> Integer, <span class="hljs-symbol">y:</span>Integer).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takes_kwargs</span><span class="hljs-params">(x, <span class="hljs-symbol">y:</span>)</span></span>
<span class="hljs-keyword">end</span>

arghash = {<span class="hljs-symbol">y:</span> <span class="hljs-number">42</span>}

<span class="hljs-comment"># GOOD EXAMPLE</span>
takes_kwargs(<span class="hljs-number">99</span>, **arghash)

<span class="hljs-comment"># BAD EXAMPLE</span>
takes_kwargs(<span class="hljs-number">99</span>, arghash)
<span class="hljs-comment">#                ^^^^^^^ error: Keyword argument hash without `**`</span>
</code></pre>
<p><a href="https://sorbet.run/?arg=--ruby3-keyword-args#%23%20typed%3A%20true%0Aextend%20T%3A%3ASig%0A%0Asig%20%7Bparams%28x%3A%20Integer%2C%20y%3AInteger%29.void%7D%0Adef%20takes_kwargs%28x%2C%20y%3A%29%0Aend%0A%0Aarghash%20%3D%20%7By%3A%2042%7D%0Atakes_kwargs%2899%2C%20arghash%29">→ View on sorbet.run</a></p>
<p>In Ruby 2.7 and earlier, Ruby allowed a positional <code>Hash</code> argument at the end of
a method call’s list of arguments to implicitly splat into the keyword
parameters of the method. In Ruby 3.0 and later, a positional <code>Hash</code> argument is
always treated as a positional argument. To avoid this error, prefix the <code>Hash</code>
argument with <code>**</code>, explicitly requesting to treat it as keyword arguments.</p>
<h2><a class="anchor" aria-hidden="true" id="7034"></a><a href="#7034" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7034</h2>
<p>Sorbet detected that the safe navigation operator (<code>&amp;.</code>) was being used on a
receiver that can never be nil. Replace the offending occurrence of <code>&amp;.</code> with a
normal method call (<code>.</code>).</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>

extend T::Sig

sig {params(<span class="hljs-symbol">x:</span> Integer, <span class="hljs-symbol">y:</span> T.nilable(Integer)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x, y)</span></span>
  puts x&amp;.to_s  <span class="hljs-comment"># error: x can never be nil</span>
  puts x.to_s   <span class="hljs-comment"># no error</span>

  puts y&amp;.to_s  <span class="hljs-comment"># no error: y may be nil</span>
<span class="hljs-keyword">end</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="7035"></a><a href="#7035" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7035</h2>
<p>Sorbet can sometimes detect when a method is passed a block despite not
accepting a block.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: strict</span>
extend T::Sig

sig {void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takes_no_block</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-comment"># BAD EXAMPLE</span>
takes_no_block {} <span class="hljs-comment"># error: does not take a block</span>
</code></pre>
<p>Why only sometimes? Technically all methods in Ruby are allowed to accept
blocks. (Unlike positional arguments, if a method does not declare that it
accepts a block argument but a caller passes one anyways the Ruby VM does not
raise an exception.)</p>
<p>For historical reasons, Sorbet did not require that a <code>sig</code> mention the <code>blk</code>
parameter if its method used <code>yield</code> from the beginning of Sorbet adoption. It
later required this, but for reasons of backwards compatibility, it’s only
checked in <code># typed: strict</code> or higher files.</p>
<p>Therefore, error 7035 is somewhat special in that it can be reported in
<code># typed: true</code> files, but <strong>only</strong> if the method being passed a block is itself
defined in a <code># typed: strict</code> file.</p>
<p>Regardless, to fix this error, either:</p>
<ol>
<li>Remove the block from this call site (using the autocorrect), or</li>
<li>Update the called method’s definition to mention block argument, or</li>
<li>Drop the strictness level of file containing the called method’s definition
to <code># typed: true</code> or lower (<strong>only</strong> as a <strong>last resort</strong>).</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="7036"></a><a href="#7036" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7036</h2>
<p>Sorbet supports declaring package-private methods. These methods can only be
called from within the package where they are declared</p>
<p>To fix this error, either remove the <code>package_private</code> (or
<code>package_private_class_method</code>) annotation from the method definition, or
rewrite the code in question to not call the private method.</p>
<p>As a <strong>last</strong> resort, you can use <code>T.unsafe</code> to hide the method call from
Sorbet, silencing the error.</p>
<h2><a class="anchor" aria-hidden="true" id="7037"></a><a href="#7037" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7037</h2>
<p>See
<a href="/docs/flow-sensitive#limitations-of-flow-sensitivity">this doc for more information</a>.</p>
<p>In general, Sorbet can’t know that two calls to identical methods return
identical things, because in general methods are not pure.</p>
<p>Consider this example</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> &lt; T::Struct</span>
  const <span class="hljs-symbol">:foo</span>, T.nilable(Integer)
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">if</span> a.foo &amp;&amp; a.foo.even?
  <span class="hljs-comment">#         ^^^^^^^^^^^ error</span>
  puts a.foo
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this example, the call to <code>a.foo.even?</code> results in an error, even though we
checked that <code>a.foo</code> was not <code>nil</code> with the <code>&amp;&amp;</code>, because Sorbet does not assume
any methods are pure, not even methods defined with the <code>T::Struct</code> class’s
<code>const</code> DSL. (There are a number of technical and philosophical reasons why
Sorbet behaves this way, and we do not foresee these reasons changing).</p>
<p>There is always a simple solution, which is to either factor out the method
call’s result into a variable, or to use Ruby’s conditional method call operator
(<code>&amp;.</code>):</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># -- solution 1 (preferred) --</span>
x = a.foo
<span class="hljs-keyword">if</span> x &amp;&amp; x.even?
  puts x
<span class="hljs-keyword">end</span>

<span class="hljs-comment"># -- solution 2 --</span>
<span class="hljs-keyword">if</span> a.foo&amp;.even?
  puts a.foo
<span class="hljs-keyword">end</span>
</code></pre>
<p>Of the two, the first solution is preferred because not only will the program
type check as written, but Sorbet will know that the <code>x</code> variable is not <code>nil</code>
throughout the body of the <code>if</code> statement.</p>
<h2><a class="anchor" aria-hidden="true" id="7038"></a><a href="#7038" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7038</h2>
<p>Consider this example:</p>
<pre><code class="hljs css language-ruby">sig <span class="hljs-keyword">do</span>
  type_parameters(<span class="hljs-symbol">:U</span>)
    .params(<span class="hljs-symbol">x:</span> T.type_parameter(<span class="hljs-symbol">:U</span>))
    .void
<span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(x)</span></span>
  x.foo <span class="hljs-comment"># error!</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>This snippet declares a method <code>example</code> with a signature that says it can be
passed any input, but then attempts to call a specific method <code>.foo</code>.</p>
<p>Since this method can be given any type of value, Sorbet rejects the call to
<code>x.foo</code>.</p>
<p>To allow code like this, use <a href="/docs/abstract">interfaces</a> with
<a href="/docs/intersection-types">intersection types</a>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># (1) Declare an interface</span>
<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">IFoo</span></span>
  extend T::Sig
  extend T::Helpers
  interface!

  sig {abstract.void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

sig <span class="hljs-keyword">do</span>
  type_parameters(<span class="hljs-symbol">:U</span>)
    <span class="hljs-comment"># (2) Use the interface with an intersection type</span>
    .params(<span class="hljs-symbol">x:</span> T.all(IFoo, T.type_parameter(<span class="hljs-symbol">:U</span>)))
    .void
<span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(x)</span></span>
  x.foo <span class="hljs-comment"># error!</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Remember that in Sorbet, <a href="/docs/abstract">interfaces</a> must be explicitly
implemented in a given class.</p>
<p>Sometimes this error happens due to a call to <code>is_a?</code> on a type parameter. To
sidestep this error, rewrite the program to use <code>case</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ...</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(x)</span></span>
  <span class="hljs-keyword">if</span> x.is_a?(Integer) <span class="hljs-comment"># error</span>
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">case</span> x
  <span class="hljs-keyword">when</span> Integer <span class="hljs-comment"># OK</span>
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Or if it’s imperative to continue using <code>is_a?</code>, change the type to
<code>T.all(Kernel, T.type_parameter(:U))</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="7039"></a><a href="#7039" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>7039</h2>
<!-- TODO(jez) Link to generic docs once written -->
<p>Consider this example:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">only_on_a</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Box</span></span>
  extend T::Sig
  extend T::Generic
  Elem = type_member

  sig {params(<span class="hljs-symbol">x:</span> Elem).void}
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize</span><span class="hljs-params">(x)</span></span>
    x.only_on_a <span class="hljs-comment"># error, see below for fix</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this example, we’re trying to to call the method <code>only_on_a</code>, but we haven’t
specified any type bounds on the <code>Elem</code> type parameter, which means we can’t
make any assumption about what methods it might have.</p>
<p>If we want to always be able to call the method <code>only_on_a</code>, we can place a
upper bound on <code>Elem</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ...</span>
  Elem = type_member {{<span class="hljs-symbol">upper:</span> A}}
<span class="hljs-comment"># ...</span>
</code></pre>
<p>This will guarantee that <code>Elem</code> is always at least <code>A</code>, which will let Sorbet
allow the call to <code>x.only_on_a</code>.</p>
<p>Sometimes this error happens due to a call to <code>is_a?</code> on a type member. To
sidestep this error, rewrite the program to use <code>case</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ...</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span><span class="hljs-params">(x)</span></span>
  <span class="hljs-keyword">if</span> x.is_a?(Integer) <span class="hljs-comment"># error</span>
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>

  <span class="hljs-keyword">case</span> x
  <span class="hljs-keyword">when</span> Integer <span class="hljs-comment"># OK</span>
    <span class="hljs-comment"># ...</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Or if it’s imperative to continue using <code>is_a?</code>, change the type to
<code>T.all(Kernel, Elem)</code> and/or add an upper bound of <code>Kernel</code> to the type member.</p>
<!-- -->
<script src="/js/error-reference.js"></script>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/faq"><span class="arrow-prev">← </span><span>FAQ</span></a><a class="docs-next button" href="/docs/sigs"><span>sig</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#1001">1001</a></li><li><a href="#1003">1003</a></li><li><a href="#1004">1004</a></li><li><a href="#2001">2001</a></li><li><a href="#2002">2002</a></li><li><a href="#2003">2003</a></li><li><a href="#2004">2004</a></li><li><a href="#3001">3001</a></li><li><a href="#3002">3002</a></li><li><a href="#3003">3003</a></li><li><a href="#3004">3004</a></li><li><a href="#3005">3005</a></li><li><a href="#3007">3007</a></li><li><a href="#3008">3008</a></li><li><a href="#3009">3009</a></li><li><a href="#3010">3010</a></li><li><a href="#3011">3011</a></li><li><a href="#3501">3501</a></li><li><a href="#3502">3502</a></li><li><a href="#3503">3503</a></li><li><a href="#3504">3504</a></li><li><a href="#3505">3505</a></li><li><a href="#3506">3506</a></li><li><a href="#3507">3507</a></li><li><a href="#3508">3508</a></li><li><a href="#3509">3509</a></li><li><a href="#3510">3510</a></li><li><a href="#3511">3511</a></li><li><a href="#3512">3512</a></li><li><a href="#3702">3702</a></li><li><a href="#3703">3703</a></li><li><a href="#3704">3704</a></li><li><a href="#3705">3705</a></li><li><a href="#3706">3706</a></li><li><a href="#3707">3707</a></li><li><a href="#3709">3709</a></li><li><a href="#3710">3710</a></li><li><a href="#3711">3711</a></li><li><a href="#3712">3712</a></li><li><a href="#3713">3713</a></li><li><a href="#3714">3714</a></li><li><a href="#3715">3715</a></li><li><a href="#3716">3716</a></li><li><a href="#4001">4001</a></li><li><a href="#4002">4002</a></li><li><a href="#4003">4003</a></li><li><a href="#4006">4006</a></li><li><a href="#4010">4010</a></li><li><a href="#4011">4011</a></li><li><a href="#4012">4012</a></li><li><a href="#4013">4013</a></li><li><a href="#4014">4014</a></li><li><a href="#4015">4015</a></li><li><a href="#4016">4016</a></li><li><a href="#4019">4019</a></li><li><a href="#4021">4021</a></li><li><a href="#5001">5001</a></li><li><a href="#5002">5002</a></li><li><a href="#5003">5003</a></li><li><a href="#5004">5004</a></li><li><a href="#5005">5005</a></li><li><a href="#5006">5006</a></li><li><a href="#5008">5008</a></li><li><a href="#5011">5011</a></li><li><a href="#5012">5012</a></li><li><a href="#5013">5013</a></li><li><a href="#5014">5014</a></li><li><a href="#5015">5015</a></li><li><a href="#5016">5016</a></li><li><a href="#5017">5017</a></li><li><a href="#5018">5018</a></li><li><a href="#5019">5019</a></li><li><a href="#5020">5020</a></li><li><a href="#5021">5021</a></li><li><a href="#5022">5022</a></li><li><a href="#5023">5023</a></li><li><a href="#5024">5024</a></li><li><a href="#5025">5025</a></li><li><a href="#5026">5026</a></li><li><a href="#5028">5028</a></li><li><a href="#5030">5030</a></li><li><a href="#5031">5031</a></li><li><a href="#5032">5032</a></li><li><a href="#5033">5033</a></li><li><a href="#5034">5034</a></li><li><a href="#5035">5035</a></li><li><a href="#5036">5036</a></li><li><a href="#5037">5037</a></li><li><a href="#5038">5038</a></li><li><a href="#5039">5039</a></li><li><a href="#5040">5040</a></li><li><a href="#5041">5041</a></li><li><a href="#5042">5042</a></li><li><a href="#5043">5043</a></li><li><a href="#5044">5044</a></li><li><a href="#5045">5045</a></li><li><a href="#5046">5046</a></li><li><a href="#5047">5047</a></li><li><a href="#5048">5048</a></li><li><a href="#5049">5049</a></li><li><a href="#5050">5050</a></li><li><a href="#5051">5051</a></li><li><a href="#5052">5052</a></li><li><a href="#5053">5053</a></li><li><a href="#5054">5054</a></li><li><a href="#5055">5055</a></li><li><a href="#5056">5056</a></li><li><a href="#5057">5057</a></li><li><a href="#5058">5058</a></li><li><a href="#5059">5059</a></li><li><a href="#5060">5060</a></li><li><a href="#5061">5061</a></li><li><a href="#5062">5062</a></li><li><a href="#5063">5063</a></li><li><a href="#5064">5064</a></li><li><a href="#5065">5065</a></li><li><a href="#5067">5067</a></li><li><a href="#5068">5068</a></li><li><a href="#5069">5069</a></li><li><a href="#5070">5070</a></li><li><a href="#5071">5071</a></li><li><a href="#6001">6001</a></li><li><a href="#6002">6002</a></li><li><a href="#6004">6004</a></li><li><a href="#6005">6005</a></li><li><a href="#7001">7001</a></li><li><a href="#7002">7002</a></li><li><a href="#7003">7003</a></li><li><a href="#7004">7004</a></li><li><a href="#7005">7005</a></li><li><a href="#7006">7006</a></li><li><a href="#7007">7007</a></li><li><a href="#7009">7009</a></li><li><a href="#7010">7010</a></li><li><a href="#7011">7011</a></li><li><a href="#7013">7013</a></li><li><a href="#7014">7014</a></li><li><a href="#7015">7015</a></li><li><a href="#7016">7016</a></li><li><a href="#7017">7017</a></li><li><a href="#7018">7018</a></li><li><a href="#7019">7019</a></li><li><a href="#7020">7020</a></li><li><a href="#7021">7021</a></li><li><a href="#7022">7022</a></li><li><a href="#7023">7023</a></li><li><a href="#7024">7024</a></li><li><a href="#7026">7026</a></li><li><a href="#7027">7027</a></li><li><a href="#7030">7030</a></li><li><a href="#7031">7031</a></li><li><a href="#7032">7032</a></li><li><a href="#7033">7033</a></li><li><a href="#7034">7034</a></li><li><a href="#7035">7035</a></li><li><a href="#7036">7036</a></li><li><a href="#7037">7037</a></li><li><a href="#7038">7038</a></li><li><a href="#7039">7039</a></li></ul></nav></div><footer class="nav-footer" id="footer"><div class="wrapper"><p class="footer">© 2022 Stripe · <a href="/docs/adopting">Get started</a> · <a href="/docs/overview">Docs</a> · <a href="https://sorbet.run">Try</a> · <a href="/en/community">Community</a> · <a href="/blog">Blog</a> · <a href="https://twitter.com/sorbet_ruby">Twitter</a></p></div></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                appId: 'ZYWC6Z01G8',
                apiKey: 'b05a65e9f8d9f50dc4ec3241db8836c4',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>