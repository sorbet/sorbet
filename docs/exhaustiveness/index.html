<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Exhaustiveness Checking · Sorbet</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Sorbet does not currently have first-class support for&lt;/p&gt;
&lt;/blockquote&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Exhaustiveness Checking · Sorbet"/><meta property="og:type" content="website"/><meta property="og:url" content="https://sorbet.org/"/><meta property="og:description" content="&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Sorbet does not currently have first-class support for&lt;/p&gt;
&lt;/blockquote&gt;
"/><meta property="og:image" content="https://sorbet.org/img/sorbet-logo-purple-sparkles.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://sorbet.org/img/sorbet-logo-purple-sparkles.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-119877071-2', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/sorbet-logo-white-sparkles.svg" alt="Sorbet"/><h2 class="headerTitleWithLogo">Sorbet</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/adopting" target="_self">Get started</a></li><li class="siteNavGroupActive"><a href="/docs/overview" target="_self">Docs</a></li><li class=""><a href="https://sorbet.run" target="_self">Try it online</a></li><li class=""><a href="/docs/talks" target="_self">Talks</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Type System</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/overview">Overview</a></li><li class="navListItem"><a class="navItem" href="/docs/adopting">Adopting Sorbet</a></li><li class="navListItem"><a class="navItem" href="/docs/quickref">Quick Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Static &amp; Runtime</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/gradual">Gradual Type Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/static">Enabling Static Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/runtime">Enabling Runtime Checks</a></li><li class="navListItem"><a class="navItem" href="/docs/rbi">RBI Files</a></li><li class="navListItem"><a class="navItem" href="/docs/cli">Command Line Reference</a></li><li class="navListItem"><a class="navItem" href="/docs/tconfiguration">Runtime Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Troubleshooting</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/troubleshooting">Troubleshooting</a></li><li class="navListItem"><a class="navItem" href="/docs/faq">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/error-reference">Error Reference</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Type System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/sigs">Signatures</a></li><li class="navListItem"><a class="navItem" href="/docs/class-types">Class Types</a></li><li class="navListItem"><a class="navItem" href="/docs/nilable-types">Nilable Types</a></li><li class="navListItem"><a class="navItem" href="/docs/union-types">Union Types</a></li><li class="navListItem"><a class="navItem" href="/docs/flow-sensitive">Flow Sensitivity</a></li><li class="navListItem"><a class="navItem" href="/docs/type-assertions">Type Assertions</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/exhaustiveness">Exhaustiveness Checking</a></li><li class="navListItem"><a class="navItem" href="/docs/tuples">Tuples</a></li><li class="navListItem"><a class="navItem" href="/docs/shapes">Shapes</a></li><li class="navListItem"><a class="navItem" href="/docs/tstruct">Typed Structs</a></li><li class="navListItem"><a class="navItem" href="/docs/untyped">T.untyped</a></li><li class="navListItem"><a class="navItem" href="/docs/noreturn">T.noreturn</a></li><li class="navListItem"><a class="navItem" href="/docs/type-aliases">Type Aliases</a></li><li class="navListItem"><a class="navItem" href="/docs/stdlib-generics">Builtin Generics</a></li><li class="navListItem"><a class="navItem" href="/docs/procs">Proc Types</a></li><li class="navListItem"><a class="navItem" href="/docs/class-of">T.class_of</a></li><li class="navListItem"><a class="navItem" href="/docs/self-type">T.self_type</a></li><li class="navListItem"><a class="navItem" href="/docs/abstract">Abstract Classes and Interfaces</a></li><li class="navListItem"><a class="navItem" href="/docs/strict">Strict Mode</a></li><li class="navListItem"><a class="navItem" href="/docs/intersection-types">Intersection Types</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/stripe/sorbet/edit/master/website/docs/exhaustiveness.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Exhaustiveness Checking</h1></header><article><div><span><blockquote>
<p><strong>Note</strong>: Sorbet does not currently have first-class support for
exhaustiveness checks. This feature is planned, but has not yet been
implemented. Here we document a current workaround.</p>
</blockquote>
<p>Using <a href="/docs/flow-sensitive">Flow-Sensitive Typing</a>, <a href="/docs/union-types">Union Types</a>,
and <a href="/docs/type-assertions">Type Assertions</a> we can approximate exhaustiveness
checking. <strong>Exhaustiveness checking</strong> is a feature of a language where the type
checker guarantees that the programmer has covered all cases. It can be super
useful at catching pesky edge cases before they become bugs!</p>
<h2><a class="anchor" aria-hidden="true" id="tl-dr"></a><a href="#tl-dr" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>tl;dr</h2>
<p>If you already know what exhaustiveness checking is, you might just want to see
the end result:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>;</span> <span class="hljs-keyword">end</span>

AorBorC = T.type_alias(T.any(A, B, C))

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_a</span><span class="hljs-params">(a)</span></span>; puts <span class="hljs-string">'Got an A!'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_b</span><span class="hljs-params">(b)</span></span>; puts <span class="hljs-string">'Got a B!'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_c</span><span class="hljs-params">(c)</span></span>; puts <span class="hljs-string">'Got a C!'</span>; <span class="hljs-keyword">end</span>

<span class="hljs-comment"># (1) We have a union type of A, B, or C</span>
sig {params(<span class="hljs-symbol">x:</span> AorBorC).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  <span class="hljs-comment"># (2) We use flow-sensitivity to cover each case separately</span>
  <span class="hljs-keyword">case</span> x
  <span class="hljs-keyword">when</span> A
    <span class="hljs-comment"># To re-iterate: within this branch, Sorbet knows x is an A</span>
    T.reveal_type(x) <span class="hljs-comment"># Revealed type: `A`</span>

    do_a(x)

  <span class="hljs-keyword">when</span> B
    do_b(x)

  <span class="hljs-keyword">else</span>
    <span class="hljs-comment"># (3) Use a type assertion to require that x MUST be C</span>
    T.let(x, C)
    <span class="hljs-comment">#        ^ If the type of x ever widens to include other types,</span>
    <span class="hljs-comment">#          sorbet will report an error here.</span>

    do_c(x)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>Otherwise, let's walk through an example explaining not only <strong>how</strong> we can get
exhaustiveness checking, but also <strong>why</strong> it's useful:</p>
<h2><a class="anchor" aria-hidden="true" id="example"></a><a href="#example" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example</h2>
<p>Let's say we have this setup:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">x:</span> T.any(A, B)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  <span class="hljs-comment"># ...</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>There are two classes (<code>A</code> and <code>B</code>), and our method <code>foo</code> takes either <code>A</code> or
<code>B</code>.</p>
<p>In the body of <code>foo</code>, we'd like to do something different when given an <code>A</code>
versus when given a <code>B</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ...</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_a</span><span class="hljs-params">(a)</span></span>; puts <span class="hljs-string">'Got an A!'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_b</span><span class="hljs-params">(b)</span></span>; puts <span class="hljs-string">'Got a B!'</span>; <span class="hljs-keyword">end</span>

sig {params(<span class="hljs-symbol">x:</span> T.any(A, B)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  <span class="hljs-comment"># Problematic! We'll improve this shortly...</span>
  <span class="hljs-keyword">case</span> x
  <span class="hljs-keyword">when</span> A
    do_a(x)
  <span class="hljs-keyword">when</span> B
    do_b(x)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>There's no bug here yet, but consider that some time in the future, someone
wants to update <code>foo</code> to work with class <code>C</code>:</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># ...</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_c</span><span class="hljs-params">(c)</span></span>; puts <span class="hljs-string">'Got a C!'</span>; <span class="hljs-keyword">end</span>

<span class="hljs-comment"># ...</span>

sig {params(<span class="hljs-symbol">x:</span> T.any(A, B, C)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  <span class="hljs-comment"># Bug! We forgot to update the body to handle C...</span>
  <span class="hljs-keyword">case</span> x
  <span class="hljs-keyword">when</span> A
    do_a(x)
  <span class="hljs-keyword">when</span> B
    do_b(x)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, there's a silent bug in our program. We've updated the signature
of <code>foo</code> to accept instances of <code>C</code>, but we haven't updated the method body to
actually do something with it!</p>
<p><strong>Exhaustiveness checking</strong> is a feature that turns this kind of bug into a type
error. It lets us catch the problem statically before causing all sorts of
problems down the line.</p>
<p>We can enable exhaustivness checking in Sorbet using a <a href="/docs/type-assertions">type
assertion</a>:</p>
<pre><code class="hljs css language-ruby">sig {params(<span class="hljs-symbol">x:</span> T.any(A, B, C)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  <span class="hljs-keyword">case</span> x
  <span class="hljs-keyword">when</span> A
    do_a(x)
  <span class="hljs-keyword">else</span>
    T.let(x, B) <span class="hljs-comment"># error: Argument does not have accepted type: `B`</span>
                <span class="hljs-comment">#        Got: `T.any(B, C)`</span>
    do_b(x)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>In this case, Sorbet is telling us that by the time we got to the else case, we
were missing a case: both <code>B</code> and <code>C</code> needed to be handled, but we were only
handling <code>B</code>.</p>
<p>Putting everything together, this is what our final program looks like. It
handles all the cases, and prevents against other people from forgetting to
handle any new cases that get added.</p>
<pre><code class="hljs css language-ruby"><span class="hljs-comment"># typed: true</span>
extend T::Sig

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>;</span> <span class="hljs-keyword">end</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>;</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_a</span><span class="hljs-params">(a)</span></span>; puts <span class="hljs-string">'Got an A!'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_b</span><span class="hljs-params">(b)</span></span>; puts <span class="hljs-string">'Got a B!'</span>; <span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">do_c</span><span class="hljs-params">(c)</span></span>; puts <span class="hljs-string">'Got a C!'</span>; <span class="hljs-keyword">end</span>

<span class="hljs-comment"># (1) We have a union type of A, B, or C</span>
sig {params(<span class="hljs-symbol">x:</span> T.any(A, B, C)).void}
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span></span>
  <span class="hljs-comment"># (2) We use flow-sensitivity to cover each case separately</span>
  <span class="hljs-keyword">case</span> x
  <span class="hljs-keyword">when</span> A
    <span class="hljs-comment"># To re-iterate: within this branch, Sorbet knows x is an A</span>
    T.reveal_type(x) <span class="hljs-comment"># Revealed type: `A`</span>

    do_a(x)

  <span class="hljs-keyword">when</span> B
    do_b(x)

  <span class="hljs-keyword">else</span>
    <span class="hljs-comment"># (3) Use a type assertion to require that x MUST be C</span>
    T.let(x, C)
    <span class="hljs-comment">#        ^ If the type of x ever widens to include other types,</span>
    <span class="hljs-comment">#          sorbet will report an error here.</span>

    do_c(x)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<blockquote>
<p><strong>Tip</strong>: We can use <a href="/docs/type-aliases">Type Aliases</a> to give a name to
<code>T.any(A, B, C)</code> and reuse it throughout our codebase. This means we can
update the alias in one place, instead of at every individual method!</p>
</blockquote>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/type-assertions"><span class="arrow-prev">← </span><span>Type Assertions</span></a><a class="docs-next button" href="/docs/tuples"><span>Tuples</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#tl-dr">tl;dr</a></li><li><a href="#example">Example</a></li></ul></nav></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'fa1ec885ab70787d636759b88e509b92',
                indexName: 'stripe_sorbet',
                inputSelector: '#search_input_react',
                algoliaOptions: {}
              });
            </script></body></html>