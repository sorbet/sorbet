# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   scripts/bin/remote-script sorbet/shim_generation/gems.rb -r net

# typed: __STDLIB_INTERNAL

module Net
end

class Net::BufferedIO
  BUFSIZE = ::T.let(nil, ::T.untyped)

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(str); end

  sig {returns(::T.untyped)}
  def close(); end

  sig {returns(::T.untyped)}
  def closed?(); end

  sig {returns(::T.untyped)}
  def continue_timeout(); end

  sig do
    params(
      continue_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def continue_timeout=(continue_timeout); end

  sig {returns(::T.untyped)}
  def debug_output(); end

  sig do
    params(
      debug_output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_output=(debug_output); end

  sig {returns(::T.untyped)}
  def eof?(); end

  sig do
    params(
      io: ::T.untyped,
      read_timeout: ::T.untyped,
      continue_timeout: ::T.untyped,
      debug_output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(io, read_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def io(); end

  sig do
    params(
      len: ::T.untyped,
      dest: ::T.untyped,
      ignore_eof: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(len, dest=T.unsafe(nil), ignore_eof=T.unsafe(nil)); end

  sig do
    params(
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_all(dest=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def read_timeout(); end

  sig do
    params(
      read_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(read_timeout); end

  sig {returns(::T.untyped)}
  def readline(); end

  sig do
    params(
      terminator: ::T.untyped,
      ignore_eof: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readuntil(terminator, ignore_eof=T.unsafe(nil)); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(str); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def writeline(str); end
end

module Net::DNS
  include ::Net::DNS::QueryClasses
  include ::Net::DNS::QueryTypes
  include ::Logger::Severity
  HFIXEDSZ = ::T.let(nil, ::T.untyped)
  INT16SZ = ::T.let(nil, ::T.untyped)
  INT32SZ = ::T.let(nil, ::T.untyped)
  PACKETSZ = ::T.let(nil, ::T.untyped)
  QFIXEDSZ = ::T.let(nil, ::T.untyped)
  RRFIXEDSZ = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)

end

class Net::DNS::Header
  IQUERY = ::T.let(nil, ::T.untyped)
  OPARR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  STATUS = ::T.let(nil, ::T.untyped)

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def aa=(val); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ad=(val); end

  sig {returns(::T.untyped)}
  def anCount(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def anCount=(val); end

  sig {returns(::T.untyped)}
  def arCount(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def arCount=(val); end

  sig {returns(::T.untyped)}
  def auth?(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cd=(val); end

  sig {returns(::T.untyped)}
  def checking?(); end

  sig {returns(::T.untyped)}
  def data(); end

  sig {returns(::T.untyped)}
  def error?(); end

  sig {returns(::T.untyped)}
  def format(); end

  sig {returns(::T.untyped)}
  def id(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def id=(val); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(arg=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def nsCount(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def nsCount=(val); end

  sig {returns(::T.untyped)}
  def opCode(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def opCode=(val); end

  sig {returns(::T.untyped)}
  def opCode_str(); end

  sig {returns(::T.untyped)}
  def qdCount(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def qdCount=(val); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def qr=(val); end

  sig {returns(::T.untyped)}
  def query?(); end

  sig {returns(::T.untyped)}
  def rCode(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rCode=(val); end

  sig {returns(::T.untyped)}
  def rCode_str(); end

  sig {returns(::T.untyped)}
  def r_available?(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ra=(val); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rd=(val); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def recursive=(val); end

  sig {returns(::T.untyped)}
  def recursive?(); end

  sig {returns(::T.untyped)}
  def response?(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tc=(val); end

  sig {returns(::T.untyped)}
  def truncated?(); end

  sig {returns(::T.untyped)}
  def verified?(); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(arg); end
end

class Net::DNS::Header::Error < StandardError
end

class Net::DNS::Header::RCode
  FORMAT = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NOTIMPLEMENTED = ::T.let(nil, ::T.untyped)
  RCodeErrorString = ::T.let(nil, ::T.untyped)
  RCodeType = ::T.let(nil, ::T.untyped)
  REFUSED = ::T.let(nil, ::T.untyped)
  SERVER = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def code(); end

  sig {returns(::T.untyped)}
  def explanation(); end

  sig do
    params(
      code: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(code); end

  sig {returns(::T.untyped)}
  def to_s(); end

  sig {returns(::T.untyped)}
  def type(); end
end

class Net::DNS::Header::WrongCountError < ArgumentError
end

class Net::DNS::Header::WrongOpcodeError < ArgumentError
end

class Net::DNS::Header::WrongRecursiveError < ArgumentError
end

module Net::DNS::Names
  INT16SZ = ::T.let(nil, ::T.untyped)

  sig do
    params(
      name: ::T.untyped,
      offset: ::T.untyped,
      compnames: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dn_comp(name, offset, compnames); end

  sig do
    params(
      packet: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dn_expand(packet, offset); end

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def names_array(name); end

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pack_name(name); end

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def valid?(name); end
end

class Net::DNS::Names::Error < StandardError
end

class Net::DNS::Names::ExpandError < Net::DNS::Names::Error
end

class Net::DNS::Packet
  include ::Net::DNS::Names
  sig {returns(::T.untyped)}
  def additional(); end

  sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def additional=(object); end

  sig {returns(::T.untyped)}
  def answer(); end

  sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def answer=(object); end

  sig {returns(::T.untyped)}
  def answerfrom(); end

  sig {returns(::T.untyped)}
  def answersize(); end

  sig {returns(::T.untyped)}
  def authority(); end

  sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authority=(object); end

  sig {returns(::T.untyped)}
  def data(); end

  sig {returns(::T.untyped)}
  def data_comp(); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_address(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_cname(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_mx(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_nameserver(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_ptr(&block); end

  sig {returns(::T.untyped)}
  def header(); end

  sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def header=(object); end

  sig do
    params(
      name: ::T.untyped,
      type: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(name, type=T.unsafe(nil), cls=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def nxdomain?(); end

  sig {returns(::T.untyped)}
  def query?(); end

  sig {returns(::T.untyped)}
  def question(); end

  sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def question=(object); end

  sig {returns(::T.untyped)}
  def size(); end

  sig {returns(::T.untyped)}
  def to_s(); end

  sig {returns(::T.untyped)}
  def truncated?(); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(*args); end
end

class Net::DNS::Packet::Error < StandardError
end

class Net::DNS::Packet::PacketError < Net::DNS::Packet::Error
end

module Net::DNS::QueryClasses
  ANY = ::T.let(nil, ::T.untyped)
  CH = ::T.let(nil, ::T.untyped)
  HS = ::T.let(nil, ::T.untyped)
  IN = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)

end

module Net::DNS::QueryTypes
  A = ::T.let(nil, ::T.untyped)
  AAAA = ::T.let(nil, ::T.untyped)
  AFSDB = ::T.let(nil, ::T.untyped)
  ANY = ::T.let(nil, ::T.untyped)
  ATMA = ::T.let(nil, ::T.untyped)
  AXFR = ::T.let(nil, ::T.untyped)
  CERT = ::T.let(nil, ::T.untyped)
  CNAME = ::T.let(nil, ::T.untyped)
  DNAME = ::T.let(nil, ::T.untyped)
  DNSKEY = ::T.let(nil, ::T.untyped)
  DS = ::T.let(nil, ::T.untyped)
  EID = ::T.let(nil, ::T.untyped)
  GID = ::T.let(nil, ::T.untyped)
  GPOS = ::T.let(nil, ::T.untyped)
  HINFO = ::T.let(nil, ::T.untyped)
  ISDN = ::T.let(nil, ::T.untyped)
  IXFR = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  KX = ::T.let(nil, ::T.untyped)
  LOC = ::T.let(nil, ::T.untyped)
  MAILA = ::T.let(nil, ::T.untyped)
  MAILB = ::T.let(nil, ::T.untyped)
  MB = ::T.let(nil, ::T.untyped)
  MD = ::T.let(nil, ::T.untyped)
  MF = ::T.let(nil, ::T.untyped)
  MG = ::T.let(nil, ::T.untyped)
  MINFO = ::T.let(nil, ::T.untyped)
  MR = ::T.let(nil, ::T.untyped)
  MX = ::T.let(nil, ::T.untyped)
  NAPTR = ::T.let(nil, ::T.untyped)
  NIMLOC = ::T.let(nil, ::T.untyped)
  NS = ::T.let(nil, ::T.untyped)
  NSAP = ::T.let(nil, ::T.untyped)
  NSAPPTR = ::T.let(nil, ::T.untyped)
  NSEC = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NXT = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  PTR = ::T.let(nil, ::T.untyped)
  PX = ::T.let(nil, ::T.untyped)
  RP = ::T.let(nil, ::T.untyped)
  RRSIG = ::T.let(nil, ::T.untyped)
  RT = ::T.let(nil, ::T.untyped)
  SIG = ::T.let(nil, ::T.untyped)
  SIGZERO = ::T.let(nil, ::T.untyped)
  SOA = ::T.let(nil, ::T.untyped)
  SRV = ::T.let(nil, ::T.untyped)
  SSHFP = ::T.let(nil, ::T.untyped)
  TKEY = ::T.let(nil, ::T.untyped)
  TSIG = ::T.let(nil, ::T.untyped)
  TXT = ::T.let(nil, ::T.untyped)
  UID = ::T.let(nil, ::T.untyped)
  UINFO = ::T.let(nil, ::T.untyped)
  UNSPEC = ::T.let(nil, ::T.untyped)
  WKS = ::T.let(nil, ::T.untyped)
  X25 = ::T.let(nil, ::T.untyped)

end

class Net::DNS::Question
  include ::Net::DNS::Names
  sig {returns(::T.untyped)}
  def comp_data(); end

  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      name: ::T.untyped,
      type: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(name, type=T.unsafe(nil), cls=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def qClass(); end

  sig {returns(::T.untyped)}
  def qName(); end

  sig {returns(::T.untyped)}
  def qType(); end

  sig {returns(::T.untyped)}
  def to_s(); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(arg); end
end

class Net::DNS::Question::Error < StandardError
end

class Net::DNS::Question::NameInvalid < Net::DNS::Question::Error
end

class Net::DNS::RR
  include ::Net::DNS::Names
  RRFIXEDSZ = ::T.let(nil, ::T.untyped)
  RR_REGEXP = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def cls(); end

  sig do
    params(
      offset: ::T.untyped,
      compnames: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def comp_data(offset, compnames); end

  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(arg); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def name(); end

  sig {returns(::T.untyped)}
  def rdata(); end

  sig {returns(::T.untyped)}
  def to_a(); end

  sig {returns(::T.untyped)}
  def to_s(); end

  sig {returns(::T.untyped)}
  def ttl(); end

  sig {returns(::T.untyped)}
  def type(); end

  sig {returns(::T.untyped)}
  def value(); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*args); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(data); end

  sig do
    params(
      data: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse_packet(data, offset); end
end

class Net::DNS::RR::A < Net::DNS::RR
  sig {returns(::T.untyped)}
  def address(); end

  sig do
    params(
      string_or_ipaddr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def address=(string_or_ipaddr); end

  sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::AAAA < Net::DNS::RR
  sig {returns(::T.untyped)}
  def address(); end

  sig do
    params(
      string_or_ipaddr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def address=(string_or_ipaddr); end

  sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::CNAME < Net::DNS::RR
  sig {returns(::T.untyped)}
  def cname(); end

  sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::Classes
  CLASSES = ::T.let(nil, ::T.untyped)

  sig do
    params(
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(cls); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def to_i(); end

  sig {returns(::T.untyped)}
  def to_s(); end

  sig {returns(::T.untyped)}
  def self.default(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.default=(str); end

  sig {returns(::T.untyped)}
  def self.regexp(); end

  sig do
    params(
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.valid?(cls); end
end

class Net::DNS::RR::DataError < Net::DNS::RR::Error
end

class Net::DNS::RR::Error < StandardError
end

class Net::DNS::RR::HINFO < Net::DNS::RR
  sig {returns(::T.untyped)}
  def cpu(); end

  sig {returns(::T.untyped)}
  def os(); end

  sig {returns(::T.untyped)}
  def to_a(); end

  sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::MR < Net::DNS::RR
  sig {returns(::T.untyped)}
  def newname(); end

  sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::MX < Net::DNS::RR
  sig {returns(::T.untyped)}
  def exchange(); end

  sig {returns(::T.untyped)}
  def preference(); end

  sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::NS < Net::DNS::RR
  sig {returns(::T.untyped)}
  def nsdname(); end

  sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::PTR < Net::DNS::RR
  sig {returns(::T.untyped)}
  def ptr(); end

  sig {returns(::T.untyped)}
  def ptrdname(); end

  sig {returns(::T.untyped)}
  def value(); end
end

class Net::DNS::RR::SOA < Net::DNS::RR
  sig {returns(::T.untyped)}
  def expire(); end

  sig {returns(::T.untyped)}
  def minimum(); end

  sig {returns(::T.untyped)}
  def mname(); end

  sig {returns(::T.untyped)}
  def refresh(); end

  sig {returns(::T.untyped)}
  def retry(); end

  sig {returns(::T.untyped)}
  def rname(); end

  sig {returns(::T.untyped)}
  def serial(); end
end

class Net::DNS::RR::SRV < Net::DNS::RR
  sig {returns(::T.untyped)}
  def host(); end

  sig {returns(::T.untyped)}
  def port(); end

  sig {returns(::T.untyped)}
  def priority(); end

  sig {returns(::T.untyped)}
  def weight(); end
end

class Net::DNS::RR::TXT < Net::DNS::RR
  sig {returns(::T.untyped)}
  def txt(); end
end

class Net::DNS::RR::Types
  TYPES = ::T.let(nil, ::T.untyped)

  sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(type); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def to_i(); end

  sig {returns(::T.untyped)}
  def to_s(); end

  sig {returns(::T.untyped)}
  def to_str(); end

  sig {returns(::T.untyped)}
  def self.default(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.default=(str); end

  sig {returns(::T.untyped)}
  def self.regexp(); end

  sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.to_str(type); end

  sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.valid?(type); end
end

class Net::DNS::Resolver
  Defaults = ::T.let(nil, ::T.untyped)

  sig do
    params(
      name: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def axfr(name, cls=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def defname(); end

  sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def defname=(bool); end

  sig {returns(::T.untyped)}
  def defname?(); end

  sig {returns(::T.untyped)}
  def dns_search(); end

  sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dns_search=(bool); end

  sig {returns(::T.untyped)}
  def dnsrch(); end

  sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dnsrch=(bool); end

  sig {returns(::T.untyped)}
  def domain(); end

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def domain=(name); end

  sig {returns(::T.untyped)}
  def ignore_truncated(); end

  sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ignore_truncated=(bool); end

  sig {returns(::T.untyped)}
  def ignore_truncated?(); end

  sig do
    params(
      config: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(config=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig do
    params(
      log: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def log_file=(log); end

  sig do
    params(
      level: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def log_level=(level); end

  sig do
    params(
      logger: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def logger=(logger); end

  sig do
    params(
      name: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mx(name, cls=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def nameserver(); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def nameserver=(arg); end

  sig {returns(::T.untyped)}
  def nameservers(); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def nameservers=(arg); end

  sig {returns(::T.untyped)}
  def packet_size(); end

  sig {returns(::T.untyped)}
  def port(); end

  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def port=(num); end

  sig {returns(::T.untyped)}
  def print(); end

  sig do
    params(
      argument: ::T.untyped,
      type: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def query(argument, type=T.unsafe(nil), cls=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def recurse(); end

  sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def recurse=(bool); end

  sig {returns(::T.untyped)}
  def recursive(); end

  sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def recursive=(bool); end

  sig {returns(::T.untyped)}
  def recursive?(); end

  sig {returns(::T.untyped)}
  def retrans(); end

  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retrans=(num); end

  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retry=(num); end

  sig {returns(::T.untyped)}
  def retry_interval(); end

  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retry_interval=(num); end

  sig {returns(::T.untyped)}
  def retry_number(); end

  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retry_number=(num); end

  sig do
    params(
      name: ::T.untyped,
      type: ::T.untyped,
      cls: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def search(name, type=T.unsafe(nil), cls=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def searchlist(); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def searchlist=(arg); end

  sig {returns(::T.untyped)}
  def source_address(); end

  sig do
    params(
      addr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def source_address=(addr); end

  sig {returns(::T.untyped)}
  def source_address_inet6(); end

  sig {returns(::T.untyped)}
  def source_port(); end

  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def source_port=(num); end

  sig {returns(::T.untyped)}
  def srcaddr(); end

  sig do
    params(
      addr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def srcaddr=(addr); end

  sig {returns(::T.untyped)}
  def srcport(); end

  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def srcport=(num); end

  sig {returns(::T.untyped)}
  def state(); end

  sig {returns(::T.untyped)}
  def tcp_timeout(); end

  sig do
    params(
      secs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tcp_timeout=(secs); end

  sig {returns(::T.untyped)}
  def udp_timeout(); end

  sig do
    params(
      secs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def udp_timeout=(secs); end

  sig {returns(::T.untyped)}
  def use_tcp(); end

  sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def use_tcp=(bool); end

  sig {returns(::T.untyped)}
  def use_tcp?(); end

  sig {returns(::T.untyped)}
  def usevc(); end

  sig do
    params(
      bool: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def usevc=(bool); end

  sig {returns(::T.untyped)}
  def self.platform_windows?(); end

  sig do
    params(
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(*params); end
end

class Net::DNS::Resolver::DnsTimeout
  sig do
    params(
      seconds: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(seconds); end

  sig {returns(::T.untyped)}
  def pretty_to_s(); end

  sig {returns(::T.untyped)}
  def seconds(); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def timeout(&block); end

  sig {returns(::T.untyped)}
  def to_s(); end
end

class Net::DNS::Resolver::Error < StandardError
end

class Net::DNS::Resolver::NoResponseError < Net::DNS::Resolver::Error
end

class Net::DNS::Resolver::TcpTimeout < Net::DNS::Resolver::DnsTimeout
  sig do
    params(
      seconds: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(seconds); end
end

class Net::DNS::Resolver::UdpTimeout < Net::DNS::Resolver::DnsTimeout
  sig do
    params(
      seconds: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(seconds); end
end

# This class implements the
# [`File`](https://docs.ruby-lang.org/en/2.6.0/File.html) Transfer Protocol. If
# you have used a command-line
# [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html) program, and are
# familiar with the commands, you will be able to use this class easily. Some
# extra features are included to take advantage of Ruby's style and strengths.
#
# ## Example
#
# ```ruby
# require 'net/ftp'
# ```
#
# ### Example 1
#
# ```ruby
# ftp = Net::FTP.new('example.com')
# ftp.login
# files = ftp.chdir('pub/lang/ruby/contrib')
# files = ftp.list('n*')
# ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024)
# ftp.close
# ```
#
# ### Example 2
#
# ```ruby
# Net::FTP.open('example.com') do |ftp|
#   ftp.login
#   files = ftp.chdir('pub/lang/ruby/contrib')
#   files = ftp.list('n*')
#   ftp.getbinaryfile('nif.rb-0.91.gz', 'nif.gz', 1024)
# end
# ```
#
# ## Major Methods
#
# The following are the methods most likely to be useful to users:
# *   [`FTP.open`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-c-open)
# *   [`getbinaryfile`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-getbinaryfile)
# *   [`gettextfile`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-gettextfile)
# *   [`putbinaryfile`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-putbinaryfile)
# *   [`puttextfile`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-puttextfile)
# *   [`chdir`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-chdir)
# *   [`nlst`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-nlst)
# *   [`size`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-size)
# *   [`rename`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-rename)
# *   [`delete`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-delete)
class Net::FTP < Net::Protocol
  include ::OpenSSL::SSL
  include ::OpenSSL
  include ::MonitorMixin
  CASE_DEPENDENT_PARSER = ::T.let(nil, ::T.untyped)
  CASE_INDEPENDENT_PARSER = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  DECIMAL_PARSER = ::T.let(nil, ::T.untyped)
  DEFAULT_BLOCKSIZE = ::T.let(nil, ::T.untyped)
  FACT_PARSERS = ::T.let(nil, ::T.untyped)
  FTP_PORT = ::T.let(nil, ::T.untyped)
  OCTAL_PARSER = ::T.let(nil, ::T.untyped)
  TIME_PARSER = ::T.let(nil, ::T.untyped)

  # Aborts the previous command (ABOR command).
  sig {returns(::T.untyped)}
  def abort(); end

  # Sends the ACCT command.
  #
  # This is a less common
  # [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html) command, to send
  # account information if the destination host requires it.
  sig do
    params(
      account: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def acct(account); end

  # When `true`, transfers are performed in binary mode. Default: `true`.
  sig {returns(::T.untyped)}
  def binary(); end

  # A setter to toggle transfers in binary mode. `newmode` is either `true` or
  # `false`
  sig do
    params(
      newmode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def binary=(newmode); end

  # Changes the (remote) directory.
  sig do
    params(
      dirname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def chdir(dirname); end

  # Closes the connection. Further operations are impossible until you open a
  # new connection with
  # [`connect`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-connect).
  sig {returns(::T.untyped)}
  def close(); end

  # Returns `true` iff the connection is closed.
  sig {returns(::T.untyped)}
  def closed?(); end

  # Establishes an [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html)
  # connection to host, optionally overriding the default port. If the
  # environment variable `SOCKS_SERVER` is set, sets up the connection through a
  # SOCKS proxy. Raises an exception (typically `Errno::ECONNREFUSED`) if the
  # connection cannot be established.
  sig do
    params(
      host: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connect(host, port=T.unsafe(nil)); end

  # When `true`, all traffic to and from the server is written to +$stdout+.
  # Default: `false`.
  sig {returns(::T.untyped)}
  def debug_mode(); end

  # When `true`, all traffic to and from the server is written to +$stdout+.
  # Default: `false`.
  sig do
    params(
      debug_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_mode=(debug_mode); end

  # Deletes a file on the server.
  sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(filename); end

  # Alias for:
  # [`list`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-list)
  sig do
    params(
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dir(*args, &block); end

  # Retrieves `remotefile` in whatever mode the session is set (text or binary).
  # See
  # [`gettextfile`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-gettextfile)
  # and
  # [`getbinaryfile`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-getbinaryfile).
  sig do
    params(
      remotefile: ::T.untyped,
      localfile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get(remotefile, localfile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  # Retrieves `remotefile` in binary mode, storing the result in `localfile`. If
  # `localfile` is nil, returns retrieved data. If a block is supplied, it is
  # passed the retrieved data in `blocksize` chunks.
  sig do
    params(
      remotefile: ::T.untyped,
      localfile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getbinaryfile(remotefile, localfile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  # Alias for:
  # [`pwd`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-pwd)
  sig {returns(::T.untyped)}
  def getdir(); end

  # Retrieves `remotefile` in ASCII (text) mode, storing the result in
  # `localfile`. If `localfile` is nil, returns retrieved data. If a block is
  # supplied, it is passed the retrieved data one line at a time.
  sig do
    params(
      remotefile: ::T.untyped,
      localfile: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def gettextfile(remotefile, localfile=T.unsafe(nil), &block); end

  # Issues the HELP command.
  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def help(arg=T.unsafe(nil)); end

  sig do
    params(
      host: ::T.untyped,
      user_or_options: ::T.untyped,
      passwd: ::T.untyped,
      acct: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(host=T.unsafe(nil), user_or_options=T.unsafe(nil), passwd=T.unsafe(nil), acct=T.unsafe(nil)); end

  # The server's last response.
  sig {returns(::T.untyped)}
  def last_response(); end

  # The server's last response code.
  sig {returns(::T.untyped)}
  def last_response_code(); end

  # The server's last response code.
  sig {returns(::T.untyped)}
  def lastresp(); end

  # Returns an array of file information in the directory (the output is like
  # `ls -l`). If a block is given, it iterates through the listing.
  #
  # Also aliased as:
  # [`ls`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-ls),
  # [`dir`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-dir)
  sig do
    params(
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def list(*args, &block); end

  # Logs in to the remote host. The session must have been previously connected.
  # If `user` is the string "anonymous" and the `password` is `nil`,
  # "anonymous@" is used as a password. If the `acct` parameter is not `nil`, an
  # [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html) ACCT command is
  # sent following the successful login. Raises an exception on error (typically
  # `Net::FTPPermError`).
  sig do
    params(
      user: ::T.untyped,
      passwd: ::T.untyped,
      acct: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def login(user=T.unsafe(nil), passwd=T.unsafe(nil), acct=T.unsafe(nil)); end

  # Alias for:
  # [`list`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-list)
  sig do
    params(
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ls(*args, &block); end

  # Returns the raw last modification time of the (remote) file in the format
  # "YYYYMMDDhhmmss" (MDTM command).
  #
  # Use `mtime` if you want a parsed
  # [`Time`](https://docs.ruby-lang.org/en/2.6.0/Time.html) instance.
  sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mdtm(filename); end

  # Creates a remote directory.
  sig do
    params(
      dirname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkdir(dirname); end

  # Returns an array of the entries of the directory specified by `pathname`.
  # Each entry has the facts (e.g., size, last modification time, etc.) and the
  # pathname. If a block is given, it iterates through the listing. If
  # `pathname` is omitted, the current directory is assumed.
  sig do
    params(
      pathname: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mlsd(pathname=T.unsafe(nil), &block); end

  # Returns data (e.g., size, last modification time, entry type, etc.) about
  # the file or directory specified by `pathname`. If `pathname` is omitted, the
  # current directory is assumed.
  sig do
    params(
      pathname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mlst(pathname=T.unsafe(nil)); end

  # Returns the last modification time of the (remote) file. If `local` is
  # `true`, it is returned as a local time, otherwise it's a UTC time.
  sig do
    params(
      filename: ::T.untyped,
      local: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mtime(filename, local=T.unsafe(nil)); end

  # Returns an array of filenames in the remote directory.
  sig do
    params(
      dir: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def nlst(dir=T.unsafe(nil)); end

  # Issues a NOOP command.
  #
  # Does nothing except return a response.
  sig {returns(::T.untyped)}
  def noop(); end

  # Number of seconds to wait for the connection to open. Any number may be
  # used, including Floats for fractional seconds. If the
  # [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html) object cannot open
  # a connection in this many seconds, it raises a
  # [`Net::OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html)
  # exception. The default value is `nil`.
  sig {returns(::T.untyped)}
  def open_timeout(); end

  # Number of seconds to wait for the connection to open. Any number may be
  # used, including Floats for fractional seconds. If the
  # [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html) object cannot open
  # a connection in this many seconds, it raises a
  # [`Net::OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html)
  # exception. The default value is `nil`.
  sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  # When `true`, the connection is in passive mode. Default: `true`.
  sig {returns(::T.untyped)}
  def passive(); end

  # When `true`, the connection is in passive mode. Default: `true`.
  sig do
    params(
      passive: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def passive=(passive); end

  # Transfers `localfile` to the server in whatever mode the session is set
  # (text or binary). See
  # [`puttextfile`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-puttextfile)
  # and
  # [`putbinaryfile`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-putbinaryfile).
  sig do
    params(
      localfile: ::T.untyped,
      remotefile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def put(localfile, remotefile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  # Transfers `localfile` to the server in binary mode, storing the result in
  # `remotefile`. If a block is supplied, calls it, passing in the transmitted
  # data in `blocksize` chunks.
  sig do
    params(
      localfile: ::T.untyped,
      remotefile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def putbinaryfile(localfile, remotefile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  # Transfers `localfile` to the server in ASCII (text) mode, storing the result
  # in `remotefile`. If callback or an associated block is supplied, calls it,
  # passing in the transmitted data one line at a time.
  sig do
    params(
      localfile: ::T.untyped,
      remotefile: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def puttextfile(localfile, remotefile=T.unsafe(nil), &block); end

  # Returns the current remote directory.
  #
  # Also aliased as:
  # [`getdir`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#method-i-getdir)
  sig {returns(::T.untyped)}
  def pwd(); end

  # Exits the [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html) session.
  sig {returns(::T.untyped)}
  def quit(); end

  # Number of seconds to wait for one block to be read (via one read(2) call).
  # Any number may be used, including Floats for fractional seconds. If the
  # [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html) object cannot read
  # data in this many seconds, it raises a
  # [`Timeout::Error`](https://docs.ruby-lang.org/en/2.6.0/Timeout/Error.html)
  # exception. The default value is 60 seconds.
  sig {returns(::T.untyped)}
  def read_timeout(); end

  # Setter for the
  # [`read_timeout`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html#attribute-i-read_timeout)
  # attribute.
  sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end

  # Renames a file on the server.
  sig do
    params(
      fromname: ::T.untyped,
      toname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(fromname, toname); end

  # Sets or retrieves the `resume` status, which decides whether incomplete
  # transfers are resumed or restarted. Default: `false`.
  sig {returns(::T.untyped)}
  def resume(); end

  # Sets or retrieves the `resume` status, which decides whether incomplete
  # transfers are resumed or restarted. Default: `false`.
  sig do
    params(
      resume: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def resume=(resume); end

  # Puts the connection into binary (image) mode, issues the given command, and
  # fetches the data returned, passing it to the associated block in chunks of
  # `blocksize` characters. Note that `cmd` is a server command (such as "RETR
  # myfile").
  sig do
    params(
      cmd: ::T.untyped,
      blocksize: ::T.untyped,
      rest_offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retrbinary(cmd, blocksize, rest_offset=T.unsafe(nil)); end

  # Puts the connection into ASCII (text) mode, issues the given command, and
  # passes the resulting data, one line at a time, to the associated block. If
  # no block is given, prints the lines. Note that `cmd` is a server command
  # (such as "RETR myfile").
  sig do
    params(
      cmd: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retrlines(cmd); end

  sig {returns(::T.untyped)}
  def return_code(); end

  sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def return_code=(s); end

  # Removes a remote directory.
  sig do
    params(
      dirname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rmdir(dirname); end

  # Sends a command and returns the response.
  sig do
    params(
      cmd: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sendcmd(cmd); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) the socket used to
  # connect to the [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html)
  # server.
  #
  # May raise FTPReplyError if `get_greeting` is false.
  sig do
    params(
      sock: ::T.untyped,
      get_greeting: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_socket(sock, get_greeting=T.unsafe(nil)); end

  # Issues a SITE command.
  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def site(arg); end

  # Returns the size of the given (remote) filename.
  sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size(filename); end

  # Number of seconds to wait for the TLS handshake. Any number may be used,
  # including Floats for fractional seconds. If the
  # [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html) object cannot
  # complete the TLS handshake in this many seconds, it raises a
  # [`Net::OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html)
  # exception. The default value is `nil`. If `ssl_handshake_timeout` is `nil`,
  # `open_timeout` is used instead.
  sig {returns(::T.untyped)}
  def ssl_handshake_timeout(); end

  # Number of seconds to wait for the TLS handshake. Any number may be used,
  # including Floats for fractional seconds. If the
  # [`FTP`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP.html) object cannot
  # complete the TLS handshake in this many seconds, it raises a
  # [`Net::OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html)
  # exception. The default value is `nil`. If `ssl_handshake_timeout` is `nil`,
  # `open_timeout` is used instead.
  sig do
    params(
      ssl_handshake_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_handshake_timeout=(ssl_handshake_timeout); end

  # Returns the status (STAT command). pathname - when stat is invoked with
  # pathname as a parameter it acts like
  #
  # ```
  # list but alot faster and over the same tcp session.
  # ```
  sig do
    params(
      pathname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def status(pathname=T.unsafe(nil)); end

  # Puts the connection into binary (image) mode, issues the given server-side
  # command (such as "STOR myfile"), and sends the contents of the file named
  # `file` to the server. If the optional block is given, it also passes it the
  # data, in chunks of `blocksize` characters.
  sig do
    params(
      cmd: ::T.untyped,
      file: ::T.untyped,
      blocksize: ::T.untyped,
      rest_offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def storbinary(cmd, file, blocksize, rest_offset=T.unsafe(nil)); end

  # Puts the connection into ASCII (text) mode, issues the given server-side
  # command (such as "STOR myfile"), and sends the contents of the file named
  # `file` to the server, one line at a time. If the optional block is given, it
  # also passes it the lines.
  sig do
    params(
      cmd: ::T.untyped,
      file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def storlines(cmd, file); end

  # Returns system information.
  sig {returns(::T.untyped)}
  def system(); end

  # Sends a command and expect a response beginning with '2'.
  sig do
    params(
      cmd: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def voidcmd(cmd); end

  # The server's welcome message.
  sig {returns(::T.untyped)}
  def welcome(); end

  # When `true`, connections are in passive mode per default. Default: `true`.
  sig {returns(::T.untyped)}
  def self.default_passive(); end

  # When `true`, connections are in passive mode per default. Default: `true`.
  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.default_passive=(value); end

  # A synonym for `FTP.new`, but with a mandatory host parameter.
  #
  # If a block is given, it is passed the `FTP` object, which will be closed
  # when the block finishes, or when an exception is raised.
  sig do
    params(
      host: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.open(host, *args); end
end

class Net::FTP::BufferedSSLSocket < Net::FTP::BufferedSocket
  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end

  sig do
    params(
      mesg: ::T.untyped,
      flags: ::T.untyped,
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send(mesg, flags, dest=T.unsafe(nil)); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def shutdown(*args); end
end

class Net::FTP::BufferedSocket < Net::BufferedIO
  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def addr(*args); end

  sig {returns(::T.untyped)}
  def gets(); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local_address(*args); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def peeraddr(*args); end

  sig do
    params(
      len: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(len=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def readline(); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote_address(*args); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send(*args); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def shutdown(*args); end
end

# [`MLSxEntry`](https://docs.ruby-lang.org/en/2.6.0/Net/FTP/MLSxEntry.html)
# represents an entry in responses of MLST/MLSD. Each entry has the facts (e.g.,
# size, last modification time, etc.) and the pathname.
class Net::FTP::MLSxEntry
  # Returns `true` if the APPE command may be applied to the file.
  sig {returns(::T.untyped)}
  def appendable?(); end

  sig {returns(::T.untyped)}
  def charset(); end

  # Returns `true` if files may be created in the directory by STOU, STOR, APPE,
  # and RNTO.
  sig {returns(::T.untyped)}
  def creatable?(); end

  sig {returns(::T.untyped)}
  def create(); end

  # Returns `true` if the file or directory may be deleted by DELE/RMD.
  sig {returns(::T.untyped)}
  def deletable?(); end

  # Returns `true` if the entry is a directory (i.e., the value of the type fact
  # is dir, cdir, or pdir).
  sig {returns(::T.untyped)}
  def directory?(); end

  # Returns `true` if the MKD command may be used to create a new directory
  # within the directory.
  sig {returns(::T.untyped)}
  def directory_makable?(); end

  # Returns `true` if the directory may be entered by CWD/CDUP.
  sig {returns(::T.untyped)}
  def enterable?(); end

  sig {returns(::T.untyped)}
  def facts(); end

  # Returns `true` if the entry is a file (i.e., the value of the type fact is
  # file).
  sig {returns(::T.untyped)}
  def file?(); end

  sig do
    params(
      facts: ::T.untyped,
      pathname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(facts, pathname); end

  sig {returns(::T.untyped)}
  def lang(); end

  # Returns `true` if the listing commands, LIST, NLST, and MLSD are applied to
  # the directory.
  sig {returns(::T.untyped)}
  def listable?(); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig {returns(::T.untyped)}
  def modify(); end

  sig {returns(::T.untyped)}
  def pathname(); end

  sig {returns(::T.untyped)}
  def perm(); end

  # Returns `true` if the objects in the directory may be deleted, or the
  # directory may be purged.
  sig {returns(::T.untyped)}
  def purgeable?(); end

  # Returns `true` if the RETR command may be applied to the file.
  sig {returns(::T.untyped)}
  def readable?(); end

  # Returns `true` if the file or directory may be renamed by RNFR.
  sig {returns(::T.untyped)}
  def renamable?(); end

  sig {returns(::T.untyped)}
  def size(); end

  sig {returns(::T.untyped)}
  def type(); end

  sig {returns(::T.untyped)}
  def unique(); end

  # Returns `true` if the STOR command may be applied to the file.
  sig {returns(::T.untyped)}
  def writable?(); end
end

class Net::FTP::NullSocket
  sig {returns(::T.untyped)}
  def close(); end

  sig {returns(::T.untyped)}
  def closed?(); end

  sig do
    params(
      mid: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def method_missing(mid, *args); end

  sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end
end

class Net::FTPConnectionError < Net::FTPError
end

class Net::FTPError < StandardError
end

class Net::FTPPermError < Net::FTPError
end

class Net::FTPProtoError < Net::FTPError
end

class Net::FTPReplyError < Net::FTPError
end

class Net::FTPTempError < Net::FTPError
end

# ## An [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) client API for Ruby.
#
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) provides a
# rich library which can be used to build
# [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) user-agents. For
# more details about [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html)
# see [RFC2616](http://www.ietf.org/rfc/rfc2616.txt).
#
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) is designed
# to work closely with [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html).
# [`URI::HTTP#host`](https://docs.ruby-lang.org/en/2.6.0/URI/Generic.html#attribute-i-host),
# [`URI::HTTP#port`](https://docs.ruby-lang.org/en/2.6.0/URI/Generic.html#attribute-i-port)
# and
# [`URI::HTTP#request_uri`](https://docs.ruby-lang.org/en/2.6.0/URI/HTTP.html#method-i-request_uri)
# are designed to work with
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html).
#
# If you are only performing a few GET requests you should try
# [`OpenURI`](https://docs.ruby-lang.org/en/2.6.0/OpenURI.html).
#
# ## Simple Examples
#
# All examples assume you have loaded
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) with:
#
# ```ruby
# require 'net/http'
# ```
#
# This will also require 'uri' so you don't need to require it separately.
#
# The [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) methods
# in the following section do not persist connections. They are not recommended
# if you are performing many
# [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) requests.
#
# ### GET
#
# ```ruby
# Net::HTTP.get('example.com', '/index.html') # => String
# ```
#
# ### GET by [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html)
#
# ```ruby
# uri = URI('http://example.com/index.html?count=10')
# Net::HTTP.get(uri) # => String
# ```
#
# ### GET with Dynamic Parameters
#
# ```ruby
# uri = URI('http://example.com/index.html')
# params = { :limit => 10, :page => 3 }
# uri.query = URI.encode_www_form(params)
#
# res = Net::HTTP.get_response(uri)
# puts res.body if res.is_a?(Net::HTTPSuccess)
# ```
#
# ### POST
#
# ```ruby
# uri = URI('http://www.example.com/search.cgi')
# res = Net::HTTP.post_form(uri, 'q' => 'ruby', 'max' => '50')
# puts res.body
# ```
#
# ### POST with Multiple Values
#
# ```ruby
# uri = URI('http://www.example.com/search.cgi')
# res = Net::HTTP.post_form(uri, 'q' => ['ruby', 'perl'], 'max' => '50')
# puts res.body
# ```
#
# ## How to use [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html)
#
# The following example code can be used as the basis of an
# [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) user-agent which
# can perform a variety of request types using persistent connections.
#
# ```ruby
# uri = URI('http://example.com/some_path?query=string')
#
# Net::HTTP.start(uri.host, uri.port) do |http|
#   request = Net::HTTP::Get.new uri
#
#   response = http.request request # Net::HTTPResponse object
# end
# ```
#
# [`Net::HTTP::start`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-c-start)
# immediately creates a connection to an
# [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) server which is
# kept open for the duration of the block. The connection will remain open for
# multiple requests in the block if the server indicates it supports persistent
# connections.
#
# If you wish to re-use a connection across multiple
# [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) requests without
# automatically closing it you can use
# [`::new`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-c-new) and
# then call
# [`start`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-start)
# and
# [`finish`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-finish)
# manually.
#
# The request types
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) supports are
# listed below in the section "HTTP Request Classes".
#
# For all the [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html)
# request objects and shortcut request methods you may supply either a
# [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html) for the request
# path or a [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html) from which
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) will extract
# the request path.
#
# ### Response [`Data`](https://docs.ruby-lang.org/en/2.6.0/Data.html)
#
# ```ruby
# uri = URI('http://example.com/index.html')
# res = Net::HTTP.get_response(uri)
#
# # Headers
# res['Set-Cookie']            # => String
# res.get_fields('set-cookie') # => Array
# res.to_hash['set-cookie']    # => Array
# puts "Headers: #{res.to_hash.inspect}"
#
# # Status
# puts res.code       # => '200'
# puts res.message    # => 'OK'
# puts res.class.name # => 'HTTPOK'
#
# # Body
# puts res.body if res.response_body_permitted?
# ```
#
# ### Following Redirection
#
# Each
# [`Net::HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
# object belongs to a class for its response code.
#
# For example, all 2XX responses are instances of a
# [`Net::HTTPSuccess`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPSuccess.html)
# subclass, a 3XX response is an instance of a
# [`Net::HTTPRedirection`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPRedirection.html)
# subclass and a 200 response is an instance of the
# [`Net::HTTPOK`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPOK.html) class.
# For details of response classes, see the section "HTTP Response Classes"
# below.
#
# Using a case statement you can handle various types of responses properly:
#
# ```ruby
# def fetch(uri_str, limit = 10)
#   # You should choose a better exception.
#   raise ArgumentError, 'too many HTTP redirects' if limit == 0
#
#   response = Net::HTTP.get_response(URI(uri_str))
#
#   case response
#   when Net::HTTPSuccess then
#     response
#   when Net::HTTPRedirection then
#     location = response['location']
#     warn "redirected to #{location}"
#     fetch(location, limit - 1)
#   else
#     response.value
#   end
# end
#
# print fetch('http://www.ruby-lang.org')
# ```
#
# ### POST
#
# A POST can be made using the
# [`Net::HTTP::Post`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Post.html)
# request class. This example creates a URL encoded POST body:
#
# ```ruby
# uri = URI('http://www.example.com/todo.cgi')
# req = Net::HTTP::Post.new(uri)
# req.set_form_data('from' => '2005-01-01', 'to' => '2005-03-31')
#
# res = Net::HTTP.start(uri.hostname, uri.port) do |http|
#   http.request(req)
# end
#
# case res
# when Net::HTTPSuccess, Net::HTTPRedirection
#   # OK
# else
#   res.value
# end
# ```
#
# To send multipart/form-data use
# [`Net::HTTPHeader#set_form`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-set_form):
#
# ```ruby
# req = Net::HTTP::Post.new(uri)
# req.set_form([['upload', File.open('foo.bar')]], 'multipart/form-data')
# ```
#
# Other requests that can contain a body such as PUT can be created in the same
# way using the corresponding request class (Net::HTTP::Put).
#
# ### Setting Headers
#
# The following example performs a conditional GET using the If-Modified-Since
# header. If the files has not been modified since the time in the header a Not
# Modified response will be returned. See RFC 2616 section 9.3 for further
# details.
#
# ```ruby
# uri = URI('http://example.com/cached_response')
# file = File.stat 'cached_response'
#
# req = Net::HTTP::Get.new(uri)
# req['If-Modified-Since'] = file.mtime.rfc2822
#
# res = Net::HTTP.start(uri.hostname, uri.port) {|http|
#   http.request(req)
# }
#
# open 'cached_response', 'w' do |io|
#   io.write res.body
# end if res.is_a?(Net::HTTPSuccess)
# ```
#
# ### Basic Authentication
#
# Basic authentication is performed according to
# [RFC2617](http://www.ietf.org/rfc/rfc2617.txt).
#
# ```ruby
# uri = URI('http://example.com/index.html?key=value')
#
# req = Net::HTTP::Get.new(uri)
# req.basic_auth 'user', 'pass'
#
# res = Net::HTTP.start(uri.hostname, uri.port) {|http|
#   http.request(req)
# }
# puts res.body
# ```
#
# ### Streaming Response Bodies
#
# By default [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html)
# reads an entire response into memory. If you are handling large files or wish
# to implement a progress bar you can instead stream the body directly to an
# [`IO`](https://docs.ruby-lang.org/en/2.6.0/IO.html).
#
# ```ruby
# uri = URI('http://example.com/large_file')
#
# Net::HTTP.start(uri.host, uri.port) do |http|
#   request = Net::HTTP::Get.new uri
#
#   http.request request do |response|
#     open 'large_file', 'w' do |io|
#       response.read_body do |chunk|
#         io.write chunk
#       end
#     end
#   end
# end
# ```
#
# ### HTTPS
#
# HTTPS is enabled for an
# [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) connection by
# [`Net::HTTP#use_ssl=`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-use_ssl-3D).
#
# ```ruby
# uri = URI('https://secure.example.com/some_path?query=string')
#
# Net::HTTP.start(uri.host, uri.port, :use_ssl => true) do |http|
#   request = Net::HTTP::Get.new uri
#   response = http.request request # Net::HTTPResponse object
# end
# ```
#
# Or if you simply want to make a GET request, you may pass in an
# [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html) object that has an HTTPS
# URL. [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html)
# automatically turns on TLS verification if the
# [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html) object has a 'https'
# [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html) scheme.
#
# ```ruby
# uri = URI('https://example.com/')
# Net::HTTP.get(uri) # => String
# ```
#
# In previous versions of Ruby you would need to require 'net/https' to use
# HTTPS. This is no longer true.
#
# ### Proxies
#
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) will
# automatically create a proxy from the `http_proxy` environment variable if it
# is present. To disable use of `http_proxy`, pass `nil` for the proxy address.
#
# You may also create a custom proxy:
#
# ```ruby
# proxy_addr = 'your.proxy.host'
# proxy_port = 8080
#
# Net::HTTP.new('example.com', nil, proxy_addr, proxy_port).start { |http|
#   # always proxy via your.proxy.addr:8080
# }
# ```
#
# See
# [`Net::HTTP.new`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-c-new)
# for further details and examples such as proxies that require a username and
# password.
#
# ### Compression
#
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) automatically
# adds Accept-Encoding for compression of response bodies and automatically
# decompresses gzip and deflate responses unless a
# [`Range`](https://docs.ruby-lang.org/en/2.6.0/Range.html) header was sent.
#
# Compression can be disabled through the Accept-Encoding: identity header.
#
# ## [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) Request Classes
#
# Here is the [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html)
# request class hierarchy.
#
# *   [`Net::HTTPRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPRequest.html)
#     *   [`Net::HTTP::Get`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Get.html)
#     *   [`Net::HTTP::Head`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Head.html)
#     *   [`Net::HTTP::Post`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Post.html)
#     *   [`Net::HTTP::Patch`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Patch.html)
#     *   [`Net::HTTP::Put`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Put.html)
#     *   [`Net::HTTP::Proppatch`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Proppatch.html)
#     *   [`Net::HTTP::Lock`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Lock.html)
#     *   [`Net::HTTP::Unlock`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Unlock.html)
#     *   [`Net::HTTP::Options`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Options.html)
#     *   [`Net::HTTP::Propfind`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Propfind.html)
#     *   [`Net::HTTP::Delete`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Delete.html)
#     *   [`Net::HTTP::Move`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Move.html)
#     *   [`Net::HTTP::Copy`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Copy.html)
#     *   [`Net::HTTP::Mkcol`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Mkcol.html)
#     *   [`Net::HTTP::Trace`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Trace.html)
#
#
#
# ## [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) Response Classes
#
# Here is [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) response
# class hierarchy. All classes are defined in
# [`Net`](https://docs.ruby-lang.org/en/2.6.0/Net.html) module and are
# subclasses of
# [`Net::HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html).
#
# HTTPUnknownResponse
# :   For unhandled [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html)
#     extensions
# HTTPInformation
# :   1xx
# HTTPContinue
# :   100
# HTTPSwitchProtocol
# :   101
# HTTPSuccess
# :   2xx
# HTTPOK
# :   200
# HTTPCreated
# :   201
# HTTPAccepted
# :   202
# HTTPNonAuthoritativeInformation
# :   203
# HTTPNoContent
# :   204
# HTTPResetContent
# :   205
# HTTPPartialContent
# :   206
# HTTPMultiStatus
# :   207
# HTTPIMUsed
# :   226
# HTTPRedirection
# :   3xx
# HTTPMultipleChoices
# :   300
# HTTPMovedPermanently
# :   301
# HTTPFound
# :   302
# HTTPSeeOther
# :   303
# HTTPNotModified
# :   304
# HTTPUseProxy
# :   305
# HTTPTemporaryRedirect
# :   307
# HTTPClientError
# :   4xx
# HTTPBadRequest
# :   400
# HTTPUnauthorized
# :   401
# HTTPPaymentRequired
# :   402
# HTTPForbidden
# :   403
# HTTPNotFound
# :   404
# HTTPMethodNotAllowed
# :   405
# HTTPNotAcceptable
# :   406
# HTTPProxyAuthenticationRequired
# :   407
# [`HTTPRequestTimeOut`](https://docs.ruby-lang.org/en/2.6.0/HTTPRequestTimeOut.html)
# :   408
# HTTPConflict
# :   409
# HTTPGone
# :   410
# HTTPLengthRequired
# :   411
# HTTPPreconditionFailed
# :   412
# [`HTTPRequestEntityTooLarge`](https://docs.ruby-lang.org/en/2.6.0/HTTPRequestEntityTooLarge.html)
# :   413
# [`HTTPRequestURITooLong`](https://docs.ruby-lang.org/en/2.6.0/HTTPRequestURITooLong.html)
# :   414
# HTTPUnsupportedMediaType
# :   415
# [`HTTPRequestedRangeNotSatisfiable`](https://docs.ruby-lang.org/en/2.6.0/HTTPRequestedRangeNotSatisfiable.html)
# :   416
# HTTPExpectationFailed
# :   417
# HTTPUnprocessableEntity
# :   422
# HTTPLocked
# :   423
# HTTPFailedDependency
# :   424
# HTTPUpgradeRequired
# :   426
# HTTPPreconditionRequired
# :   428
# HTTPTooManyRequests
# :   429
# HTTPRequestHeaderFieldsTooLarge
# :   431
# HTTPUnavailableForLegalReasons
# :   451
# HTTPServerError
# :   5xx
# HTTPInternalServerError
# :   500
# HTTPNotImplemented
# :   501
# HTTPBadGateway
# :   502
# HTTPServiceUnavailable
# :   503
# [`HTTPGatewayTimeOut`](https://docs.ruby-lang.org/en/2.6.0/HTTPGatewayTimeOut.html)
# :   504
# HTTPVersionNotSupported
# :   505
# HTTPInsufficientStorage
# :   507
# HTTPNetworkAuthenticationRequired
# :   511
#
#
# There is also the
# [`Net::HTTPBadResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPBadResponse.html)
# exception which is raised when there is a protocol error.
class Net::HTTP < Net::Protocol
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
  HTTPVersion = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS_ = ::T.let(nil, ::T.untyped)
  Revision = ::T.let(nil, ::T.untyped)
  SSL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SSL_IVNAMES = ::T.let(nil, ::T.untyped)

  # Alias for:
  # [`started?`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-started-3F)
  sig {returns(::T.untyped)}
  def active?(); end

  # The DNS host name or IP address to connect to.
  sig {returns(::T.untyped)}
  def address(); end

  # Sets path of a CA certification file in PEM format.
  #
  # The file can contain several CA certificates.
  sig {returns(::T.untyped)}
  def ca_file(); end

  # Sets path of a CA certification file in PEM format.
  #
  # The file can contain several CA certificates.
  sig do
    params(
      ca_file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ca_file=(ca_file); end

  # Sets path of a CA certification directory containing certifications in PEM
  # format.
  sig {returns(::T.untyped)}
  def ca_path(); end

  # Sets path of a CA certification directory containing certifications in PEM
  # format.
  sig do
    params(
      ca_path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ca_path=(ca_path); end

  # Sets an
  # [`OpenSSL::X509::Certificate`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/X509/Certificate.html)
  # object as client certificate. (This method is appeared in Michal Rokos's
  # [`OpenSSL`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL.html) extension).
  sig {returns(::T.untyped)}
  def cert(); end

  # Sets an
  # [`OpenSSL::X509::Certificate`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/X509/Certificate.html)
  # object as client certificate. (This method is appeared in Michal Rokos's
  # [`OpenSSL`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL.html) extension).
  sig do
    params(
      cert: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert=(cert); end

  # Sets the X509::Store to verify peer certificate.
  sig {returns(::T.untyped)}
  def cert_store(); end

  # Sets the X509::Store to verify peer certificate.
  sig do
    params(
      cert_store: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert_store=(cert_store); end

  # Sets the available ciphers. See
  # [`OpenSSL::SSL::SSLContext#ciphers=`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/SSL/SSLContext.html#method-i-ciphers-3D)
  sig {returns(::T.untyped)}
  def ciphers(); end

  # Sets the available ciphers. See
  # [`OpenSSL::SSL::SSLContext#ciphers=`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/SSL/SSLContext.html#method-i-ciphers-3D)
  sig do
    params(
      ciphers: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ciphers=(ciphers); end

  sig {returns(::T.untyped)}
  def close_on_empty_response(); end

  sig do
    params(
      close_on_empty_response: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def close_on_empty_response=(close_on_empty_response); end

  # Seconds to wait for 100 Continue response. If the
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) object does not
  # receive a response in this many seconds it sends the request body. The
  # default value is `nil`.
  sig {returns(::T.untyped)}
  def continue_timeout(); end

  # Setter for the
  # [`continue_timeout`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-continue_timeout)
  # attribute.
  sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def continue_timeout=(sec); end

  # Sends a COPY request to the `path` and gets a response, as an HTTPResponse
  # object.
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def copy(path, initheader=T.unsafe(nil)); end

  # Sends a DELETE request to the `path` and gets a response, as an HTTPResponse
  # object.
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(path, initheader=T.unsafe(nil)); end

  # Finishes the [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html)
  # session and closes the TCP connection. Raises
  # [`IOError`](https://docs.ruby-lang.org/en/2.6.0/IOError.html) if the session
  # has not been started.
  sig {returns(::T.untyped)}
  def finish(); end

  # Retrieves data from `path` on the connected-to host which may be an absolute
  # path [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html) or a
  # [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html) to extract the path
  # from.
  #
  # `initheader` must be a
  # [`Hash`](https://docs.ruby-lang.org/en/2.6.0/Hash.html) like { 'Accept' =>
  # '**/**', ... }, and it defaults to an empty hash. If `initheader` doesn't
  # have the key 'accept-encoding', then a value of
  # "gzip;q=1.0,deflate;q=0.6,identity;q=0.3" is used, so that gzip compression
  # is used in preference to deflate compression, which is used in preference to
  # no compression. Ruby doesn't have libraries to support the compress
  # (Lempel-Ziv) compression, so that is not supported. The intent of this is to
  # reduce bandwidth by default.  If this routine sets up compression, then it
  # does the decompression also, removing the header as well to prevent
  # confusion. Otherwise it leaves the body as it found it.
  #
  # This method returns a
  # [`Net::HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
  # object.
  #
  # If called with a block, yields each fragment of the entity body in turn as a
  # string as it is read from the socket. Note that in this case, the returned
  # response object will **not** contain a (meaningful) body.
  #
  # `dest` argument is obsolete. It still works but you must not use it.
  #
  # This method never raises an exception.
  #
  # ```ruby
  # response = http.get('/index.html')
  #
  # # using block
  # File.open('result.txt', 'w') {|f|
  #   http.get('/~foo/') do |str|
  #     f.write str
  #   end
  # }
  # ```
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get(path, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  # Alias for:
  # [`request_get`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-request_get)
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get2(path, initheader=T.unsafe(nil), &block); end

  # Gets only the header from `path` on the connected-to host. `header` is a
  # [`Hash`](https://docs.ruby-lang.org/en/2.6.0/Hash.html) like { 'Accept' =>
  # '**/**', ... }.
  #
  # This method returns a
  # [`Net::HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
  # object.
  #
  # This method never raises an exception.
  #
  # ```ruby
  # response = nil
  # Net::HTTP.start('some.www.server', 80) {|http|
  #   response = http.head('/index.html')
  # }
  # p response['content-type']
  # ```
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def head(path, initheader=T.unsafe(nil)); end

  # Alias for:
  # [`request_head`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-request_head)
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def head2(path, initheader=T.unsafe(nil), &block); end

  sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(address, port=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  # Seconds to reuse the connection of the previous request. If the idle time is
  # less than this Keep-Alive
  # [`Timeout`](https://docs.ruby-lang.org/en/2.6.0/Timeout.html),
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) reuses the
  # TCP/IP socket used by the previous communication. The default value is 2
  # seconds.
  sig {returns(::T.untyped)}
  def keep_alive_timeout(); end

  # Seconds to reuse the connection of the previous request. If the idle time is
  # less than this Keep-Alive
  # [`Timeout`](https://docs.ruby-lang.org/en/2.6.0/Timeout.html),
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) reuses the
  # TCP/IP socket used by the previous communication. The default value is 2
  # seconds.
  sig do
    params(
      keep_alive_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def keep_alive_timeout=(keep_alive_timeout); end

  # Sets an
  # [`OpenSSL::PKey::RSA`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/PKey/RSA.html)
  # or
  # [`OpenSSL::PKey::DSA`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/PKey/DSA.html)
  # object. (This method is appeared in Michal Rokos's
  # [`OpenSSL`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL.html) extension.)
  sig {returns(::T.untyped)}
  def key(); end

  # Sets an
  # [`OpenSSL::PKey::RSA`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/PKey/RSA.html)
  # or
  # [`OpenSSL::PKey::DSA`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/PKey/DSA.html)
  # object. (This method is appeared in Michal Rokos's
  # [`OpenSSL`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL.html) extension.)
  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key=(key); end

  # The local host used to establish the connection.
  sig {returns(::T.untyped)}
  def local_host(); end

  # The local host used to establish the connection.
  sig do
    params(
      local_host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local_host=(local_host); end

  # The local port used to establish the connection.
  sig {returns(::T.untyped)}
  def local_port(); end

  # The local port used to establish the connection.
  sig do
    params(
      local_port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local_port=(local_port); end

  # Sends a LOCK request to the `path` and gets a response, as an HTTPResponse
  # object.
  sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lock(path, body, initheader=T.unsafe(nil)); end

  # Sends a MKCOL request to the `path` and gets a response, as an HTTPResponse
  # object.
  sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkcol(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  # Sends a MOVE request to the `path` and gets a response, as an HTTPResponse
  # object.
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def move(path, initheader=T.unsafe(nil)); end

  # Number of seconds to wait for the connection to open. Any number may be
  # used, including Floats for fractional seconds. If the
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) object cannot
  # open a connection in this many seconds, it raises a
  # [`Net::OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html)
  # exception. The default value is 60 seconds.
  sig {returns(::T.untyped)}
  def open_timeout(); end

  # Number of seconds to wait for the connection to open. Any number may be
  # used, including Floats for fractional seconds. If the
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) object cannot
  # open a connection in this many seconds, it raises a
  # [`Net::OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html)
  # exception. The default value is 60 seconds.
  sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  # Sends a OPTIONS request to the `path` and gets a response, as an
  # HTTPResponse object.
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def options(path, initheader=T.unsafe(nil)); end

  # Sends a PATCH request to the `path` and gets a response, as an HTTPResponse
  # object.
  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def patch(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  # Returns the X.509 certificates the server presented.
  sig {returns(::T.untyped)}
  def peer_cert(); end

  # The port number to connect to.
  sig {returns(::T.untyped)}
  def port(); end

  # Posts `data` (must be a
  # [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html)) to `path`.
  # `header` must be a [`Hash`](https://docs.ruby-lang.org/en/2.6.0/Hash.html)
  # like { 'Accept' => '**/**', ... }.
  #
  # This method returns a
  # [`Net::HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
  # object.
  #
  # If called with a block, yields each fragment of the entity body in turn as a
  # string as it is read from the socket. Note that in this case, the returned
  # response object will **not** contain a (meaningful) body.
  #
  # `dest` argument is obsolete. It still works but you must not use it.
  #
  # This method never raises exception.
  #
  # ```ruby
  # response = http.post('/cgi-bin/search.rb', 'query=foo')
  #
  # # using block
  # File.open('result.txt', 'w') {|f|
  #   http.post('/cgi-bin/search.rb', 'query=foo') do |str|
  #     f.write str
  #   end
  # }
  # ```
  #
  # You should set Content-Type: header field for POST. If no Content-Type:
  # field given, this method uses "application/x-www-form-urlencoded" by
  # default.
  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def post(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  # Alias for:
  # [`request_post`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-request_post)
  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def post2(path, data, initheader=T.unsafe(nil), &block); end

  # Sends a PROPFIND request to the `path` and gets a response, as an
  # HTTPResponse object.
  sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def propfind(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  # Sends a PROPPATCH request to the `path` and gets a response, as an
  # HTTPResponse object.
  sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proppatch(path, body, initheader=T.unsafe(nil)); end

  # True if requests for this connection will be proxied
  sig {returns(::T.untyped)}
  def proxy?(); end

  sig {returns(::T.untyped)}
  def proxy_address(); end

  sig do
    params(
      proxy_address: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_address=(proxy_address); end

  sig do
    params(
      proxy_from_env: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_from_env=(proxy_from_env); end

  # True if the proxy for this connection is determined from the environment
  sig {returns(::T.untyped)}
  def proxy_from_env?(); end

  sig {returns(::T.untyped)}
  def proxy_pass(); end

  sig do
    params(
      proxy_pass: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_pass=(proxy_pass); end

  sig {returns(::T.untyped)}
  def proxy_port(); end

  sig do
    params(
      proxy_port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_port=(proxy_port); end

  sig {returns(::T.untyped)}
  def proxy_uri(); end

  sig {returns(::T.untyped)}
  def proxy_user(); end

  sig do
    params(
      proxy_user: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_user=(proxy_user); end

  # Alias for:
  # [`proxy_address`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-proxy_address)
  sig {returns(::T.untyped)}
  def proxyaddr(); end

  # Alias for:
  # [`proxy_port`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-proxy_port)
  sig {returns(::T.untyped)}
  def proxyport(); end

  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def put(path, data, initheader=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def put2(path, data, initheader=T.unsafe(nil), &block); end

  # Number of seconds to wait for one block to be read (via one read(2) call).
  # Any number may be used, including Floats for fractional seconds. If the
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) object cannot
  # read data in this many seconds, it raises a
  # [`Net::ReadTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/ReadTimeout.html)
  # exception. The default value is 60 seconds.
  sig {returns(::T.untyped)}
  def read_timeout(); end

  # Setter for the
  # [`read_timeout`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-read_timeout)
  # attribute.
  sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end

  # Sends an HTTPRequest object `req` to the
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) server.
  #
  # If `req` is a
  # [`Net::HTTP::Post`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Post.html)
  # or [`Net::HTTP::Put`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Put.html)
  # request containing data, the data is also sent. Providing data for a
  # [`Net::HTTP::Head`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Head.html)
  # or [`Net::HTTP::Get`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Get.html)
  # request results in an
  # [`ArgumentError`](https://docs.ruby-lang.org/en/2.6.0/ArgumentError.html).
  #
  # Returns an HTTPResponse object.
  #
  # When called with a block, passes an HTTPResponse object to the block. The
  # body of the response will not have been read yet; the block can process it
  # using HTTPResponse#read\_body, if desired.
  #
  # This method never raises Net::\* exceptions.
  sig do
    params(
      req: ::T.untyped,
      body: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request(req, body=T.unsafe(nil), &block); end

  # Sends a GET request to the `path`. Returns the response as a
  # [`Net::HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
  # object.
  #
  # When called with a block, passes an HTTPResponse object to the block. The
  # body of the response will not have been read yet; the block can process it
  # using HTTPResponse#read\_body, if desired.
  #
  # Returns the response.
  #
  # This method never raises Net::\* exceptions.
  #
  # ```ruby
  # response = http.request_get('/index.html')
  # # The entity body is already read in this case.
  # p response['content-type']
  # puts response.body
  #
  # # Using a block
  # http.request_get('/index.html') {|response|
  #   p response['content-type']
  #   response.read_body do |str|   # read body now
  #     print str
  #   end
  # }
  # ```
  #
  #
  # Also aliased as:
  # [`get2`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-get2)
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_get(path, initheader=T.unsafe(nil), &block); end

  # Sends a HEAD request to the `path` and returns the response as a
  # [`Net::HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
  # object.
  #
  # Returns the response.
  #
  # This method never raises Net::\* exceptions.
  #
  # ```ruby
  # response = http.request_head('/index.html')
  # p response['content-type']
  # ```
  #
  #
  # Also aliased as:
  # [`head2`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-head2)
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_head(path, initheader=T.unsafe(nil), &block); end

  # Sends a POST request to the `path`.
  #
  # Returns the response as a
  # [`Net::HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
  # object.
  #
  # When called with a block, the block is passed an HTTPResponse object. The
  # body of that response will not have been read yet; the block can process it
  # using HTTPResponse#read\_body, if desired.
  #
  # Returns the response.
  #
  # This method never raises Net::\* exceptions.
  #
  # ```ruby
  # # example
  # response = http.request_post('/cgi-bin/nice.rb', 'datadatadata...')
  # p response.status
  # puts response.body          # body is already read in this case
  #
  # # using block
  # http.request_post('/cgi-bin/nice.rb', 'datadatadata...') {|response|
  #   p response.status
  #   p response['content-type']
  #   response.read_body do |str|   # read body now
  #     print str
  #   end
  # }
  # ```
  #
  #
  # Also aliased as:
  # [`post2`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-post2)
  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_post(path, data, initheader=T.unsafe(nil), &block); end

  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_put(path, data, initheader=T.unsafe(nil), &block); end

  # Sends an [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) request
  # to the [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) server.
  # Also sends a DATA string if `data` is given.
  #
  # Returns a
  # [`Net::HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
  # object.
  #
  # This method never raises Net::\* exceptions.
  #
  # ```ruby
  # response = http.send_request('GET', '/index.html')
  # puts response.body
  # ```
  sig do
    params(
      name: ::T.untyped,
      path: ::T.untyped,
      data: ::T.untyped,
      header: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_request(name, path, data=T.unsafe(nil), header=T.unsafe(nil)); end

  # **WARNING** This method opens a serious security hole. Never use this method
  # in production code.
  #
  # Sets an output stream for debugging.
  #
  # ```
  # http = Net::HTTP.new(hostname)
  # http.set_debug_output $stderr
  # http.start { .... }
  # ```
  sig do
    params(
      output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_debug_output(output); end

  # Sets the SSL timeout seconds.
  sig {returns(::T.untyped)}
  def ssl_timeout(); end

  # Sets the SSL timeout seconds.
  sig do
    params(
      ssl_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_timeout=(ssl_timeout); end

  # Sets the SSL version. See
  # [`OpenSSL::SSL::SSLContext#ssl_version=`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/SSL/SSLContext.html#method-i-ssl_version-3D)
  sig {returns(::T.untyped)}
  def ssl_version(); end

  # Sets the SSL version. See
  # [`OpenSSL::SSL::SSLContext#ssl_version=`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/SSL/SSLContext.html#method-i-ssl_version-3D)
  sig do
    params(
      ssl_version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_version=(ssl_version); end

  # Opens a TCP connection and
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) session.
  #
  # When this method is called with a block, it passes the
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) object to
  # the block, and closes the TCP connection and
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) session after
  # the block has been executed.
  #
  # When called with a block, it returns the return value of the block;
  # otherwise, it returns self.
  sig {returns(::T.untyped)}
  def start(); end

  # Returns true if the
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) session has been
  # started.
  #
  # Also aliased as:
  # [`active?`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-i-active-3F)
  sig {returns(::T.untyped)}
  def started?(); end

  # Sends a TRACE request to the `path` and gets a response, as an HTTPResponse
  # object.
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def trace(path, initheader=T.unsafe(nil)); end

  sig do
    params(
      req: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def transport_request(req); end

  # Sends a UNLOCK request to the `path` and gets a response, as an HTTPResponse
  # object.
  sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unlock(path, body, initheader=T.unsafe(nil)); end

  # Turn on/off SSL. This flag must be set before starting session. If you
  # change use\_ssl value after session started, a
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) object
  # raises [`IOError`](https://docs.ruby-lang.org/en/2.6.0/IOError.html).
  sig do
    params(
      flag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def use_ssl=(flag); end

  # Returns true if SSL/TLS is being used with
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html).
  sig {returns(::T.untyped)}
  def use_ssl?(); end

  # Sets the verify callback for the server certification verification.
  sig {returns(::T.untyped)}
  def verify_callback(); end

  # Sets the verify callback for the server certification verification.
  sig do
    params(
      verify_callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_callback=(verify_callback); end

  # Sets the maximum depth for the certificate chain verification.
  sig {returns(::T.untyped)}
  def verify_depth(); end

  # Sets the maximum depth for the certificate chain verification.
  sig do
    params(
      verify_depth: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_depth=(verify_depth); end

  # Sets the flags for server the certification verification at beginning of
  # SSL/TLS session.
  #
  # OpenSSL::SSL::VERIFY\_NONE or OpenSSL::SSL::VERIFY\_PEER are acceptable.
  sig {returns(::T.untyped)}
  def verify_mode(); end

  # Sets the flags for server the certification verification at beginning of
  # SSL/TLS session.
  #
  # OpenSSL::SSL::VERIFY\_NONE or OpenSSL::SSL::VERIFY\_PEER are acceptable.
  sig do
    params(
      verify_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_mode=(verify_mode); end

  # Creates an [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) proxy
  # class which behaves like
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html), but
  # performs all access via the specified proxy.
  #
  # This class is obsolete. You may pass these same parameters directly to
  # [`Net::HTTP.new`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-c-new).
  # See
  # [`Net::HTTP.new`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-c-new)
  # for details of the arguments.
  sig do
    params(
      p_addr: ::T.untyped,
      p_port: ::T.untyped,
      p_user: ::T.untyped,
      p_pass: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.Proxy(p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  # The default port to use for
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) requests;
  # defaults to 80.
  sig {returns(::T.untyped)}
  def self.default_port(); end

  # Sends a GET request to the target and returns the
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) response as a
  # string. The target can either be specified as (`uri`), or as (`host`,
  # `path`, `port` = 80); so:
  #
  # ```ruby
  # print Net::HTTP.get(URI('http://www.example.com/index.html'))
  # ```
  #
  # or:
  #
  # ```ruby
  # print Net::HTTP.get('www.example.com', '/index.html')
  # ```
  sig do
    params(
      uri_or_host: ::T.untyped,
      path: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get(uri_or_host, path=T.unsafe(nil), port=T.unsafe(nil)); end

  # Gets the body text from the target and outputs it to $stdout. The target can
  # either be specified as (`uri`), or as (`host`, `path`, `port` = 80); so:
  #
  # ```ruby
  # Net::HTTP.get_print URI('http://www.example.com/index.html')
  # ```
  #
  # or:
  #
  # ```ruby
  # Net::HTTP.get_print 'www.example.com', '/index.html'
  # ```
  sig do
    params(
      uri_or_host: ::T.untyped,
      path: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get_print(uri_or_host, path=T.unsafe(nil), port=T.unsafe(nil)); end

  # Sends a GET request to the target and returns the
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) response as a
  # [`Net::HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
  # object. The target can either be specified as (`uri`), or as (`host`,
  # `path`, `port` = 80); so:
  #
  # ```ruby
  # res = Net::HTTP.get_response(URI('http://www.example.com/index.html'))
  # print res.body
  # ```
  #
  # or:
  #
  # ```ruby
  # res = Net::HTTP.get_response('www.example.com', '/index.html')
  # print res.body
  # ```
  sig do
    params(
      uri_or_host: ::T.untyped,
      path: ::T.untyped,
      port: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get_response(uri_or_host, path=T.unsafe(nil), port=T.unsafe(nil), &block); end

  # The default port to use for
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) requests;
  # defaults to 80.
  sig {returns(::T.untyped)}
  def self.http_default_port(); end

  # The default port to use for HTTPS requests; defaults to 443.
  sig {returns(::T.untyped)}
  def self.https_default_port(); end

  sig {returns(::T.untyped)}
  def self.is_version_1_1?(); end

  # Alias for:
  # [`version_1_2?`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-c-version_1_2-3F)
  sig {returns(::T.untyped)}
  def self.is_version_1_2?(); end

  # Creates a new
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) object for
  # the specified server address, without opening the TCP connection or
  # initializing the [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html)
  # session. The `address` should be a DNS hostname or IP address.
  sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
      p_addr: ::T.untyped,
      p_port: ::T.untyped,
      p_user: ::T.untyped,
      p_pass: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(address, port=T.unsafe(nil), p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  # Alias for:
  # [`new`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-c-new)
  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.newobj(*_); end

  # Posts data to the specified
  # [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html) object.
  #
  # Example:
  #
  # ```ruby
  # require 'net/http'
  # require 'uri'
  #
  # Net::HTTP.post URI('http://www.example.com/api/search'),
  #                { "q" => "ruby", "max" => "50" }.to_json,
  #                "Content-Type" => "application/json"
  # ```
  sig do
    params(
      url: ::T.untyped,
      data: ::T.untyped,
      header: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.post(url, data, header=T.unsafe(nil)); end

  # Posts HTML form data to the specified
  # [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html) object. The form data
  # must be provided as a
  # [`Hash`](https://docs.ruby-lang.org/en/2.6.0/Hash.html) mapping from
  # [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html) to
  # [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html). Example:
  #
  # ```ruby
  # { "cmd" => "search", "q" => "ruby", "max" => "50" }
  # ```
  #
  # This method also does Basic Authentication iff `url`.user exists. But
  # userinfo for authentication is deprecated (RFC3986). So this feature will be
  # removed.
  #
  # Example:
  #
  # ```ruby
  # require 'net/http'
  # require 'uri'
  #
  # Net::HTTP.post_form URI('http://www.example.com/search.cgi'),
  #                     { "q" => "ruby", "max" => "50" }
  # ```
  sig do
    params(
      url: ::T.untyped,
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.post_form(url, params); end

  # Address of proxy host. If
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) does not
  # use a proxy, nil.
  sig {returns(::T.untyped)}
  def self.proxy_address(); end

  # returns true if self is a class which was created by HTTP::Proxy.
  sig {returns(::T.untyped)}
  def self.proxy_class?(); end

  # User password for accessing proxy. If
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) does not
  # use a proxy, nil.
  sig {returns(::T.untyped)}
  def self.proxy_pass(); end

  # Port number of proxy host. If
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) does not
  # use a proxy, nil.
  sig {returns(::T.untyped)}
  def self.proxy_port(); end

  # User name for accessing proxy. If
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) does not
  # use a proxy, nil.
  sig {returns(::T.untyped)}
  def self.proxy_user(); end

  sig {returns(::T.untyped)}
  def self.socket_type(); end

  # Creates a new
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) object,
  # then additionally opens the TCP connection and
  # [`HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) session.
  #
  # Arguments are the following:
  # *address*
  # :   hostname or IP address of the server
  # *port*
  # :   port of the server
  # *p\_addr*
  # :   address of proxy
  # *p\_port*
  # :   port of proxy
  # *p\_user*
  # :   user of proxy
  # *p\_pass*
  # :   pass of proxy
  # *opt*
  # :   optional hash
  #
  #
  # *opt* sets following values by its accessor. The keys are
  # [`ca_file`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-ca_file),
  # [`ca_path`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-ca_path),
  # cert,
  # [`cert_store`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-cert_store),
  # ciphers,
  # [`close_on_empty_response`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-close_on_empty_response),
  # key,
  # [`open_timeout`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-open_timeout),
  # [`read_timeout`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-read_timeout),
  # [`write_timeout`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-write_timeout),
  # [`ssl_timeout`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-ssl_timeout),
  # [`ssl_version`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-ssl_version),
  # use\_ssl,
  # [`verify_callback`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-verify_callback),
  # [`verify_depth`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-verify_depth)
  # and verify\_mode. If you set :use\_ssl as true, you can use https and
  # default value of
  # [`verify_mode`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#attribute-i-verify_mode)
  # is set as OpenSSL::SSL::VERIFY\_PEER.
  #
  # If the optional block is given, the newly created
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) object is
  # passed to it and closed when the block finishes. In this case, the return
  # value of this method is the return value of the block. If no block is given,
  # the return value of this method is the newly created
  # [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) object
  # itself, and the caller is responsible for closing it upon completion using
  # the finish() method.
  sig do
    params(
      address: ::T.untyped,
      arg: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(address, *arg, &block); end

  sig {returns(::T.untyped)}
  def self.version_1_1?(); end

  # Turns on net/http 1.2 (Ruby 1.8) features. Defaults to ON in Ruby 1.8 or
  # later.
  sig {returns(::T.untyped)}
  def self.version_1_2(); end

  # Returns true if net/http is in version 1.2 mode. Defaults to true.
  #
  # Also aliased as:
  # [`is_version_1_2?`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html#method-c-is_version_1_2-3F)
  sig {returns(::T.untyped)}
  def self.version_1_2?(); end
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods.
class Net::HTTP::Copy < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods. See
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) for usage
# examples.
class Net::HTTP::Delete < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::DigestAuth
  include ::MonitorMixin
  VERSION = ::T.let(nil, ::T.untyped)

  sig do
    params(
      uri: ::T.untyped,
      www_authenticate: ::T.untyped,
      method: ::T.untyped,
      iis: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_header(uri, www_authenticate, method, iis=T.unsafe(nil)); end

  sig do
    params(
      ignored: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(ignored=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def make_cnonce(); end

  sig {returns(::T.untyped)}
  def next_nonce(); end
end

class Net::HTTP::DigestAuth::Error < RuntimeError
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods. See
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) for usage
# examples.
class Net::HTTP::Get < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods. See
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) for usage
# examples.
class Net::HTTP::Head < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods.
class Net::HTTP::Lock < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods.
class Net::HTTP::Mkcol < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods.
class Net::HTTP::Move < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods.
class Net::HTTP::Options < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods.
class Net::HTTP::Patch < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods. See
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) for usage
# examples.
class Net::HTTP::Post < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods.
class Net::HTTP::Propfind < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods.
class Net::HTTP::Proppatch < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

module Net::HTTP::ProxyDelta
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods. See
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) for usage
# examples.
class Net::HTTP::Put < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods.
class Net::HTTP::Trace < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

# See
# [`Net::HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# for attributes and methods.
class Net::HTTP::Unlock < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPAccepted < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPBadGateway < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPBadRequest < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPBadResponse < StandardError
end

class Net::HTTPClientError < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPConflict < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPContinue < Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPCreated < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPError < Net::ProtocolError
  include ::Net::HTTPExceptions
end

# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html) exception
# class. You cannot use
# [`Net::HTTPExceptions`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPExceptions.html)
# directly; instead, you must use its subclasses.
module Net::HTTPExceptions
  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      msg: ::T.untyped,
      res: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(msg, res); end

  sig {returns(::T.untyped)}
  def response(); end
end

class Net::HTTPExpectationFailed < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPFailedDependency < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPFatalError < Net::ProtoFatalError
  include ::Net::HTTPExceptions
end

class Net::HTTPForbidden < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPFound < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeOut < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

# [`HTTPGenericRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPGenericRequest.html)
# is the parent of the HTTPRequest class. Do not use this directly; use a
# subclass of HTTPRequest.
#
# Mixes in the HTTPHeader module to provide easier access to HTTP headers.
class Net::HTTPGenericRequest
  include ::Net::HTTPHeader
  sig do
    params(
      key: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(key, val); end

  sig {returns(::T.untyped)}
  def body(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body=(str); end

  sig {returns(::T.untyped)}
  def body_exist?(); end

  sig {returns(::T.untyped)}
  def body_stream(); end

  sig do
    params(
      input: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body_stream=(input); end

  # Automatically set to false if the user sets the Accept-Encoding header. This
  # indicates they wish to handle Content-encoding in responses themselves.
  sig {returns(::T.untyped)}
  def decode_content(); end

  sig do
    params(
      sock: ::T.untyped,
      ver: ::T.untyped,
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def exec(sock, ver, path); end

  sig do
    params(
      m: ::T.untyped,
      reqbody: ::T.untyped,
      resbody: ::T.untyped,
      uri_or_path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(m, reqbody, resbody, uri_or_path, initheader=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def method(); end

  sig {returns(::T.untyped)}
  def path(); end

  sig {returns(::T.untyped)}
  def request_body_permitted?(); end

  sig {returns(::T.untyped)}
  def response_body_permitted?(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_body_internal(str); end

  sig do
    params(
      addr: ::T.untyped,
      port: ::T.untyped,
      ssl: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def update_uri(addr, port, ssl); end

  sig {returns(::T.untyped)}
  def uri(); end
end

class Net::HTTPGenericRequest::Chunker
  sig {returns(::T.untyped)}
  def finish(); end

  sig do
    params(
      sock: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sock); end

  sig do
    params(
      buf: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(buf); end
end

class Net::HTTPGone < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

# The [`HTTPHeader`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html)
# module defines methods for reading and writing HTTP headers.
#
# It is used as a mixin by other classes, to provide hash-like access to HTTP
# header values. Unlike raw hash access,
# [`HTTPHeader`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html)
# provides access via case-insensitive keys. It also provides methods for
# accessing commonly-used HTTP header values in more convenient formats.
module Net::HTTPHeader
  # Returns the header field corresponding to the case-insensitive key. For
  # example, a key of "Content-Type" might return "text/html"
  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  # Sets the header field corresponding to the case-insensitive key.
  sig do
    params(
      key: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(key, val); end

  # Ruby 1.8.3
  # :   Adds a value to a named header field, instead of replacing its value.
  #     Second argument `val` must be a
  #     [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html). See also
  #     [`[]=`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-5B-5D-3D),
  #     [`[]`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-5B-5D)
  #     and
  #     [`get_fields`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-get_fields).
  #
  # ```ruby
  # request.add_field 'X-My-Header', 'a'
  # p request['X-My-Header']              #=> "a"
  # p request.get_fields('X-My-Header')   #=> ["a"]
  # request.add_field 'X-My-Header', 'b'
  # p request['X-My-Header']              #=> "a, b"
  # p request.get_fields('X-My-Header')   #=> ["a", "b"]
  # request.add_field 'X-My-Header', 'c'
  # p request['X-My-Header']              #=> "a, b, c"
  # p request.get_fields('X-My-Header')   #=> ["a", "b", "c"]
  # ```
  sig do
    params(
      key: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_field(key, val); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) the Authorization:
  # header for "Basic" authorization.
  sig do
    params(
      account: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def basic_auth(account, password); end

  # Alias for:
  # [`each_capitalized`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-each_capitalized)
  sig {returns(::T.untyped)}
  def canonical_each(); end

  # Returns "true" if the "transfer-encoding" header is present and set to
  # "chunked". This is an HTTP/1.1 feature, allowing the the content to be sent
  # in "chunks" without at the outset stating the entire content length.
  sig {returns(::T.untyped)}
  def chunked?(); end

  sig {returns(::T.untyped)}
  def connection_close?(); end

  sig {returns(::T.untyped)}
  def connection_keep_alive?(); end

  # Returns an [`Integer`](https://docs.ruby-lang.org/en/2.6.0/Integer.html)
  # object which represents the HTTP Content-Length: header field, or `nil` if
  # that field was not provided.
  sig {returns(::T.untyped)}
  def content_length(); end

  sig do
    params(
      len: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_length=(len); end

  # Returns a [`Range`](https://docs.ruby-lang.org/en/2.6.0/Range.html) object
  # which represents the value of the Content-Range: header field. For a partial
  # entity body, this indicates where this fragment fits inside the full entity
  # body, as range of byte offsets.
  sig {returns(::T.untyped)}
  def content_range(); end

  # Returns a content type string such as "text/html". This method returns nil
  # if Content-Type: header field does not exist.
  sig {returns(::T.untyped)}
  def content_type(); end

  # Alias for:
  # [`set_content_type`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-set_content_type)
  sig do
    params(
      type: ::T.untyped,
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_type=(type, params=T.unsafe(nil)); end

  # Removes a header field, specified by case-insensitive key.
  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(key); end

  # Alias for:
  # [`each_header`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-each_header)
  sig {returns(::T.untyped)}
  def each(); end

  # As for
  # [`each_header`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-each_header),
  # except the keys are provided in capitalized form.
  #
  # Note that header names are capitalized systematically; capitalization may
  # not match that used by the remote HTTP server in its response.
  #
  # Returns an enumerator if no block is given.
  #
  # Also aliased as:
  # [`canonical_each`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-canonical_each)
  sig {returns(::T.untyped)}
  def each_capitalized(); end

  # Iterates through the header names in the header, passing capitalized header
  # names to the code block.
  #
  # Note that header names are capitalized systematically; capitalization may
  # not match that used by the remote HTTP server in its response.
  #
  # Returns an enumerator if no block is given.
  sig {returns(::T.untyped)}
  def each_capitalized_name(); end

  # Iterates through the header names and values, passing in the name and value
  # to the code block supplied.
  #
  # Returns an enumerator if no block is given.
  #
  # Example:
  #
  # ```ruby
  # response.header.each_header {|key,value| puts "#{key} = #{value}" }
  # ```
  #
  #
  # Also aliased as:
  # [`each`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-each)
  sig {returns(::T.untyped)}
  def each_header(); end

  # Alias for:
  # [`each_name`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-each_name)
  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_key(&block); end

  # Iterates through the header names in the header, passing each header name to
  # the code block.
  #
  # Returns an enumerator if no block is given.
  #
  # Also aliased as:
  # [`each_key`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-each_key)
  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_name(&block); end

  # Iterates through header values, passing each value to the code block.
  #
  # Returns an enumerator if no block is given.
  sig {returns(::T.untyped)}
  def each_value(); end

  # Returns the header field corresponding to the case-insensitive key. Returns
  # the default value `args`, or the result of the block, or raises an
  # [`IndexError`](https://docs.ruby-lang.org/en/2.6.0/IndexError.html) if
  # there's no header field named `key` See
  # [`Hash#fetch`](https://docs.ruby-lang.org/en/2.6.0/Hash.html#method-i-fetch)
  sig do
    params(
      key: ::T.untyped,
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fetch(key, *args, &block); end

  # Alias for:
  # [`set_form_data`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-set_form_data)
  sig do
    params(
      params: ::T.untyped,
      sep: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def form_data=(params, sep=T.unsafe(nil)); end

  # Ruby 1.8.3
  # :   Returns an array of header field strings corresponding to the
  #     case-insensitive `key`. This method allows you to get duplicated header
  #     fields without any processing. See also
  #     [`[]`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-5B-5D).
  #
  # ```
  # p response.get_fields('Set-Cookie')
  #   #=> ["session=al98axx; expires=Fri, 31-Dec-1999 23:58:23",
  #        "query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23"]
  # p response['Set-Cookie']
  #   #=> "session=al98axx; expires=Fri, 31-Dec-1999 23:58:23, query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23"
  # ```
  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get_fields(key); end

  sig do
    params(
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize_http_header(initheader); end

  # true if `key` header exists.
  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key?(key); end

  sig {returns(::T.untyped)}
  def length(); end

  # Returns a content type string such as "text". This method returns nil if
  # Content-Type: header field does not exist.
  sig {returns(::T.untyped)}
  def main_type(); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) Proxy-Authorization:
  # header for "Basic" authorization.
  sig do
    params(
      account: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_basic_auth(account, password); end

  # Returns an [`Array`](https://docs.ruby-lang.org/en/2.6.0/Array.html) of
  # [`Range`](https://docs.ruby-lang.org/en/2.6.0/Range.html) objects which
  # represent the Range: HTTP header field, or `nil` if there is no such header.
  sig {returns(::T.untyped)}
  def range(); end

  # Alias for:
  # [`set_range`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-set_range)
  sig do
    params(
      r: ::T.untyped,
      e: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def range=(r, e=T.unsafe(nil)); end

  # The length of the range represented in Content-Range: header.
  sig {returns(::T.untyped)}
  def range_length(); end

  # Sets the content type in an HTTP header. The `type` should be a full HTTP
  # content type, e.g. "text/html". The `params` are an optional
  # [`Hash`](https://docs.ruby-lang.org/en/2.6.0/Hash.html) of parameters to add
  # after the content type, e.g. {'charset' => 'iso-8859-1'}
  #
  # Also aliased as:
  # [`content_type=`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-content_type-3D)
  sig do
    params(
      type: ::T.untyped,
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_content_type(type, params=T.unsafe(nil)); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) an HTML form data set.
  # `params` is the form data set; it is an
  # [`Array`](https://docs.ruby-lang.org/en/2.6.0/Array.html) of Arrays or a
  # [`Hash`](https://docs.ruby-lang.org/en/2.6.0/Hash.html) +enctype is the type
  # to encode the form data set. It is application/x-www-form-urlencoded or
  # multipart/form-data. `formopt` is an optional hash to specify the detail.
  #
  # boundary
  # :   the boundary of the multipart message
  # charset
  # :   the charset of the message. All names and the values of non-file fields
  #     are encoded as the charset.
  #
  #
  # Each item of params is an array and contains following items:
  # `name`
  # :   the name of the field
  # `value`
  # :   the value of the field, it should be a
  #     [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html) or a
  #     [`File`](https://docs.ruby-lang.org/en/2.6.0/File.html)
  # `opt`
  # :   an optional hash to specify additional information
  #
  #
  # Each item is a file field or a normal field. If `value` is a
  # [`File`](https://docs.ruby-lang.org/en/2.6.0/File.html) object or the `opt`
  # have a filename key, the item is treated as a file field.
  #
  # If Transfer-Encoding is set as chunked, this send the request in chunked
  # encoding. Because chunked encoding is HTTP/1.1 feature, you must confirm the
  # server to support HTTP/1.1 before sending it.
  #
  # Example:
  #
  # ```ruby
  # http.set_form([["q", "ruby"], ["lang", "en"]])
  # ```
  #
  # See also RFC 2388, RFC 2616, HTML 4.01, and HTML5
  sig do
    params(
      params: ::T.untyped,
      enctype: ::T.untyped,
      formopt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_form(params, enctype=T.unsafe(nil), formopt=T.unsafe(nil)); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) header fields and a
  # body from HTML form data. `params` should be an
  # [`Array`](https://docs.ruby-lang.org/en/2.6.0/Array.html) of Arrays or a
  # [`Hash`](https://docs.ruby-lang.org/en/2.6.0/Hash.html) containing HTML form
  # data. Optional argument `sep` means data record separator.
  #
  # Values are URL encoded as necessary and the content-type is set to
  # application/x-www-form-urlencoded
  #
  # Example:
  #
  # ```ruby
  # http.form_data = {"q" => "ruby", "lang" => "en"}
  # http.form_data = {"q" => ["ruby", "perl"], "lang" => "en"}
  # http.set_form_data({"q" => "ruby", "lang" => "en"}, ';')
  # ```
  #
  #
  # Also aliased as:
  # [`form_data=`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-form_data-3D)
  sig do
    params(
      params: ::T.untyped,
      sep: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_form_data(params, sep=T.unsafe(nil)); end

  # Sets the HTTP Range: header. Accepts either a
  # [`Range`](https://docs.ruby-lang.org/en/2.6.0/Range.html) object as a single
  # argument, or a beginning index and a length from that index. Example:
  #
  # ```ruby
  # req.range = (0..1023)
  # req.set_range 0, 1023
  # ```
  #
  #
  # Also aliased as:
  # [`range=`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-range-3D)
  sig do
    params(
      r: ::T.untyped,
      e: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_range(r, e=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def size(); end

  # Returns a content type string such as "html". This method returns nil if
  # Content-Type: header field does not exist or sub-type is not given (e.g.
  # "Content-Type: text").
  sig {returns(::T.untyped)}
  def sub_type(); end

  # Returns a [`Hash`](https://docs.ruby-lang.org/en/2.6.0/Hash.html) consisting
  # of header names and array of values. e.g. {"cache-control" => ["private"],
  #
  # ```
  # "content-type" => ["text/html"],
  # "date" => ["Wed, 22 Jun 2005 22:11:50 GMT"]}
  # ```
  sig {returns(::T.untyped)}
  def to_hash(); end

  # Any parameters specified for the content type, returned as a
  # [`Hash`](https://docs.ruby-lang.org/en/2.6.0/Hash.html). For example, a
  # header of Content-Type: text/html; charset=EUC-JP would result in
  # [`type_params`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPHeader.html#method-i-type_params)
  # returning {'charset' => 'EUC-JP'}
  sig {returns(::T.untyped)}
  def type_params(); end
end

class Net::HTTPHeaderSyntaxError < StandardError
end

class Net::HTTPIMUsed < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPInformation < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPInsufficientStorage < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

# 444 No Response - Nginx 449 Retry With - Microsoft 450 Blocked by Windows
# Parental Controls - Microsoft 499 Client Closed Request - Nginx
class Net::HTTPInternalServerError < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLengthRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLocked < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMethodNotAllowed < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMovedPermanently < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMultiStatus < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMultipleChoices < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNetworkAuthenticationRequired < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNoContent < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNonAuthoritativeInformation < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotAcceptable < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotFound < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotImplemented < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotModified < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPOK < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPartialContent < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPaymentRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPermanentRedirect < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPreconditionFailed < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPreconditionRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProxyAuthenticationRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRedirection < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

# HTTP request class. This class wraps together the request header and the
# request path. You cannot use this class directly. Instead, you should use one
# of its subclasses:
# [`Net::HTTP::Get`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Get.html),
# [`Net::HTTP::Post`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Post.html),
# [`Net::HTTP::Head`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP/Head.html).
class Net::HTTPRequest < Net::HTTPGenericRequest
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(path, initheader=T.unsafe(nil)); end
end

class Net::HTTPRequestEntityTooLarge < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestHeaderFieldsTooLarge < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeOut < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestURITooLong < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestedRangeNotSatisfiable < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPResetContent < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

# HTTP response class.
#
# This class wraps together the response header and the response body (the
# entity requested).
#
# It mixes in the HTTPHeader module, which provides access to response header
# values both via hash-like methods and via individual readers.
#
# Note that each possible HTTP response code defines its own
# [`HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
# subclass. These are listed below.
#
# All classes are defined under the
# [`Net`](https://docs.ruby-lang.org/en/2.6.0/Net.html) module. Indentation
# indicates inheritance. For a list of the classes see
# [`Net::HTTP`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTP.html).
class Net::HTTPResponse
  include ::Net::HTTPHeader
  CODE_CLASS_TO_OBJ = ::T.let(nil, ::T.untyped)
  CODE_TO_OBJ = ::T.let(nil, ::T.untyped)

  # Returns the full entity body.
  #
  # Calling this method a second or subsequent time will return the string
  # already read.
  #
  # ```ruby
  # http.request_get('/index.html') {|res|
  #   puts res.body
  # }
  #
  # http.request_get('/index.html') {|res|
  #   p res.body.object_id   # 538149362
  #   p res.body.object_id   # 538149362
  # }
  # ```
  #
  #
  # Also aliased as:
  # [`entity`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html#method-i-entity)
  sig {returns(::T.untyped)}
  def body(); end

  # Because it may be necessary to modify the body, Eg, decompression this
  # method facilitates that.
  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body=(value); end

  # The HTTP result code string. For example, '302'. You can also determine the
  # response type by examining which response subclass the response object is an
  # instance of.
  sig {returns(::T.untyped)}
  def code(); end

  sig {returns(::T.untyped)}
  def code_type(); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) to true automatically
  # when the request did not contain an Accept-Encoding header from the user.
  sig {returns(::T.untyped)}
  def decode_content(); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) to true automatically
  # when the request did not contain an Accept-Encoding header from the user.
  sig do
    params(
      decode_content: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def decode_content=(decode_content); end

  # Alias for:
  # [`body`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html#method-i-body)
  sig {returns(::T.untyped)}
  def entity(); end

  sig {returns(::T.untyped)}
  def error!(); end

  sig {returns(::T.untyped)}
  def error_type(); end

  sig {returns(::T.untyped)}
  def header(); end

  # The HTTP version supported by the server.
  sig {returns(::T.untyped)}
  def http_version(); end

  sig do
    params(
      httpv: ::T.untyped,
      code: ::T.untyped,
      msg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(httpv, code, msg); end

  sig {returns(::T.untyped)}
  def inspect(); end

  # The HTTP result message sent by the server. For example, 'Not Found'.
  sig {returns(::T.untyped)}
  def message(); end

  # The HTTP result message sent by the server. For example, 'Not Found'.
  sig {returns(::T.untyped)}
  def msg(); end

  # Gets the entity body returned by the remote HTTP server.
  #
  # If a block is given, the body is passed to the block, and the body is
  # provided in fragments, as it is read in from the socket.
  #
  # Calling this method a second or subsequent time for the same
  # [`HTTPResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/HTTPResponse.html)
  # object will return the value already read.
  #
  # ```ruby
  # http.request_get('/index.html') {|res|
  #   puts res.read_body
  # }
  #
  # http.request_get('/index.html') {|res|
  #   p res.read_body.object_id   # 538149362
  #   p res.read_body.object_id   # 538149362
  # }
  #
  # # using iterator
  # http.request_get('/index.html') {|res|
  #   res.read_body do |segment|
  #     print segment
  #   end
  # }
  # ```
  sig do
    params(
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_body(dest=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def read_header(); end

  sig do
    params(
      sock: ::T.untyped,
      reqmethodallowbody: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reading_body(sock, reqmethodallowbody); end

  sig {returns(::T.untyped)}
  def response(); end

  # The [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html) used to fetch this
  # response. The response [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html)
  # is only available if a [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html)
  # was used to create the request.
  sig {returns(::T.untyped)}
  def uri(); end

  # The [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html) used to fetch this
  # response. The response [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html)
  # is only available if a [`URI`](https://docs.ruby-lang.org/en/2.6.0/URI.html)
  # was used to create the request.
  sig do
    params(
      uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uri=(uri); end

  # Raises an HTTP error if the response is not 2xx (success).
  sig {returns(::T.untyped)}
  def value(); end

  # true if the response has a body.
  sig {returns(::T.untyped)}
  def self.body_permitted?(); end

  sig {returns(::T.untyped)}
  def self.exception_type(); end

  sig do
    params(
      sock: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.read_new(sock); end
end

class Net::HTTPResponse::Inflater
  sig {returns(::T.untyped)}
  def finish(); end

  sig do
    params(
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def inflate_adapter(dest); end

  sig do
    params(
      socket: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(socket); end

  sig do
    params(
      clen: ::T.untyped,
      dest: ::T.untyped,
      ignore_eof: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(clen, dest, ignore_eof=T.unsafe(nil)); end

  sig do
    params(
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_all(dest); end
end

class Net::HTTPRetriableError < Net::ProtoRetriableError
  include ::Net::HTTPExceptions
end

class Net::HTTPSeeOther < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPServerError < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPServerException < Net::ProtoServerError
  include ::Net::HTTPExceptions
end

class Net::HTTPServiceUnavailable < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPSuccess < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPSwitchProtocol < Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

# 306 Switch Proxy - no longer unused
class Net::HTTPTemporaryRedirect < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPTooManyRequests < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPUnauthorized < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPUnavailableForLegalReasons < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

# https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
class Net::HTTPUnknownResponse < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPUnprocessableEntity < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPUnsupportedMediaType < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

# 425 Unordered Collection - existed only in draft
class Net::HTTPUpgradeRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPUseProxy < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVersionNotSupported < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

# [`Net::IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) implements
# Internet Message Access Protocol (IMAP) client functionality. The protocol is
# described in [IMAP].
#
# ## [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) Overview
#
# An [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) client connects
# to a server, and then authenticates itself using either
# [`authenticate()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-authenticate)
# or
# [`login()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-login).
# Having authenticated itself, there is a range of commands available to it.
# Most work with mailboxes, which may be arranged in an hierarchical namespace,
# and each of which contains zero or more messages. How this is implemented on
# the server is implementation-dependent; on a UNIX server, it will frequently
# be implemented as files in mailbox format within a hierarchy of directories.
#
# To work on the messages within a mailbox, the client must first select that
# mailbox, using either
# [`select()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-select)
# or (for read-only access)
# [`examine()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-examine).
# Once the client has successfully selected a mailbox, they enter *selected*
# state, and that mailbox becomes the *current* mailbox, on which mail-item
# related commands implicitly operate.
#
# Messages have two sorts of identifiers: message sequence numbers and UIDs.
#
# Message sequence numbers number messages within a mailbox from 1 up to the
# number of items in the mailbox. If a new message arrives during a session, it
# receives a sequence number equal to the new size of the mailbox. If messages
# are expunged from the mailbox, remaining messages have their sequence numbers
# "shuffled down" to fill the gaps.
#
# UIDs, on the other hand, are permanently guaranteed not to identify another
# message within the same mailbox, even if the existing message is deleted. UIDs
# are required to be assigned in ascending (but not necessarily sequential)
# order within a mailbox; this means that if a non-IMAP client rearranges the
# order of mailitems within a mailbox, the UIDs have to be reassigned. An
# [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) client thus cannot
# rearrange message orders.
#
# ## Examples of Usage
#
# ### List sender and subject of all recent messages in the default mailbox
#
# ```ruby
# imap = Net::IMAP.new('mail.example.com')
# imap.authenticate('LOGIN', 'joe_user', 'joes_password')
# imap.examine('INBOX')
# imap.search(["RECENT"]).each do |message_id|
#   envelope = imap.fetch(message_id, "ENVELOPE")[0].attr["ENVELOPE"]
#   puts "#{envelope.from[0].name}: \t#{envelope.subject}"
# end
# ```
#
# ### Move all messages from April 2003 from "Mail/sent-mail" to "Mail/sent-apr03"
#
# ```ruby
# imap = Net::IMAP.new('mail.example.com')
# imap.authenticate('LOGIN', 'joe_user', 'joes_password')
# imap.select('Mail/sent-mail')
# if not imap.list('Mail/', 'sent-apr03')
#   imap.create('Mail/sent-apr03')
# end
# imap.search(["BEFORE", "30-Apr-2003", "SINCE", "1-Apr-2003"]).each do |message_id|
#   imap.copy(message_id, "Mail/sent-apr03")
#   imap.store(message_id, "+FLAGS", [:Deleted])
# end
# imap.expunge
# ```
#
# ## [`Thread`](https://docs.ruby-lang.org/en/2.6.0/Thread.html) Safety
#
# [`Net::IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) supports
# concurrent threads. For example,
#
# ```ruby
# imap = Net::IMAP.new("imap.foo.net", "imap2")
# imap.authenticate("cram-md5", "bar", "password")
# imap.select("inbox")
# fetch_thread = Thread.start { imap.fetch(1..-1, "UID") }
# search_result = imap.search(["BODY", "hello"])
# fetch_result = fetch_thread.value
# imap.disconnect
# ```
#
# This script invokes the FETCH command and the SEARCH command concurrently.
#
# ## Errors
#
# An [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) server can send
# three different types of responses to indicate failure:
#
# NO
# :   the attempted command could not be successfully completed. For instance,
#     the username/password used for logging in are incorrect; the selected
#     mailbox does not exist; etc.
#
# BAD
# :   the request from the client does not follow the server's understanding of
#     the [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) protocol.
#     This includes attempting commands from the wrong client state; for
#     instance, attempting to perform a SEARCH command without having SELECTed a
#     current mailbox. It can also signal an internal server failure (such as a
#     disk crash) has occurred.
#
# BYE
# :   the server is saying goodbye. This can be part of a normal logout
#     sequence, and can be used as part of a login sequence to indicate that the
#     server is (for some reason) unwilling to accept your connection. As a
#     response to any other command, it indicates either that the server is
#     shutting down, or that the server is timing out the client connection due
#     to inactivity.
#
#
# These three error response are represented by the errors
# [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html),
# [`Net::IMAP::BadResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BadResponseError.html),
# and
# [`Net::IMAP::ByeResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/ByeResponseError.html),
# all of which are subclasses of
# [`Net::IMAP::ResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/ResponseError.html).
# Essentially, all methods that involve sending a request to the server can
# generate one of these errors. Only the most pertinent instances have been
# documented below.
#
# Because the [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) class
# uses Sockets for communication, its methods are also susceptible to the
# various errors that can occur when working with sockets. These are generally
# represented as [`Errno`](https://docs.ruby-lang.org/en/2.6.0/Errno.html)
# errors. For instance, any method that involves sending a request to the server
# and/or receiving a response from it could raise an Errno::EPIPE error if the
# network connection unexpectedly goes down. See the socket(7), ip(7), tcp(7),
# socket(2), connect(2), and associated man pages.
#
# Finally, a
# [`Net::IMAP::DataFormatError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/DataFormatError.html)
# is thrown if low-level data is found to be in an incorrect format (for
# instance, when converting between UTF-8 and UTF-16), and
# [`Net::IMAP::ResponseParseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/ResponseParseError.html)
# is thrown if a server response is non-parseable.
#
# ## References
#
#     1.  Crispin, "INTERNET MESSAGE ACCESS PROTOCOL - VERSION 4rev1",
#
#     RFC 2060, December 1996. (Note: since obsoleted by RFC 3501)
#
# [LANGUAGE-TAGS]
# :   Alvestrand, H., "Tags for the Identification of Languages", RFC 1766,
#     March 1995.
#
# [MD5]
# :   Myers, J., and M. Rose, "The Content-MD5 Header Field", RFC 1864, October
#     1995.
#
# [MIME-IMB]
# :   Freed, N., and N. Borenstein, "MIME (Multipurpose Internet Mail
#     Extensions) Part One: Format of Internet Message Bodies", RFC 2045,
#     November 1996.
#
# [RFC-822]
# :   Crocker, D., "Standard for the Format of ARPA Internet Text Messages", STD
#     11, RFC 822, University of Delaware, August 1982.
#
# [RFC-2087]
# :   Myers, J., "IMAP4 QUOTA extension", RFC 2087, January 1997.
#
# [RFC-2086]
# :   Myers, J., "IMAP4 [`ACL`](https://docs.ruby-lang.org/en/2.6.0/ACL.html)
#     extension", RFC 2086, January 1997.
#
# [RFC-2195]
# :   Klensin, J., Catoe, R., and Krumviede, P., "IMAP/POP AUTHorize Extension
#     for Simple Challenge/Response", RFC 2195, September 1997.
#
# [SORT-THREAD-EXT]
# :   Crispin, M., "INTERNET MESSAGE ACCESS PROTOCOL - SORT and THREAD
#     Extensions", draft-ietf-imapext-sort, May 2003.
#
# [OSSL]
# :   http://www.openssl.org
#
# [RSSL]
# :   http://savannah.gnu.org/projects/rubypki
#
# [UTF7]
# :   Goldsmith, D. and Davis, M., "UTF-7: A Mail-Safe Transformation Format of
#     Unicode", RFC 2152, May 1997.
class Net::IMAP < Net::Protocol
  include ::OpenSSL::SSL
  include ::OpenSSL
  include ::MonitorMixin
  # Flag indicating a message has been answered.
  ANSWERED = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  DATE_MONTH = ::T.let(nil, ::T.untyped)
  # Flag indicating a message has been marked for deletion. This will occur when
  # the mailbox is closed or expunged.
  DELETED = ::T.let(nil, ::T.untyped)
  # Flag indicating a message is only a draft or work-in-progress version.
  DRAFT = ::T.let(nil, ::T.untyped)
  # Flag indicating a message has been flagged for special or urgent attention.
  FLAGGED = ::T.let(nil, ::T.untyped)
  # Flag indicating that a mailbox has been marked "interesting" by the server;
  # this commonly indicates that the mailbox contains new messages.
  MARKED = ::T.let(nil, ::T.untyped)
  # Flag indicating that a mailbox context name cannot contain children.
  NOINFERIORS = ::T.let(nil, ::T.untyped)
  # Flag indicating that a mailbox is not selected.
  NOSELECT = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  # Flag indicating that the message is "recent," meaning that this session is
  # the first session in which the client has been notified of this message.
  RECENT = ::T.let(nil, ::T.untyped)
  # Flag indicating a message has been seen.
  SEEN = ::T.let(nil, ::T.untyped)
  SSL_PORT = ::T.let(nil, ::T.untyped)
  # Flag indicating that the mailbox does not contains new messages.
  UNMARKED = ::T.let(nil, ::T.untyped)

  # Adds a response handler. For example, to detect when the server sends a new
  # EXISTS response (which normally indicates new messages being added to the
  # mailbox), add the following handler after selecting the mailbox:
  #
  # ```ruby
  # imap.add_response_handler { |resp|
  #   if resp.kind_of?(Net::IMAP::UntaggedResponse) and resp.name == "EXISTS"
  #     puts "Mailbox now has #{resp.data} messages"
  #   end
  # }
  # ```
  sig do
    params(
      handler: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_response_handler(handler=T.unsafe(nil)); end

  # Sends a APPEND command to append the `message` to the end of the `mailbox`.
  # The optional `flags` argument is an array of flags initially passed to the
  # new message. The optional `date_time` argument specifies the creation time
  # to assign to the new message; it defaults to the current time. For example:
  #
  # ```ruby
  # imap.append("inbox", <<EOF.gsub(/\n/, "\r\n"), [:Seen], Time.now)
  # Subject: hello
  # From: shugo@ruby-lang.org
  # To: shugo@ruby-lang.org
  #
  # hello world
  # EOF
  # ```
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if the mailbox does not exist (it is not created automatically),
  # or if the flags, date\_time, or message arguments contain errors.
  sig do
    params(
      mailbox: ::T.untyped,
      message: ::T.untyped,
      flags: ::T.untyped,
      date_time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def append(mailbox, message, flags=T.unsafe(nil), date_time=T.unsafe(nil)); end

  # Sends an AUTHENTICATE command to authenticate the client. The `auth_type`
  # parameter is a string that represents the authentication mechanism to be
  # used. Currently
  # [`Net::IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) supports
  # the authentication mechanisms:
  #
  # ```
  # LOGIN:: login using cleartext user and password.
  # CRAM-MD5:: login with cleartext user and encrypted password
  #            (see [RFC-2195] for a full description).  This
  #            mechanism requires that the server have the user's
  #            password stored in clear-text password.
  # ```
  #
  # For both of these mechanisms, there should be two `args`: username and
  # (cleartext) password. A server may not support one or the other of these
  # mechanisms; check
  # [`capability()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-capability)
  # for a capability of the form "AUTH=LOGIN" or "AUTH=CRAM-MD5".
  #
  # Authentication is done using the appropriate authenticator object: see
  # @@authenticators for more information on plugging in your own authenticator.
  #
  # For example:
  #
  # ```ruby
  # imap.authenticate('LOGIN', user, password)
  # ```
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if authentication fails.
  sig do
    params(
      auth_type: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(auth_type, *args); end

  # Sends a CAPABILITY command, and returns an array of capabilities that the
  # server supports. Each capability is a string. See [IMAP] for a list of
  # possible capabilities.
  #
  # Note that the
  # [`Net::IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) class does
  # not modify its behaviour according to the capabilities of the server; it is
  # up to the user of the class to ensure that a certain capability is supported
  # by a server before using it.
  sig {returns(::T.untyped)}
  def capability(); end

  # Sends a CHECK command to request a checkpoint of the currently selected
  # mailbox. This performs implementation-specific housekeeping; for instance,
  # reconciling the mailbox's in-memory and on-disk state.
  sig {returns(::T.untyped)}
  def check(); end

  # The thread to receive exceptions.
  sig {returns(::T.untyped)}
  def client_thread(); end

  # The thread to receive exceptions.
  sig do
    params(
      client_thread: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def client_thread=(client_thread); end

  # Sends a CLOSE command to close the currently selected mailbox. The CLOSE
  # command permanently removes from the mailbox all messages that have the
  # Deleted flag set.
  sig {returns(::T.untyped)}
  def close(); end

  # Sends a COPY command to copy the specified message(s) to the end of the
  # specified destination `mailbox`. The `set` parameter is a number, an array
  # of numbers, or a [`Range`](https://docs.ruby-lang.org/en/2.6.0/Range.html)
  # object. The number is a message sequence number.
  sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def copy(set, mailbox); end

  # Sends a CREATE command to create a new `mailbox`.
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if a mailbox with that name cannot be created.
  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def create(mailbox); end

  # Sends a DELETE command to remove the `mailbox`.
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if a mailbox with that name cannot be deleted, either because it
  # does not exist or because the client does not have permission to delete it.
  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(mailbox); end

  # Disconnects from the server.
  sig {returns(::T.untyped)}
  def disconnect(); end

  # Returns true if disconnected from the server.
  sig {returns(::T.untyped)}
  def disconnected?(); end

  # Sends a EXAMINE command to select a `mailbox` so that messages in the
  # `mailbox` can be accessed. Behaves the same as
  # [`select()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-select),
  # except that the selected `mailbox` is identified as read-only.
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if the mailbox does not exist or is for some reason
  # non-examinable.
  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def examine(mailbox); end

  # Sends a EXPUNGE command to permanently remove from the currently selected
  # mailbox all messages that have the Deleted flag set.
  sig {returns(::T.untyped)}
  def expunge(); end

  # Sends a FETCH command to retrieve data associated with a message in the
  # mailbox.
  #
  # The `set` parameter is a number or a range between two numbers, or an array
  # of those. The number is a message sequence number, where -1 represents a
  # '\*' for use in range notation like 100..-1 being interpreted as '100:\*'.
  # Beware that the `exclude_end?` property of a
  # [`Range`](https://docs.ruby-lang.org/en/2.6.0/Range.html) object is ignored,
  # and the contents of a range are independent of the order of the range
  # endpoints as per the protocol specification, so 1...5, 5..1 and 5...1 are
  # all equivalent to 1..5.
  #
  # `attr` is a list of attributes to fetch; see the documentation for
  # [`Net::IMAP::FetchData`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#FetchData)
  # for a list of valid attributes.
  #
  # The return value is an array of
  # [`Net::IMAP::FetchData`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#FetchData)
  # or nil (instead of an empty array) if there is no matching message.
  #
  # For example:
  #
  # ```ruby
  # p imap.fetch(6..8, "UID")
  # #=> [#<Net::IMAP::FetchData seqno=6, attr={"UID"=>98}>, \\
  #      #<Net::IMAP::FetchData seqno=7, attr={"UID"=>99}>, \\
  #      #<Net::IMAP::FetchData seqno=8, attr={"UID"=>100}>]
  # p imap.fetch(6, "BODY[HEADER.FIELDS (SUBJECT)]")
  # #=> [#<Net::IMAP::FetchData seqno=6, attr={"BODY[HEADER.FIELDS (SUBJECT)]"=>"Subject: test\r\n\r\n"}>]
  # data = imap.uid_fetch(98, ["RFC822.SIZE", "INTERNALDATE"])[0]
  # p data.seqno
  # #=> 6
  # p data.attr["RFC822.SIZE"]
  # #=> 611
  # p data.attr["INTERNALDATE"]
  # #=> "12-Oct-2000 22:40:59 +0900"
  # p data.attr["UID"]
  # #=> 98
  # ```
  sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fetch(set, attr); end

  # Send the GETACL command along with a specified `mailbox`. If this mailbox
  # exists, an array containing objects of
  # [`Net::IMAP::MailboxACLItem`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#MailboxACLItem)
  # will be returned.
  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getacl(mailbox); end

  # Sends the GETQUOTA command along with specified `mailbox`. If this mailbox
  # exists, then an array containing a
  # [`Net::IMAP::MailboxQuota`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#MailboxQuota)
  # object is returned. This command is generally only available to server
  # admin.
  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getquota(mailbox); end

  # Sends the GETQUOTAROOT command along with the specified `mailbox`. This
  # command is generally available to both admin and user. If this mailbox
  # exists, it returns an array containing objects of type
  # [`Net::IMAP::MailboxQuotaRoot`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#MailboxQuotaRoot)
  # and
  # [`Net::IMAP::MailboxQuota`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#MailboxQuota).
  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getquotaroot(mailbox); end

  # Returns an initial greeting response from the server.
  sig {returns(::T.untyped)}
  def greeting(); end

  # Sends an IDLE command that waits for notifications of new or expunged
  # messages. Yields responses from the server during the IDLE.
  #
  # Use
  # [`idle_done()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-idle_done)
  # to leave IDLE.
  #
  # If `timeout` is given, this method returns after `timeout` seconds passed.
  # `timeout` can be used for keep-alive. For example, the following code checks
  # the connection for each 60 seconds.
  #
  # ```
  # loop do
  #   imap.idle(60) do |res|
  #     ...
  #   end
  # end
  # ```
  sig do
    params(
      timeout: ::T.untyped,
      response_handler: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def idle(timeout=T.unsafe(nil), &response_handler); end

  # Leaves IDLE.
  sig {returns(::T.untyped)}
  def idle_done(); end

  sig do
    params(
      host: ::T.untyped,
      port_or_options: ::T.untyped,
      usessl: ::T.untyped,
      certs: ::T.untyped,
      verify: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(host, port_or_options=T.unsafe(nil), usessl=T.unsafe(nil), certs=T.unsafe(nil), verify=T.unsafe(nil)); end

  # Sends a LIST command, and returns a subset of names from the complete set of
  # all names available to the client. `refname` provides a context (for
  # instance, a base directory in a directory-based mailbox hierarchy).
  # `mailbox` specifies a mailbox or (via wildcards) mailboxes under that
  # context. Two wildcards may be used in `mailbox`: '\*', which matches all
  # characters **including** the hierarchy delimiter (for instance, '/' on a
  # UNIX-hosted directory-based mailbox hierarchy); and '%', which matches all
  # characters **except** the hierarchy delimiter.
  #
  # If `refname` is empty, `mailbox` is used directly to determine which
  # mailboxes to match. If `mailbox` is empty, the root name of `refname` and
  # the hierarchy delimiter are returned.
  #
  # The return value is an array of `Net::IMAP::MailboxList`. For example:
  #
  # ```ruby
  # imap.create("foo/bar")
  # imap.create("foo/baz")
  # p imap.list("", "foo/%")
  # #=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim="/", name="foo/">, \\
  #      #<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim="/", name="foo/bar">, \\
  #      #<Net::IMAP::MailboxList attr=[:Noinferiors], delim="/", name="foo/baz">]
  # ```
  sig do
    params(
      refname: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def list(refname, mailbox); end

  # Sends a LOGIN command to identify the client and carries the plaintext
  # `password` authenticating this `user`. Note that, unlike calling
  # [`authenticate()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-authenticate)
  # with an `auth_type` of "LOGIN",
  # [`login()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-login)
  # does **not** use the login authenticator.
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if authentication fails.
  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def login(user, password); end

  # Sends a LOGOUT command to inform the server that the client is done with the
  # connection.
  sig {returns(::T.untyped)}
  def logout(); end

  # Sends a LSUB command, and returns a subset of names from the set of names
  # that the user has declared as being "active" or "subscribed."  `refname` and
  # `mailbox` are interpreted as for
  # [`list()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-list).
  # The return value is an array of `Net::IMAP::MailboxList`.
  sig do
    params(
      refname: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lsub(refname, mailbox); end

  # Sends a MOVE command to move the specified message(s) to the end of the
  # specified destination `mailbox`. The `set` parameter is a number, an array
  # of numbers, or a [`Range`](https://docs.ruby-lang.org/en/2.6.0/Range.html)
  # object. The number is a message sequence number. The
  # [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) MOVE extension
  # is described in [RFC-6851].
  sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def move(set, mailbox); end

  # Sends a NOOP command to the server. It does nothing.
  sig {returns(::T.untyped)}
  def noop(); end

  # Removes the response handler.
  sig do
    params(
      handler: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove_response_handler(handler); end

  # Sends a RENAME command to change the name of the `mailbox` to `newname`.
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if a mailbox with the name `mailbox` cannot be renamed to
  # `newname` for whatever reason; for instance, because `mailbox` does not
  # exist, or because there is already a mailbox with the name `newname`.
  sig do
    params(
      mailbox: ::T.untyped,
      newname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(mailbox, newname); end

  # Returns all response handlers.
  sig {returns(::T.untyped)}
  def response_handlers(); end

  # Returns recorded untagged responses. For example:
  #
  # ```ruby
  # imap.select("inbox")
  # p imap.responses["EXISTS"][-1]
  # #=> 2
  # p imap.responses["UIDVALIDITY"][-1]
  # #=> 968263756
  # ```
  sig {returns(::T.untyped)}
  def responses(); end

  # Sends a SEARCH command to search the mailbox for messages that match the
  # given searching criteria, and returns message sequence numbers. `keys` can
  # either be a string holding the entire search string, or a single-dimension
  # array of search keywords and arguments. The following are some common search
  # criteria; see [IMAP] section 6.4.4 for a full list.
  #
  # <message set>
  # :   a set of message sequence numbers. ',' indicates an interval, ':'
  #     indicates a range. For instance, '2,10:12,15' means "2,10,11,12,15".
  #
  # BEFORE <date>
  # :   messages with an internal date strictly before <date>. The date argument
  #     has a format similar to 8-Aug-2002.
  #
  # BODY <string>
  # :   messages that contain <string> within their body.
  #
  # CC <string>
  # :   messages containing <string> in their CC field.
  #
  # FROM <string>
  # :   messages that contain <string> in their FROM field.
  #
  # NEW
  # :   messages with the Recent, but not the Seen, flag set.
  #
  # NOT <search-key>
  # :   negate the following search key.
  #
  # OR <search-key> <search-key>
  # :   "or" two search keys together.
  #
  # ON <date>
  # :   messages with an internal date exactly equal to <date>, which has a
  #     format similar to 8-Aug-2002.
  #
  # SINCE <date>
  # :   messages with an internal date on or after <date>.
  #
  # SUBJECT <string>
  # :   messages with <string> in their subject.
  #
  # TO <string>
  # :   messages with <string> in their TO field.
  #
  #
  # For example:
  #
  # ```ruby
  # p imap.search(["SUBJECT", "hello", "NOT", "NEW"])
  # #=> [1, 6, 7, 8]
  # ```
  sig do
    params(
      keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def search(keys, charset=T.unsafe(nil)); end

  # Sends a SELECT command to select a `mailbox` so that messages in the
  # `mailbox` can be accessed.
  #
  # After you have selected a mailbox, you may retrieve the number of items in
  # that mailbox from @[responses]("EXISTS")[-1], and the number of recent
  # messages from @[responses]("RECENT")[-1]. Note that these values can change
  # if new messages arrive during a session; see
  # [`add_response_handler()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-add_response_handler)
  # for a way of detecting this event.
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if the mailbox does not exist or is for some reason
  # non-selectable.
  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def select(mailbox); end

  # Sends the SETACL command along with `mailbox`, `user` and the `rights` that
  # user is to have on that mailbox. If `rights` is nil, then that user will be
  # stripped of any rights to that mailbox. The
  # [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html)
  # [`ACL`](https://docs.ruby-lang.org/en/2.6.0/ACL.html) commands are described
  # in [RFC-2086].
  sig do
    params(
      mailbox: ::T.untyped,
      user: ::T.untyped,
      rights: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setacl(mailbox, user, rights); end

  # Sends a SETQUOTA command along with the specified `mailbox` and `quota`. If
  # `quota` is nil, then `quota` will be unset for that mailbox. Typically one
  # needs to be logged in as a server admin for this to work. The
  # [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) quota commands
  # are described in [RFC-2087].
  sig do
    params(
      mailbox: ::T.untyped,
      quota: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setquota(mailbox, quota); end

  # Sends a SORT command to sort messages in the mailbox. Returns an array of
  # message sequence numbers. For example:
  #
  # ```ruby
  # p imap.sort(["FROM"], ["ALL"], "US-ASCII")
  # #=> [1, 2, 3, 5, 6, 7, 8, 4, 9]
  # p imap.sort(["DATE"], ["SUBJECT", "hello"], "US-ASCII")
  # #=> [6, 7, 8, 1]
  # ```
  #
  # See [SORT-THREAD-EXT] for more details.
  sig do
    params(
      sort_keys: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sort(sort_keys, search_keys, charset); end

  # Sends a STARTTLS command to start TLS session.
  sig do
    params(
      options: ::T.untyped,
      verify: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def starttls(options=T.unsafe(nil), verify=T.unsafe(nil)); end

  # Sends a STATUS command, and returns the status of the indicated `mailbox`.
  # `attr` is a list of one or more attributes whose statuses are to be
  # requested. Supported attributes include:
  #
  # ```
  # MESSAGES:: the number of messages in the mailbox.
  # RECENT:: the number of recent messages in the mailbox.
  # UNSEEN:: the number of unseen messages in the mailbox.
  # ```
  #
  # The return value is a hash of attributes. For example:
  #
  # ```ruby
  # p imap.status("inbox", ["MESSAGES", "RECENT"])
  # #=> {"RECENT"=>0, "MESSAGES"=>44}
  # ```
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if status values for `mailbox` cannot be returned; for instance,
  # because it does not exist.
  sig do
    params(
      mailbox: ::T.untyped,
      attr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def status(mailbox, attr); end

  # Sends a STORE command to alter data associated with messages in the mailbox,
  # in particular their flags. The `set` parameter is a number, an array of
  # numbers, or a [`Range`](https://docs.ruby-lang.org/en/2.6.0/Range.html)
  # object. Each number is a message sequence number. `attr` is the name of a
  # data item to store: 'FLAGS' will replace the message's flag list with the
  # provided one, '+FLAGS' will add the provided flags, and '-FLAGS' will remove
  # them. `flags` is a list of flags.
  #
  # The return value is an array of
  # [`Net::IMAP::FetchData`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#FetchData).
  # For example:
  #
  # ```ruby
  # p imap.store(6..8, "+FLAGS", [:Deleted])
  # #=> [#<Net::IMAP::FetchData seqno=6, attr={"FLAGS"=>[:Seen, :Deleted]}>, \\
  #      #<Net::IMAP::FetchData seqno=7, attr={"FLAGS"=>[:Seen, :Deleted]}>, \\
  #      #<Net::IMAP::FetchData seqno=8, attr={"FLAGS"=>[:Seen, :Deleted]}>]
  # ```
  sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def store(set, attr, flags); end

  # Sends a SUBSCRIBE command to add the specified `mailbox` name to the
  # server's set of "active" or "subscribed" mailboxes as returned by
  # [`lsub()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-lsub).
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if `mailbox` cannot be subscribed to; for instance, because it
  # does not exist.
  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subscribe(mailbox); end

  # Similar to
  # [`search()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-search),
  # but returns message sequence numbers in threaded format, as a
  # [`Net::IMAP::ThreadMember`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#ThreadMember)
  # tree. The supported algorithms are:
  #
  # ORDEREDSUBJECT
  # :   split into single-level threads according to subject, ordered by date.
  # REFERENCES
  # :   split into threads by parent/child relationships determined by which
  #     message is a reply to which.
  #
  #
  # Unlike
  # [`search()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-search),
  # `charset` is a required argument. US-ASCII and UTF-8 are sample values.
  #
  # See [SORT-THREAD-EXT] for more details.
  sig do
    params(
      algorithm: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def thread(algorithm, search_keys, charset); end

  # Similar to
  # [`copy()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-copy),
  # but `set` contains unique identifiers.
  sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_copy(set, mailbox); end

  # Similar to
  # [`fetch()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-fetch),
  # but `set` contains unique identifiers.
  sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_fetch(set, attr); end

  # Similar to
  # [`move()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-move),
  # but `set` contains unique identifiers.
  sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_move(set, mailbox); end

  # Similar to
  # [`search()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-search),
  # but returns unique identifiers.
  sig do
    params(
      keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_search(keys, charset=T.unsafe(nil)); end

  # Similar to
  # [`sort()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-sort),
  # but returns an array of unique identifiers.
  sig do
    params(
      sort_keys: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_sort(sort_keys, search_keys, charset); end

  # Similar to
  # [`store()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-store),
  # but `set` contains unique identifiers.
  sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_store(set, attr, flags); end

  # Similar to
  # [`thread()`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-thread),
  # but returns unique identifiers instead of message sequence numbers.
  sig do
    params(
      algorithm: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_thread(algorithm, search_keys, charset); end

  # Sends a UNSUBSCRIBE command to remove the specified `mailbox` name from the
  # server's set of "active" or "subscribed" mailboxes.
  #
  # A
  # [`Net::IMAP::NoResponseError`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/NoResponseError.html)
  # is raised if `mailbox` cannot be unsubscribed from; for instance, because
  # the client is not currently subscribed to it.
  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unsubscribe(mailbox); end

  # Sends a XLIST command, and returns a subset of names from the complete set
  # of all names available to the client. `refname` provides a context (for
  # instance, a base directory in a directory-based mailbox hierarchy).
  # `mailbox` specifies a mailbox or (via wildcards) mailboxes under that
  # context. Two wildcards may be used in `mailbox`: '\*', which matches all
  # characters **including** the hierarchy delimiter (for instance, '/' on a
  # UNIX-hosted directory-based mailbox hierarchy); and '%', which matches all
  # characters **except** the hierarchy delimiter.
  #
  # If `refname` is empty, `mailbox` is used directly to determine which
  # mailboxes to match. If `mailbox` is empty, the root name of `refname` and
  # the hierarchy delimiter are returned.
  #
  # The XLIST command is like the LIST command except that the flags returned
  # refer to the function of the folder/mailbox, e.g. :Sent
  #
  # The return value is an array of `Net::IMAP::MailboxList`. For example:
  #
  # ```ruby
  # imap.create("foo/bar")
  # imap.create("foo/baz")
  # p imap.xlist("", "foo/%")
  # #=> [#<Net::IMAP::MailboxList attr=[:Noselect], delim="/", name="foo/">, \\
  #      #<Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim="/", name="foo/bar">, \\
  #      #<Net::IMAP::MailboxList attr=[:Noinferiors], delim="/", name="foo/baz">]
  # ```
  sig do
    params(
      refname: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def xlist(refname, mailbox); end

  # Adds an authenticator for
  # [`Net::IMAP#authenticate`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-authenticate).
  # `auth_type` is the type of authentication this authenticator supports (for
  # instance, "LOGIN"). The `authenticator` is an object which defines a
  # process() method to handle authentication with the server. See
  # [`Net::IMAP::LoginAuthenticator`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/LoginAuthenticator.html),
  # [`Net::IMAP::CramMD5Authenticator`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/CramMD5Authenticator.html),
  # and
  # [`Net::IMAP::DigestMD5Authenticator`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/DigestMD5Authenticator.html)
  # for examples.
  #
  # If `auth_type` refers to an existing authenticator, it will be replaced by
  # the new one.
  sig do
    params(
      auth_type: ::T.untyped,
      authenticator: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.add_authenticator(auth_type, authenticator); end

  # Returns the debug mode.
  sig {returns(::T.untyped)}
  def self.debug(); end

  # Sets the debug mode.
  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.debug=(val); end

  # Decode a string from modified UTF-7 format to UTF-8.
  #
  # UTF-7 is a 7-bit encoding of Unicode [UTF7].
  # [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) uses a slightly
  # modified version of this to encode mailbox names containing non-ASCII
  # characters; see [IMAP] section 5.1.3.
  #
  # [`Net::IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) does *not*
  # automatically encode and decode mailbox names to and from UTF-7.
  sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.decode_utf7(s); end

  # Alias for:
  # [`default_port`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-c-default_port)
  sig {returns(::T.untyped)}
  def self.default_imap_port(); end

  # Alias for:
  # [`default_tls_port`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-c-default_tls_port)
  sig {returns(::T.untyped)}
  def self.default_imaps_port(); end

  # The default port for
  # [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) connections,
  # port 143
  #
  # Also aliased as:
  # [`default_imap_port`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-c-default_imap_port)
  sig {returns(::T.untyped)}
  def self.default_port(); end

  # Alias for:
  # [`default_tls_port`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-c-default_tls_port)
  sig {returns(::T.untyped)}
  def self.default_ssl_port(); end

  # The default port for IMAPS connections, port 993
  #
  # Also aliased as:
  # [`default_imaps_port`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-c-default_imaps_port),
  # [`default_ssl_port`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-c-default_ssl_port)
  sig {returns(::T.untyped)}
  def self.default_tls_port(); end

  # Encode a string from UTF-8 format to modified UTF-7.
  sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.encode_utf7(s); end

  # Formats `time` as an IMAP-style date.
  sig do
    params(
      time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.format_date(time); end

  # Formats `time` as an IMAP-style date-time.
  sig do
    params(
      time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.format_datetime(time); end

  # Returns the max number of flags interned to symbols.
  sig {returns(::T.untyped)}
  def self.max_flag_count(); end

  # Sets the max number of flags interned to symbols.
  sig do
    params(
      count: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.max_flag_count=(count); end
end

# [`Net::IMAP::Address`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#Address)
# represents electronic mail addresses.
#
# #### Fields:
#
# name
# :   Returns the phrase from [RFC-822] mailbox.
#
# route
# :   Returns the route from [RFC-822] route-addr.
#
# mailbox
# :   nil indicates end of [RFC-822] group. If non-nil and host is nil, returns
#     [RFC-822] group name. Otherwise, returns [RFC-822] local-part.
#
# host
# :   nil indicates [RFC-822] group syntax. Otherwise, returns [RFC-822] domain
#     name.
class Net::IMAP::Address < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def host(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def host=(_); end

  sig {returns(::T.untyped)}
  def mailbox(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  sig {returns(::T.untyped)}
  def name(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  sig {returns(::T.untyped)}
  def route(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def route=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::Atom
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  sig {returns(::T.untyped)}
  def validate(); end
end

# Error raised upon a "BAD" response from the server, indicating that the client
# command violated the
# [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html) protocol, or an
# internal server failure has occurred.
class Net::IMAP::BadResponseError < Net::IMAP::ResponseError
end

# [`Net::IMAP::BodyTypeAttachment`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeAttachment.html)
# represents attachment body structures of messages.
#
# #### Fields:
#
# media\_type
# :   Returns the content media type name.
#
# subtype
# :   Returns `nil`.
#
# param
# :   Returns a hash that represents parameters.
#
# multipart?
# :   Returns false.
class Net::IMAP::BodyTypeAttachment
  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

# [`Net::IMAP::BodyTypeBasic`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeBasic.html)
# represents basic body structures of messages.
#
# #### Fields:
#
# media\_type
# :   Returns the content media type name as defined in [MIME-IMB].
#
# subtype
# :   Returns the content subtype name as defined in [MIME-IMB].
#
# param
# :   Returns a hash that represents parameters as defined in [MIME-IMB].
#
# content\_id
# :   Returns a string giving the content id as defined in [MIME-IMB].
#
# description
# :   Returns a string giving the content description as defined in [MIME-IMB].
#
# encoding
# :   Returns a string giving the content transfer encoding as defined in
#     [MIME-IMB].
#
# size
# :   Returns a number giving the size of the body in octets.
#
# md5
# :   Returns a string giving the body MD5 value as defined in [MD5].
#
# disposition
# :   Returns a Net::IMAP::ContentDisposition object giving the content
#     disposition.
#
# language
# :   Returns a string or an array of strings giving the body language value as
#     defined in [LANGUAGE-TAGS].
#
# extension
# :   Returns extension data.
#
# multipart?
# :   Returns false.
class Net::IMAP::BodyTypeBasic
  sig {returns(::T.untyped)}
  def content_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  sig {returns(::T.untyped)}
  def description(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  sig {returns(::T.untyped)}
  def disposition(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  sig {returns(::T.untyped)}
  def encoding(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  sig {returns(::T.untyped)}
  def extension(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  sig {returns(::T.untyped)}
  def language(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  sig {returns(::T.untyped)}
  def md5(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def md5=(_); end

  # Obsolete: use `subtype` instead. Calling this will generate a warning
  # message to `stderr`, then return the value of `subtype`.
  sig {returns(::T.untyped)}
  def media_subtype(); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeExtension
  sig {returns(::T.untyped)}
  def content_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  sig {returns(::T.untyped)}
  def description(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  sig {returns(::T.untyped)}
  def encoding(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def params(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def params=(_); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

# [`Net::IMAP::BodyTypeMessage`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeMessage.html)
# represents MESSAGE/RFC822 body structures of messages.
#
# #### Fields:
#
# envelope
# :   Returns a Net::IMAP::Envelope giving the envelope structure.
#
# body
# :   Returns an object giving the body structure.
#
#
# And
# [`Net::IMAP::BodyTypeMessage`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeMessage.html)
# has all methods of
# [`Net::IMAP::BodyTypeText`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeText.html).
class Net::IMAP::BodyTypeMessage
  sig {returns(::T.untyped)}
  def body(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body=(_); end

  sig {returns(::T.untyped)}
  def content_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  sig {returns(::T.untyped)}
  def description(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  sig {returns(::T.untyped)}
  def disposition(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  sig {returns(::T.untyped)}
  def encoding(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  sig {returns(::T.untyped)}
  def envelope(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def envelope=(_); end

  sig {returns(::T.untyped)}
  def extension(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  sig {returns(::T.untyped)}
  def language(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  sig {returns(::T.untyped)}
  def lines(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lines=(_); end

  sig {returns(::T.untyped)}
  def md5(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def md5=(_); end

  # Obsolete: use `subtype` instead. Calling this will generate a warning
  # message to `stderr`, then return the value of `subtype`.
  sig {returns(::T.untyped)}
  def media_subtype(); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

# [`Net::IMAP::BodyTypeMultipart`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeMultipart.html)
# represents multipart body structures of messages.
#
# #### Fields:
#
# media\_type
# :   Returns the content media type name as defined in [MIME-IMB].
#
# subtype
# :   Returns the content subtype name as defined in [MIME-IMB].
#
# parts
# :   Returns multiple parts.
#
# param
# :   Returns a hash that represents parameters as defined in [MIME-IMB].
#
# disposition
# :   Returns a Net::IMAP::ContentDisposition object giving the content
#     disposition.
#
# language
# :   Returns a string or an array of strings giving the body language value as
#     defined in [LANGUAGE-TAGS].
#
# extension
# :   Returns extension data.
#
# multipart?
# :   Returns true.
class Net::IMAP::BodyTypeMultipart
  sig {returns(::T.untyped)}
  def disposition(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  sig {returns(::T.untyped)}
  def extension(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  sig {returns(::T.untyped)}
  def language(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  # Obsolete: use `subtype` instead. Calling this will generate a warning
  # message to `stderr`, then return the value of `subtype`.
  sig {returns(::T.untyped)}
  def media_subtype(); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig {returns(::T.untyped)}
  def parts(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parts=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

# [`Net::IMAP::BodyTypeText`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeText.html)
# represents TEXT body structures of messages.
#
# #### Fields:
#
# lines
# :   Returns the size of the body in text lines.
#
#
# And
# [`Net::IMAP::BodyTypeText`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeText.html)
# has all fields of
# [`Net::IMAP::BodyTypeBasic`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeBasic.html).
class Net::IMAP::BodyTypeText
  sig {returns(::T.untyped)}
  def content_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  sig {returns(::T.untyped)}
  def description(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  sig {returns(::T.untyped)}
  def disposition(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  sig {returns(::T.untyped)}
  def encoding(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  sig {returns(::T.untyped)}
  def extension(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  sig {returns(::T.untyped)}
  def language(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  sig {returns(::T.untyped)}
  def lines(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lines=(_); end

  sig {returns(::T.untyped)}
  def md5(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def md5=(_); end

  # Obsolete: use `subtype` instead. Calling this will generate a warning
  # message to `stderr`, then return the value of `subtype`.
  sig {returns(::T.untyped)}
  def media_subtype(); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

# Error raised upon a "BYE" response from the server, indicating that the client
# is not being allowed to login, or has been timed out due to inactivity.
class Net::IMAP::ByeResponseError < Net::IMAP::ResponseError
end

# [`Net::IMAP::ContentDisposition`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#ContentDisposition)
# represents Content-Disposition fields.
#
# #### Fields:
#
# dsp\_type
# :   Returns the disposition type.
#
# param
# :   Returns a hash that represents parameters of the Content-Disposition
#     field.
class Net::IMAP::ContentDisposition < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def dsp_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dsp_type=(_); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# [`Net::IMAP::ContinuationRequest`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#ContinuationRequest)
# represents command continuation requests.
#
# The command continuation request response is indicated by a "+" token instead
# of a tag. This form of response indicates that the server is ready to accept
# the continuation of a command from the client. The remainder of this response
# is a line of text.
#
# ```
# continue_req    ::= "+" SPACE (resp_text / base64)
# ```
#
# #### Fields:
#
# data
# :   Returns the data (Net::IMAP::ResponseText).
#
# raw\_data
# :   Returns the raw data string.
class Net::IMAP::ContinuationRequest < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  sig {returns(::T.untyped)}
  def raw_data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def raw_data=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# Authenticator for the "CRAM-MD5" authentication type. See authenticate().
class Net::IMAP::CramMD5Authenticator
  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password); end

  sig do
    params(
      challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(challenge); end
end

# Error raised when data is in the incorrect format.
class Net::IMAP::DataFormatError < Net::IMAP::Error
end

# Authenticator for the "DIGEST-MD5" authentication type. See authenticate().
class Net::IMAP::DigestMD5Authenticator
  STAGE_ONE = ::T.let(nil, ::T.untyped)
  STAGE_TWO = ::T.let(nil, ::T.untyped)

  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
      authname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password, authname=T.unsafe(nil)); end

  sig do
    params(
      challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(challenge); end
end

# [`Net::IMAP::Envelope`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#Envelope)
# represents envelope structures of messages.
#
# #### Fields:
#
# date
# :   Returns a string that represents the date.
#
# subject
# :   Returns a string that represents the subject.
#
# from
# :   Returns an array of
#     [`Net::IMAP::Address`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#Address)
#     that represents the from.
#
# sender
# :   Returns an array of
#     [`Net::IMAP::Address`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#Address)
#     that represents the sender.
#
# reply\_to
# :   Returns an array of
#     [`Net::IMAP::Address`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#Address)
#     that represents the reply-to.
#
# to
# :   Returns an array of
#     [`Net::IMAP::Address`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#Address)
#     that represents the to.
#
# cc
# :   Returns an array of
#     [`Net::IMAP::Address`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#Address)
#     that represents the cc.
#
# bcc
# :   Returns an array of
#     [`Net::IMAP::Address`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#Address)
#     that represents the bcc.
#
# in\_reply\_to
# :   Returns a string that represents the in-reply-to.
#
# message\_id
# :   Returns a string that represents the message-id.
class Net::IMAP::Envelope < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def bcc(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def bcc=(_); end

  sig {returns(::T.untyped)}
  def cc(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cc=(_); end

  sig {returns(::T.untyped)}
  def date(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def date=(_); end

  sig {returns(::T.untyped)}
  def from(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def from=(_); end

  sig {returns(::T.untyped)}
  def in_reply_to(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def in_reply_to=(_); end

  sig {returns(::T.untyped)}
  def message_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def message_id=(_); end

  sig {returns(::T.untyped)}
  def reply_to(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reply_to=(_); end

  sig {returns(::T.untyped)}
  def sender(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sender=(_); end

  sig {returns(::T.untyped)}
  def subject(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subject=(_); end

  sig {returns(::T.untyped)}
  def to(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# Superclass of [`IMAP`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html)
# errors.
class Net::IMAP::Error < StandardError
end

# [`Net::IMAP::FetchData`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#FetchData)
# represents the contents of the FETCH response.
#
# #### Fields:
#
# seqno
# :   Returns the message sequence number. (Note: not the unique identifier,
#     even for the UID command response.)
#
# attr
# :   Returns a hash. Each key is a data item name, and each value is its value.
#
#     The current data items are:
#
#     BODY
# :       A form of BODYSTRUCTURE without extension data.
#     [BODY](<section>)<<origin\_octet>>
# :       A string expressing the body contents of the specified section.
#     BODYSTRUCTURE
# :       An object that describes the [MIME-IMB] body structure of a message.
#         See
#         [`Net::IMAP::BodyTypeBasic`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeBasic.html),
#         [`Net::IMAP::BodyTypeText`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeText.html),
#         [`Net::IMAP::BodyTypeMessage`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeMessage.html),
#         [`Net::IMAP::BodyTypeMultipart`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP/BodyTypeMultipart.html).
#     ENVELOPE
# :       A
#         [`Net::IMAP::Envelope`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#Envelope)
#         object that describes the envelope structure of a message.
#     FLAGS
# :       A array of flag symbols that are set for this message. Flag symbols
#         are capitalized by
#         [`String#capitalize`](https://docs.ruby-lang.org/en/2.6.0/String.html#method-i-capitalize).
#     INTERNALDATE
# :       A string representing the internal date of the message.
#     RFC822
# :       Equivalent to BODY[].
#     RFC822.HEADER
# :       Equivalent to [BODY.PEEK](HEADER).
#     RFC822.SIZE
# :       A number expressing the [RFC-822] size of the message.
#     RFC822.TEXT
# :       Equivalent to [BODY](TEXT).
#     UID
# :       A number expressing the unique identifier of the message.
class Net::IMAP::FetchData < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def attr(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attr=(_); end

  sig {returns(::T.untyped)}
  def seqno(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def seqno=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# Error raised when too many flags are interned to symbols.
class Net::IMAP::FlagCountError < Net::IMAP::Error
end

class Net::IMAP::Literal
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  sig {returns(::T.untyped)}
  def validate(); end
end

# Authenticator for the "LOGIN" authentication type. See authenticate().
class Net::IMAP::LoginAuthenticator
  STATE_PASSWORD = ::T.let(nil, ::T.untyped)
  STATE_USER = ::T.let(nil, ::T.untyped)

  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(data); end
end

# [`Net::IMAP::MailboxACLItem`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#MailboxACLItem)
# represents the response from GETACL.
#
# ```
# acl_data        ::= "ACL" SPACE mailbox *(SPACE identifier SPACE rights)
#
# identifier      ::= astring
#
# rights          ::= astring
# ```
#
# #### Fields:
#
# user
# :   Login name that has certain rights to the mailbox that was specified with
#     the getacl command.
#
# rights
# :   The access rights the indicated user has to the mailbox.
class Net::IMAP::MailboxACLItem < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def mailbox(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  sig {returns(::T.untyped)}
  def rights(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rights=(_); end

  sig {returns(::T.untyped)}
  def user(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def user=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# [`Net::IMAP::MailboxList`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#MailboxList)
# represents contents of the LIST response.
#
# ```
# mailbox_list    ::= "(" #("\Marked" / "\Noinferiors" /
#                     "\Noselect" / "\Unmarked" / flag_extension) ")"
#                     SPACE (<"> QUOTED_CHAR <"> / nil) SPACE mailbox
# ```
#
# #### Fields:
#
# attr
# :   Returns the name attributes. Each name attribute is a symbol capitalized
#     by
#     [`String#capitalize`](https://docs.ruby-lang.org/en/2.6.0/String.html#method-i-capitalize),
#     such as :Noselect (not :NoSelect).
#
# delim
# :   Returns the hierarchy delimiter.
#
# name
# :   Returns the mailbox name.
class Net::IMAP::MailboxList < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def attr(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attr=(_); end

  sig {returns(::T.untyped)}
  def delim(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delim=(_); end

  sig {returns(::T.untyped)}
  def name(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# [`Net::IMAP::MailboxQuota`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#MailboxQuota)
# represents contents of GETQUOTA response. This object can also be a response
# to GETQUOTAROOT. In the syntax specification below, the delimiter used with
# the "#" construct is a single space (SPACE).
#
# ```
# quota_list      ::= "(" #quota_resource ")"
#
# quota_resource  ::= atom SPACE number SPACE number
#
# quota_response  ::= "QUOTA" SPACE astring SPACE quota_list
# ```
#
# #### Fields:
#
# mailbox
# :   The mailbox with the associated quota.
#
# usage
# :   Current storage usage of the mailbox.
#
# quota
# :   Quota limit imposed on the mailbox.
class Net::IMAP::MailboxQuota < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def mailbox(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  sig {returns(::T.untyped)}
  def quota(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def quota=(_); end

  sig {returns(::T.untyped)}
  def usage(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def usage=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# [`Net::IMAP::MailboxQuotaRoot`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#MailboxQuotaRoot)
# represents part of the GETQUOTAROOT response. (GETQUOTAROOT can also return
# [`Net::IMAP::MailboxQuota`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#MailboxQuota).)
#
# ```
# quotaroot_response ::= "QUOTAROOT" SPACE astring *(SPACE astring)
# ```
#
# #### Fields:
#
# mailbox
# :   The mailbox with the associated quota.
#
# quotaroots
# :   Zero or more quotaroots that affect the quota on the specified mailbox.
class Net::IMAP::MailboxQuotaRoot < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def mailbox(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  sig {returns(::T.untyped)}
  def quotaroots(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def quotaroots=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::MessageSet
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  sig {returns(::T.untyped)}
  def validate(); end
end

# Error raised upon a "NO" response from the server, indicating that the client
# command could not be completed successfully.
class Net::IMAP::NoResponseError < Net::IMAP::ResponseError
end

# Common validators of number and nz\_number types
module Net::IMAP::NumValidator
  # Ensure argument is 'number' or raise DataFormatError
  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ensure_number(num); end

  # Ensure argument is 'nz\_number' or raise DataFormatError
  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ensure_nz_number(num); end

  # Check is passed argument valid 'number' in RFC 3501 terminology
  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.valid_number?(num); end

  # Check is passed argument valid 'nz\_number' in RFC 3501 terminology
  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.valid_nz_number?(num); end
end

# Authenticator for the "PLAIN" authentication type. See authenticate().
class Net::IMAP::PlainAuthenticator
  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(data); end
end

class Net::IMAP::QuotedString
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::RawData
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  sig {returns(::T.untyped)}
  def validate(); end
end

# [`Net::IMAP::ResponseCode`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#ResponseCode)
# represents response codes.
#
# ```
# resp_text_code  ::= "ALERT" / "PARSE" /
#                     "PERMANENTFLAGS" SPACE "(" #(flag / "\*") ")" /
#                     "READ-ONLY" / "READ-WRITE" / "TRYCREATE" /
#                     "UIDVALIDITY" SPACE nz_number /
#                     "UNSEEN" SPACE nz_number /
#                     atom [SPACE 1*<any TEXT_CHAR except "]">]
# ```
#
# #### Fields:
#
# name
# :   Returns the name, such as "ALERT", "PERMANENTFLAGS", or "UIDVALIDITY".
#
# data
# :   Returns the data, if it exists.
class Net::IMAP::ResponseCode < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  sig {returns(::T.untyped)}
  def name(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# Superclass of all errors used to encapsulate "fail" responses from the server.
class Net::IMAP::ResponseError < Net::IMAP::Error
  sig do
    params(
      response: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(response); end

  # The response that caused this error
  sig {returns(::T.untyped)}
  def response(); end

  # The response that caused this error
  sig do
    params(
      response: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def response=(response); end
end

# Error raised when a response from the server is non-parseable.
class Net::IMAP::ResponseParseError < Net::IMAP::Error
end

class Net::IMAP::ResponseParser
  ADDRESS_REGEXP = ::T.let(nil, ::T.untyped)
  ATOM_TOKENS = ::T.let(nil, ::T.untyped)
  BEG_REGEXP = ::T.let(nil, ::T.untyped)
  CTEXT_REGEXP = ::T.let(nil, ::T.untyped)
  DATA_REGEXP = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CTEXT = ::T.let(nil, ::T.untyped)
  EXPR_DATA = ::T.let(nil, ::T.untyped)
  EXPR_RTEXT = ::T.let(nil, ::T.untyped)
  EXPR_TEXT = ::T.let(nil, ::T.untyped)
  FLAG_REGEXP = ::T.let(nil, ::T.untyped)
  RTEXT_REGEXP = ::T.let(nil, ::T.untyped)
  STRING_TOKENS = ::T.let(nil, ::T.untyped)
  TEXT_REGEXP = ::T.let(nil, ::T.untyped)
  T_ATOM = ::T.let(nil, ::T.untyped)
  T_BSLASH = ::T.let(nil, ::T.untyped)
  T_CRLF = ::T.let(nil, ::T.untyped)
  T_EOF = ::T.let(nil, ::T.untyped)
  T_LBRA = ::T.let(nil, ::T.untyped)
  T_LITERAL = ::T.let(nil, ::T.untyped)
  T_LPAR = ::T.let(nil, ::T.untyped)
  T_NIL = ::T.let(nil, ::T.untyped)
  T_NUMBER = ::T.let(nil, ::T.untyped)
  T_PERCENT = ::T.let(nil, ::T.untyped)
  T_PLUS = ::T.let(nil, ::T.untyped)
  T_QUOTED = ::T.let(nil, ::T.untyped)
  T_RBRA = ::T.let(nil, ::T.untyped)
  T_RPAR = ::T.let(nil, ::T.untyped)
  T_SPACE = ::T.let(nil, ::T.untyped)
  T_STAR = ::T.let(nil, ::T.untyped)
  T_TEXT = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def initialize(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str); end
end

class Net::IMAP::ResponseParser::Token < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def symbol(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symbol=(_); end

  sig {returns(::T.untyped)}
  def value(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# [`Net::IMAP::ResponseText`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#ResponseText)
# represents texts of responses. The text may be prefixed by the response code.
#
# ```
# resp_text       ::= ["[" resp_text_code "]" SPACE] (text_mime2 / text)
#                     ;; text SHOULD NOT begin with "[" or "="
# ```
#
# #### Fields:
#
# code
# :   Returns the response code. See ((<Net::IMAP::ResponseCode>)).
#
# text
# :   Returns the text.
class Net::IMAP::ResponseText < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def code(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def code=(_); end

  sig {returns(::T.untyped)}
  def text(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def text=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# [`Net::IMAP::StatusData`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#StatusData)
# represents the contents of the STATUS response.
#
# #### Fields:
#
# mailbox
# :   Returns the mailbox name.
#
# attr
# :   Returns a hash. Each key is one of "MESSAGES", "RECENT", "UIDNEXT",
#     "UIDVALIDITY", "UNSEEN". Each value is a number.
class Net::IMAP::StatusData < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def attr(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attr=(_); end

  sig {returns(::T.untyped)}
  def mailbox(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# [`Net::IMAP::TaggedResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#TaggedResponse)
# represents tagged responses.
#
# The server completion result response indicates the success or failure of the
# operation. It is tagged with the same tag as the client command which began
# the operation.
#
# ```
# response_tagged ::= tag SPACE resp_cond_state CRLF
#
# tag             ::= 1*<any ATOM_CHAR except "+">
#
# resp_cond_state ::= ("OK" / "NO" / "BAD") SPACE resp_text
# ```
#
# #### Fields:
#
# tag
# :   Returns the tag.
#
# name
# :   Returns the name, one of "OK", "NO", or "BAD".
#
# data
# :   Returns the data. See ((<Net::IMAP::ResponseText>)).
#
# raw\_data
# :   Returns the raw data string.
class Net::IMAP::TaggedResponse < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  sig {returns(::T.untyped)}
  def name(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  sig {returns(::T.untyped)}
  def raw_data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def raw_data=(_); end

  sig {returns(::T.untyped)}
  def tag(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tag=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# [`Net::IMAP::ThreadMember`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#ThreadMember)
# represents a thread-node returned by
# [`Net::IMAP#thread`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#method-i-thread).
#
# #### Fields:
#
# seqno
# :   The sequence number of this message.
#
# children
# :   An array of
#     [`Net::IMAP::ThreadMember`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#ThreadMember)
#     objects for mail items that are children of this in the thread.
class Net::IMAP::ThreadMember < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def children(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def children=(_); end

  sig {returns(::T.untyped)}
  def seqno(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def seqno=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

# [`Net::IMAP::UntaggedResponse`](https://docs.ruby-lang.org/en/2.6.0/Net/IMAP.html#UntaggedResponse)
# represents untagged responses.
#
# [`Data`](https://docs.ruby-lang.org/en/2.6.0/Data.html) transmitted by the
# server to the client and status responses that do not indicate command
# completion are prefixed with the token "\*", and are called untagged
# responses.
#
# ```
# response_data   ::= "*" SPACE (resp_cond_state / resp_cond_bye /
#                     mailbox_data / message_data / capability_data)
# ```
#
# #### Fields:
#
# name
# :   Returns the name, such as "FLAGS", "LIST", or "FETCH".
#
# data
# :   Returns the data such as an array of flag symbols, a
#     ((<Net::IMAP::MailboxList>)) object.
#
# raw\_data
# :   Returns the raw data string.
class Net::IMAP::UntaggedResponse < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  sig {returns(::T.untyped)}
  def name(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  sig {returns(::T.untyped)}
  def raw_data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def raw_data=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::InternetMessageIO < Net::BufferedIO
  sig {returns(::T.untyped)}
  def each_list_item(); end

  sig {returns(::T.untyped)}
  def each_message_chunk(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  sig do
    params(
      src: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_message(src); end

  sig do
    params(
      src: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_message_0(src); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_message_by_block(&block); end
end

module Net::NTLM
  BLOB_SIGN = ::T.let(nil, ::T.untyped)
  DEFAULT_FLAGS = ::T.let(nil, ::T.untyped)
  FLAGS = ::T.let(nil, ::T.untyped)
  FLAG_KEYS = ::T.let(nil, ::T.untyped)
  LM_MAGIC = ::T.let(nil, ::T.untyped)
  MAX64 = ::T.let(nil, ::T.untyped)
  SSP_SIGN = ::T.let(nil, ::T.untyped)
  TIME_OFFSET = ::T.let(nil, ::T.untyped)

  sig do
    params(
      plain: ::T.untyped,
      keys: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.apply_des(plain, keys); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.gen_keys(str); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.is_ntlm_hash?(data); end

  sig do
    params(
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.lm_hash(password); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.lm_response(arg); end

  sig do
    params(
      arg: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.lmv2_response(arg, opt=T.unsafe(nil)); end

  sig do
    params(
      arg: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ntlm2_session(arg, opt=T.unsafe(nil)); end

  sig do
    params(
      password: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ntlm_hash(password, opt=T.unsafe(nil)); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ntlm_response(arg); end

  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
      target: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ntlmv2_hash(user, password, target, opt=T.unsafe(nil)); end

  sig do
    params(
      arg: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ntlmv2_response(arg, opt=T.unsafe(nil)); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.pack_int64le(val); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.split7(str); end
end

class Net::NTLM::Blob < Net::NTLM::FieldSet
  sig {returns(::T.untyped)}
  def blob_signature(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def blob_signature=(val); end

  sig {returns(::T.untyped)}
  def challenge(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def challenge=(val); end

  sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def reserved(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reserved=(val); end

  sig {returns(::T.untyped)}
  def target_info(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def target_info=(val); end

  sig {returns(::T.untyped)}
  def timestamp(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def timestamp=(val); end

  sig {returns(::T.untyped)}
  def unknown1(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unknown1=(val); end

  sig {returns(::T.untyped)}
  def unknown2(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unknown2=(val); end
end

class Net::NTLM::ChannelBinding
  sig {returns(::T.untyped)}
  def acceptor_address_length(); end

  sig {returns(::T.untyped)}
  def acceptor_addrtype(); end

  sig {returns(::T.untyped)}
  def application_data(); end

  sig {returns(::T.untyped)}
  def channel(); end

  sig {returns(::T.untyped)}
  def channel_binding_token(); end

  sig {returns(::T.untyped)}
  def channel_hash(); end

  sig {returns(::T.untyped)}
  def gss_channel_bindings_struct(); end

  sig do
    params(
      outer_channel: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(outer_channel); end

  sig {returns(::T.untyped)}
  def initiator_address_length(); end

  sig {returns(::T.untyped)}
  def initiator_addtype(); end

  sig {returns(::T.untyped)}
  def unique_prefix(); end

  sig do
    params(
      outer_channel: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.create(outer_channel); end
end

class Net::NTLM::Client
  DEFAULT_FLAGS = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def domain(); end

  sig {returns(::T.untyped)}
  def flags(); end

  sig do
    params(
      resp: ::T.untyped,
      channel_binding: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def init_context(resp=T.unsafe(nil), channel_binding=T.unsafe(nil)); end

  sig do
    params(
      username: ::T.untyped,
      password: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(username, password, opts=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def password(); end

  sig {returns(::T.untyped)}
  def session(); end

  sig {returns(::T.untyped)}
  def session_key(); end

  sig {returns(::T.untyped)}
  def username(); end

  sig {returns(::T.untyped)}
  def workstation(); end
end

class Net::NTLM::Client::Session
  CLIENT_TO_SERVER_SEALING = ::T.let(nil, ::T.untyped)
  CLIENT_TO_SERVER_SIGNING = ::T.let(nil, ::T.untyped)
  MAX64 = ::T.let(nil, ::T.untyped)
  SERVER_TO_CLIENT_SEALING = ::T.let(nil, ::T.untyped)
  SERVER_TO_CLIENT_SIGNING = ::T.let(nil, ::T.untyped)
  TIME_OFFSET = ::T.let(nil, ::T.untyped)
  VERSION_MAGIC = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def authenticate!(); end

  sig {returns(::T.untyped)}
  def challenge_message(); end

  sig {returns(::T.untyped)}
  def channel_binding(); end

  sig {returns(::T.untyped)}
  def client(); end

  sig {returns(::T.untyped)}
  def exported_session_key(); end

  sig do
    params(
      client: ::T.untyped,
      challenge_message: ::T.untyped,
      channel_binding: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(client, challenge_message, channel_binding=T.unsafe(nil)); end

  sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def seal_message(message); end

  sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign_message(message); end

  sig do
    params(
      emessage: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unseal_message(emessage); end

  sig do
    params(
      signature: ::T.untyped,
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_signature(signature, message); end
end

class Net::NTLM::EncodeUtil
  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.decode_utf16le(str); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.encode_utf16le(str); end
end

class Net::NTLM::Field
  sig {returns(::T.untyped)}
  def active(); end

  sig do
    params(
      active: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def active=(active); end

  sig do
    params(
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opts); end

  sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def serialize(); end

  sig {returns(::T.untyped)}
  def size(); end

  sig {returns(::T.untyped)}
  def value(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(value); end
end

class Net::NTLM::FieldSet
  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](name); end

  sig do
    params(
      name: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(name, val); end

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disable(name); end

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable(name); end

  sig {returns(::T.untyped)}
  def has_disabled_fields?(); end

  sig {returns(::T.untyped)}
  def initialize(); end

  sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def serialize(); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      name: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.int16LE(name, opts); end

  sig do
    params(
      name: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.int32LE(name, opts); end

  sig do
    params(
      name: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.int64LE(name, opts); end

  sig {returns(::T.untyped)}
  def self.names(); end

  sig {returns(::T.untyped)}
  def self.opts(); end

  sig {returns(::T.untyped)}
  def self.prototypes(); end

  sig do
    params(
      name: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.security_buffer(name, opts); end

  sig do
    params(
      name: ::T.untyped,
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.string(name, opts); end

  sig {returns(::T.untyped)}
  def self.types(); end
end

class Net::NTLM::Int16LE < Net::NTLM::Field
  sig do
    params(
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opt); end

  sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def serialize(); end
end

class Net::NTLM::Int32LE < Net::NTLM::Field
  sig do
    params(
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opt); end

  sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def serialize(); end
end

class Net::NTLM::Int64LE < Net::NTLM::Field
  sig do
    params(
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opt); end

  sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def serialize(); end
end

class Net::NTLM::InvalidTargetDataError < Net::NTLM::NtlmError
  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      msg: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(msg, data); end
end

class Net::NTLM::Message < Net::NTLM::FieldSet
  sig {returns(::T.untyped)}
  def data_edge(); end

  sig {returns(::T.untyped)}
  def data_size(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def decode64(str); end

  sig {returns(::T.untyped)}
  def deflag(); end

  sig {returns(::T.untyped)}
  def dump_flags(); end

  sig {returns(::T.untyped)}
  def encode64(); end

  sig do
    params(
      flag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def has_flag?(flag); end

  sig {returns(::T.untyped)}
  def head_size(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str); end

  sig {returns(::T.untyped)}
  def security_buffers(); end

  sig {returns(::T.untyped)}
  def serialize(); end

  sig do
    params(
      flag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_flag(flag); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.decode64(str); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(str); end
end

class Net::NTLM::Message::Type0 < Net::NTLM::Message
  sig {returns(::T.untyped)}
  def sign(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign=(val); end

  sig {returns(::T.untyped)}
  def type(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(val); end
end

class Net::NTLM::Message::Type1 < Net::NTLM::Message
  sig {returns(::T.untyped)}
  def domain(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def domain=(val); end

  sig {returns(::T.untyped)}
  def flag(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flag=(val); end

  sig {returns(::T.untyped)}
  def os_version(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def os_version=(val); end

  sig {returns(::T.untyped)}
  def sign(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign=(val); end

  sig {returns(::T.untyped)}
  def type(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(val); end

  sig {returns(::T.untyped)}
  def workstation(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def workstation=(val); end
end

class Net::NTLM::Message::Type2 < Net::NTLM::Message
  sig {returns(::T.untyped)}
  def challenge(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def challenge=(val); end

  sig {returns(::T.untyped)}
  def context(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def context=(val); end

  sig {returns(::T.untyped)}
  def flag(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flag=(val); end

  sig {returns(::T.untyped)}
  def os_version(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def os_version=(val); end

  sig do
    params(
      arg: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def response(arg, opt=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def sign(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign=(val); end

  sig {returns(::T.untyped)}
  def target_info(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def target_info=(val); end

  sig {returns(::T.untyped)}
  def target_name(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def target_name=(val); end

  sig {returns(::T.untyped)}
  def type(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(val); end
end

class Net::NTLM::Message::Type3 < Net::NTLM::Message
  sig do
    params(
      server_challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def blank_password?(server_challenge); end

  sig {returns(::T.untyped)}
  def domain(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def domain=(val); end

  sig {returns(::T.untyped)}
  def flag(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flag=(val); end

  sig {returns(::T.untyped)}
  def lm_response(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lm_response=(val); end

  sig {returns(::T.untyped)}
  def ntlm_response(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ntlm_response=(val); end

  sig {returns(::T.untyped)}
  def ntlm_version(); end

  sig {returns(::T.untyped)}
  def os_version(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def os_version=(val); end

  sig do
    params(
      password: ::T.untyped,
      server_challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def password?(password, server_challenge); end

  sig {returns(::T.untyped)}
  def session_key(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def session_key=(val); end

  sig {returns(::T.untyped)}
  def sign(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign=(val); end

  sig {returns(::T.untyped)}
  def type(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(val); end

  sig {returns(::T.untyped)}
  def user(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def user=(val); end

  sig {returns(::T.untyped)}
  def workstation(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def workstation=(val); end

  sig do
    params(
      arg: ::T.untyped,
      opt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.create(arg, opt=T.unsafe(nil)); end
end

class Net::NTLM::NtlmError < StandardError
end

class Net::NTLM::SecurityBuffer < Net::NTLM::FieldSet
  sig {returns(::T.untyped)}
  def active(); end

  sig do
    params(
      active: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def active=(active); end

  sig {returns(::T.untyped)}
  def allocated(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def allocated=(val); end

  sig {returns(::T.untyped)}
  def data_size(); end

  sig do
    params(
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opts=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def length(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def length=(val); end

  sig {returns(::T.untyped)}
  def offset(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def offset=(val); end

  sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def serialize(); end

  sig {returns(::T.untyped)}
  def value(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(val); end
end

class Net::NTLM::String < Net::NTLM::Field
  sig do
    params(
      opts: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(opts); end

  sig do
    params(
      str: ::T.untyped,
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str, offset=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def serialize(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(val); end
end

class Net::NTLM::TargetInfo
  MSV_AV_CHANNEL_BINDINGS = ::T.let(nil, ::T.untyped)
  MSV_AV_DNS_COMPUTER_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_DNS_DOMAIN_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_DNS_TREE_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_EOL = ::T.let(nil, ::T.untyped)
  MSV_AV_FLAGS = ::T.let(nil, ::T.untyped)
  MSV_AV_NB_COMPUTER_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_NB_DOMAIN_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_SINGLE_HOST = ::T.let(nil, ::T.untyped)
  MSV_AV_TARGET_NAME = ::T.let(nil, ::T.untyped)
  MSV_AV_TIMESTAMP = ::T.let(nil, ::T.untyped)
  VALID_PAIR_ID = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def av_pairs(); end

  sig do
    params(
      av_pair_sequence: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(av_pair_sequence); end

  sig {returns(::T.untyped)}
  def to_s(); end
end

module Net::NetPrivate
end

# [`OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html), a
# subclass of
# [`Timeout::Error`](https://docs.ruby-lang.org/en/2.6.0/Timeout/Error.html), is
# raised if a connection cannot be created within the open\_timeout.
class Net::OpenTimeout < Timeout::Error
end

class Net::ProtoAuthError < Net::ProtocolError
end

class Net::ProtoCommandError < Net::ProtocolError
end

class Net::ProtoFatalError < Net::ProtocolError
end

class Net::ProtoRetriableError < Net::ProtocolError
end

class Net::ProtoServerError < Net::ProtocolError
end

class Net::ProtoSyntaxError < Net::ProtocolError
end

class Net::ProtoUnknownError < Net::ProtocolError
end

class Net::Protocol
  sig do
    params(
      name: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.protocol_param(name, val); end
end

class Net::ProtocolError < StandardError
end

class Net::ReadAdapter
  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(str); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(block); end

  sig {returns(::T.untyped)}
  def inspect(); end
end

# [`ReadTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/ReadTimeout.html), a
# subclass of
# [`Timeout::Error`](https://docs.ruby-lang.org/en/2.6.0/Timeout/Error.html), is
# raised if a chunk of the response cannot be read within the read\_timeout.
class Net::ReadTimeout < Timeout::Error
end

module Net::SFTP
  sig do
    params(
      host: ::T.untyped,
      user: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(host, user, options=T.unsafe(nil), &block); end
end

module Net::SFTP::Constants
end

module Net::SFTP::Constants::ACE
end

module Net::SFTP::Constants::ACE::Flag
  DIRECTORY_INHERIT = ::T.let(nil, ::T.untyped)
  FAILED_ACCESS = ::T.let(nil, ::T.untyped)
  FILE_INHERIT = ::T.let(nil, ::T.untyped)
  IDENTIFIER_GROUP = ::T.let(nil, ::T.untyped)
  INHERIT_ONLY = ::T.let(nil, ::T.untyped)
  NO_PROPAGATE_INHERIT = ::T.let(nil, ::T.untyped)
  SUCCESSFUL_ACCESS = ::T.let(nil, ::T.untyped)
end

module Net::SFTP::Constants::ACE::Mask
  ADD_FILE = ::T.let(nil, ::T.untyped)
  ADD_SUBDIRECTORY = ::T.let(nil, ::T.untyped)
  APPEND_DATA = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  DELETE_CHILD = ::T.let(nil, ::T.untyped)
  EXECUTE = ::T.let(nil, ::T.untyped)
  LIST_DIRECTORY = ::T.let(nil, ::T.untyped)
  READ_ACL = ::T.let(nil, ::T.untyped)
  READ_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  READ_DATA = ::T.let(nil, ::T.untyped)
  READ_NAMED_ATTRS = ::T.let(nil, ::T.untyped)
  SYNCHRONIZE = ::T.let(nil, ::T.untyped)
  WRITE_ACL = ::T.let(nil, ::T.untyped)
  WRITE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  WRITE_DATA = ::T.let(nil, ::T.untyped)
  WRITE_NAMED_ATTRS = ::T.let(nil, ::T.untyped)
  WRITE_OWNER = ::T.let(nil, ::T.untyped)
end

module Net::SFTP::Constants::ACE::Type
  ACCESS_ALLOWED = ::T.let(nil, ::T.untyped)
  ACCESS_DENIED = ::T.let(nil, ::T.untyped)
  SYSTEM_ALARM = ::T.let(nil, ::T.untyped)
  SYSTEM_AUDIT = ::T.let(nil, ::T.untyped)
end

module Net::SFTP::Constants::LockTypes
  ADVISORY = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  READ = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)
end

module Net::SFTP::Constants::OpenFlags
end

module Net::SFTP::Constants::OpenFlags::FV1
  APPEND = ::T.let(nil, ::T.untyped)
  CREAT = ::T.let(nil, ::T.untyped)
  EXCL = ::T.let(nil, ::T.untyped)
  READ = ::T.let(nil, ::T.untyped)
  TRUNC = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)
end

module Net::SFTP::Constants::OpenFlags::FV5
  APPEND_DATA = ::T.let(nil, ::T.untyped)
  APPEND_DATA_ATOMIC = ::T.let(nil, ::T.untyped)
  CREATE_NEW = ::T.let(nil, ::T.untyped)
  CREATE_TRUNCATE = ::T.let(nil, ::T.untyped)
  DELETE_LOCK = ::T.let(nil, ::T.untyped)
  OPEN_EXISTING = ::T.let(nil, ::T.untyped)
  OPEN_OR_CREATE = ::T.let(nil, ::T.untyped)
  READ_LOCK = ::T.let(nil, ::T.untyped)
  TEXT_MODE = ::T.let(nil, ::T.untyped)
  TRUNCATE_EXISTING = ::T.let(nil, ::T.untyped)
  WRITE_LOCK = ::T.let(nil, ::T.untyped)
end

module Net::SFTP::Constants::OpenFlags::FV6
  ACCESS_AUDIT_ALARM_INFO = ::T.let(nil, ::T.untyped)
  ACCESS_BACKUP = ::T.let(nil, ::T.untyped)
  ADVISORY_LOCK = ::T.let(nil, ::T.untyped)
  BACKUP_STREAM = ::T.let(nil, ::T.untyped)
  DELETE_ON_CLOSE = ::T.let(nil, ::T.untyped)
  NOFOLLOW = ::T.let(nil, ::T.untyped)
  OVERRIDE_OWNER = ::T.let(nil, ::T.untyped)
end

module Net::SFTP::Constants::PacketTypes
  FXP_ATTRS = ::T.let(nil, ::T.untyped)
  FXP_BLOCK = ::T.let(nil, ::T.untyped)
  FXP_CLOSE = ::T.let(nil, ::T.untyped)
  FXP_DATA = ::T.let(nil, ::T.untyped)
  FXP_EXTENDED = ::T.let(nil, ::T.untyped)
  FXP_EXTENDED_REPLY = ::T.let(nil, ::T.untyped)
  FXP_FSETSTAT = ::T.let(nil, ::T.untyped)
  FXP_FSTAT = ::T.let(nil, ::T.untyped)
  FXP_HANDLE = ::T.let(nil, ::T.untyped)
  FXP_INIT = ::T.let(nil, ::T.untyped)
  FXP_LINK = ::T.let(nil, ::T.untyped)
  FXP_LSTAT = ::T.let(nil, ::T.untyped)
  FXP_MKDIR = ::T.let(nil, ::T.untyped)
  FXP_NAME = ::T.let(nil, ::T.untyped)
  FXP_OPEN = ::T.let(nil, ::T.untyped)
  FXP_OPENDIR = ::T.let(nil, ::T.untyped)
  FXP_READ = ::T.let(nil, ::T.untyped)
  FXP_READDIR = ::T.let(nil, ::T.untyped)
  FXP_READLINK = ::T.let(nil, ::T.untyped)
  FXP_REALPATH = ::T.let(nil, ::T.untyped)
  FXP_REMOVE = ::T.let(nil, ::T.untyped)
  FXP_RENAME = ::T.let(nil, ::T.untyped)
  FXP_RMDIR = ::T.let(nil, ::T.untyped)
  FXP_SETSTAT = ::T.let(nil, ::T.untyped)
  FXP_STAT = ::T.let(nil, ::T.untyped)
  FXP_STATUS = ::T.let(nil, ::T.untyped)
  FXP_SYMLINK = ::T.let(nil, ::T.untyped)
  FXP_UNBLOCK = ::T.let(nil, ::T.untyped)
  FXP_VERSION = ::T.let(nil, ::T.untyped)
  FXP_WRITE = ::T.let(nil, ::T.untyped)
end

module Net::SFTP::Constants::RenameFlags
  ATOMIC = ::T.let(nil, ::T.untyped)
  NATIVE = ::T.let(nil, ::T.untyped)
  OVERWRITE = ::T.let(nil, ::T.untyped)
end

module Net::SFTP::Constants::StatusCodes
  FX_BAD_MESSAGE = ::T.let(nil, ::T.untyped)
  FX_CONNECTION_LOST = ::T.let(nil, ::T.untyped)
  FX_DIR_NOT_EMPTY = ::T.let(nil, ::T.untyped)
  FX_EOF = ::T.let(nil, ::T.untyped)
  FX_FAILURE = ::T.let(nil, ::T.untyped)
  FX_FILE_ALREADY_EXISTS = ::T.let(nil, ::T.untyped)
  FX_INVALID_FILENAME = ::T.let(nil, ::T.untyped)
  FX_INVALID_HANDLE = ::T.let(nil, ::T.untyped)
  FX_LINK_LOOP = ::T.let(nil, ::T.untyped)
  FX_LOCK_CONFlICT = ::T.let(nil, ::T.untyped)
  FX_NOT_A_DIRECTORY = ::T.let(nil, ::T.untyped)
  FX_NO_CONNECTION = ::T.let(nil, ::T.untyped)
  FX_NO_MEDIA = ::T.let(nil, ::T.untyped)
  FX_NO_SPACE_ON_FILESYSTEM = ::T.let(nil, ::T.untyped)
  FX_NO_SUCH_FILE = ::T.let(nil, ::T.untyped)
  FX_NO_SUCH_PATH = ::T.let(nil, ::T.untyped)
  FX_OK = ::T.let(nil, ::T.untyped)
  FX_OP_UNSUPPORTED = ::T.let(nil, ::T.untyped)
  FX_PERMISSION_DENIED = ::T.let(nil, ::T.untyped)
  FX_QUOTA_EXCEEDED = ::T.let(nil, ::T.untyped)
  FX_UNKNOWN_PRINCIPLE = ::T.let(nil, ::T.untyped)
  FX_WRITE_PROTECT = ::T.let(nil, ::T.untyped)
end

class Net::SFTP::Exception < RuntimeError
end

module Net::SFTP::Operations
end

class Net::SFTP::Operations::Dir
  sig do
    params(
      path: ::T.untyped,
      pattern: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](path, pattern); end

  sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def entries(path); end

  sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def foreach(path); end

  sig do
    params(
      path: ::T.untyped,
      pattern: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def glob(path, pattern, flags=T.unsafe(nil)); end

  sig do
    params(
      sftp: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sftp); end

  sig {returns(::T.untyped)}
  def sftp(); end
end

class Net::SFTP::Operations::Download
  include ::Net::SSH::Loggable
  DEFAULT_READ_SIZE = ::T.let(nil, ::T.untyped)

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](name); end

  sig do
    params(
      name: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(name, value); end

  sig {returns(::T.untyped)}
  def abort!(); end

  sig {returns(::T.untyped)}
  def active?(); end

  sig do
    params(
      sftp: ::T.untyped,
      local: ::T.untyped,
      remote: ::T.untyped,
      options: ::T.untyped,
      progress: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sftp, local, remote, options=T.unsafe(nil), &progress); end

  sig {returns(::T.untyped)}
  def local(); end

  sig {returns(::T.untyped)}
  def options(); end

  sig {returns(::T.untyped)}
  def properties(); end

  sig {returns(::T.untyped)}
  def recursive?(); end

  sig {returns(::T.untyped)}
  def remote(); end

  sig {returns(::T.untyped)}
  def sftp(); end

  sig {returns(::T.untyped)}
  def wait(); end
end

class Net::SFTP::Operations::Download::Entry < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def directory(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def directory=(_); end

  sig {returns(::T.untyped)}
  def handle(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def handle=(_); end

  sig {returns(::T.untyped)}
  def local(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local=(_); end

  sig {returns(::T.untyped)}
  def offset(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def offset=(_); end

  sig {returns(::T.untyped)}
  def remote(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote=(_); end

  sig {returns(::T.untyped)}
  def sink(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sink=(_); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::SFTP::Operations::File
  sig {returns(::T.untyped)}
  def close(); end

  sig {returns(::T.untyped)}
  def eof?(); end

  sig do
    params(
      sep_string: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def gets(sep_string=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def handle(); end

  sig do
    params(
      sftp: ::T.untyped,
      handle: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sftp, handle); end

  sig {returns(::T.untyped)}
  def pos(); end

  sig do
    params(
      offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pos=(offset); end

  sig do
    params(
      items: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def print(*items); end

  sig do
    params(
      items: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def puts(*items); end

  sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(n=T.unsafe(nil)); end

  sig do
    params(
      sep_string: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readline(sep_string=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def sftp(); end

  sig {returns(::T.untyped)}
  def stat(); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(data); end
end

class Net::SFTP::Operations::FileFactory
  sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def directory?(path); end

  sig do
    params(
      sftp: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sftp); end

  sig do
    params(
      name: ::T.untyped,
      flags: ::T.untyped,
      mode: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open(name, flags=T.unsafe(nil), mode=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def sftp(); end
end

class Net::SFTP::Operations::Upload
  include ::Net::SSH::Loggable
  DEFAULT_READ_SIZE = ::T.let(nil, ::T.untyped)
  RECURSIVE_READERS = ::T.let(nil, ::T.untyped)
  SINGLE_FILE_READERS = ::T.let(nil, ::T.untyped)

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](name); end

  sig do
    params(
      name: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(name, value); end

  sig {returns(::T.untyped)}
  def abort!(); end

  sig {returns(::T.untyped)}
  def active?(); end

  sig do
    params(
      sftp: ::T.untyped,
      local: ::T.untyped,
      remote: ::T.untyped,
      options: ::T.untyped,
      progress: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sftp, local, remote, options=T.unsafe(nil), &progress); end

  sig {returns(::T.untyped)}
  def local(); end

  sig {returns(::T.untyped)}
  def options(); end

  sig {returns(::T.untyped)}
  def properties(); end

  sig {returns(::T.untyped)}
  def recursive?(); end

  sig {returns(::T.untyped)}
  def remote(); end

  sig {returns(::T.untyped)}
  def sftp(); end

  sig {returns(::T.untyped)}
  def wait(); end
end

class Net::SFTP::Operations::Upload::LiveFile < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def handle(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def handle=(_); end

  sig {returns(::T.untyped)}
  def io(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def io=(_); end

  sig {returns(::T.untyped)}
  def local(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local=(_); end

  sig {returns(::T.untyped)}
  def remote(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote=(_); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::SFTP::Packet < Net::SSH::Buffer
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig {returns(::T.untyped)}
  def type(); end
end

module Net::SFTP::Protocol
  sig do
    params(
      session: ::T.untyped,
      version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load(session, version); end
end

class Net::SFTP::Protocol::Base
  include ::Net::SFTP::Constants::PacketTypes
  include ::Net::SFTP::Constants
  include ::Net::SSH::Loggable
  sig do
    params(
      session: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(packet); end

  sig {returns(::T.untyped)}
  def session(); end
end

module Net::SFTP::Protocol::V01
end

class Net::SFTP::Protocol::V01::Attributes
  F_ACMODTIME = ::T.let(nil, ::T.untyped)
  F_EXTENDED = ::T.let(nil, ::T.untyped)
  F_PERMISSIONS = ::T.let(nil, ::T.untyped)
  F_SIZE = ::T.let(nil, ::T.untyped)
  F_UIDGID = ::T.let(nil, ::T.untyped)
  T_BLOCK_DEVICE = ::T.let(nil, ::T.untyped)
  T_CHAR_DEVICE = ::T.let(nil, ::T.untyped)
  T_DIRECTORY = ::T.let(nil, ::T.untyped)
  T_FIFO = ::T.let(nil, ::T.untyped)
  T_REGULAR = ::T.let(nil, ::T.untyped)
  T_SOCKET = ::T.let(nil, ::T.untyped)
  T_SPECIAL = ::T.let(nil, ::T.untyped)
  T_SYMLINK = ::T.let(nil, ::T.untyped)
  T_UNKNOWN = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def atime(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def atime=(value); end

  sig {returns(::T.untyped)}
  def attributes(); end

  sig {returns(::T.untyped)}
  def directory?(); end

  sig {returns(::T.untyped)}
  def extended(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extended=(value); end

  sig {returns(::T.untyped)}
  def file?(); end

  sig {returns(::T.untyped)}
  def gid(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def gid=(value); end

  sig {returns(::T.untyped)}
  def group(); end

  sig do
    params(
      attributes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(attributes=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def mtime(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mtime=(value); end

  sig {returns(::T.untyped)}
  def owner(); end

  sig {returns(::T.untyped)}
  def permissions(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def permissions=(value); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(value); end

  sig {returns(::T.untyped)}
  def symbolic_type(); end

  sig {returns(::T.untyped)}
  def symlink?(); end

  sig {returns(::T.untyped)}
  def to_s(); end

  sig {returns(::T.untyped)}
  def type(); end

  sig {returns(::T.untyped)}
  def uid(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid=(value); end

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.attr_accessor(name); end

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.attr_writer(name); end

  sig {returns(::T.untyped)}
  def self.elements(); end

  sig do
    params(
      buffer: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.from_buffer(buffer); end
end

class Net::SFTP::Protocol::V01::Base < Net::SFTP::Protocol::Base
  include ::Net::SFTP::Constants::OpenFlags
  sig {returns(::T.untyped)}
  def attribute_factory(); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      mask: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def block(handle, offset, length, mask); end

  sig do
    params(
      handle: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def close(handle); end

  sig do
    params(
      handle: ::T.untyped,
      attrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fsetstat(handle, attrs); end

  sig do
    params(
      handle: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fstat(handle, flags=T.unsafe(nil)); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def link(*args); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lstat(path, flags=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkdir(path, attrs); end

  sig {returns(::T.untyped)}
  def name_factory(); end

  sig do
    params(
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def normalize_open_flags(flags); end

  sig do
    params(
      operation: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def not_implemented!(operation); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open(path, flags, options); end

  sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def opendir(path); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_attrs_packet(packet); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_data_packet(packet); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_handle_packet(packet); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_name_packet(packet); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_status_packet(packet); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(handle, offset, length); end

  sig do
    params(
      handle: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readdir(handle); end

  sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readlink(path); end

  sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def realpath(path); end

  sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove(filename); end

  sig do
    params(
      name: ::T.untyped,
      new_name: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(name, new_name, flags=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rmdir(path); end

  sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setstat(path, attrs); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def stat(path, flags=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      target: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symlink(path, target); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unblock(handle, offset, length); end

  sig {returns(::T.untyped)}
  def version(); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(handle, offset, data); end
end

class Net::SFTP::Protocol::V01::Name
  sig {returns(::T.untyped)}
  def attributes(); end

  sig {returns(::T.untyped)}
  def directory?(); end

  sig {returns(::T.untyped)}
  def file?(); end

  sig do
    params(
      name: ::T.untyped,
      longname: ::T.untyped,
      attributes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(name, longname, attributes); end

  sig {returns(::T.untyped)}
  def longname(); end

  sig {returns(::T.untyped)}
  def name(); end

  sig {returns(::T.untyped)}
  def symlink?(); end
end

module Net::SFTP::Protocol::V02
end

class Net::SFTP::Protocol::V02::Base < Net::SFTP::Protocol::V01::Base
  sig do
    params(
      name: ::T.untyped,
      new_name: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(name, new_name, flags=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def version(); end
end

module Net::SFTP::Protocol::V03
end

class Net::SFTP::Protocol::V03::Base < Net::SFTP::Protocol::V02::Base
  sig do
    params(
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readlink(path); end

  sig do
    params(
      path: ::T.untyped,
      target: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symlink(path, target); end

  sig {returns(::T.untyped)}
  def version(); end
end

module Net::SFTP::Protocol::V04
end

class Net::SFTP::Protocol::V04::Attributes < Net::SFTP::Protocol::V01::Attributes
  F_ACCESSTIME = ::T.let(nil, ::T.untyped)
  F_ACL = ::T.let(nil, ::T.untyped)
  F_CREATETIME = ::T.let(nil, ::T.untyped)
  F_MODIFYTIME = ::T.let(nil, ::T.untyped)
  F_OWNERGROUP = ::T.let(nil, ::T.untyped)
  F_SUBSECOND_TIMES = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def acl(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def acl=(value); end

  sig {returns(::T.untyped)}
  def atime_nseconds(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def atime_nseconds=(value); end

  sig {returns(::T.untyped)}
  def createtime(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def createtime=(value); end

  sig {returns(::T.untyped)}
  def createtime_nseconds(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def createtime_nseconds=(value); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def group=(value); end

  sig do
    params(
      attributes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(attributes=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def mtime_nseconds(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mtime_nseconds=(value); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def owner=(value); end

  sig {returns(::T.untyped)}
  def type(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(value); end

  sig {returns(::T.untyped)}
  def self.elements(); end
end

class Net::SFTP::Protocol::V04::Attributes::ACL < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def flag(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def flag=(_); end

  sig {returns(::T.untyped)}
  def mask(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mask=(_); end

  sig {returns(::T.untyped)}
  def type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(_); end

  sig {returns(::T.untyped)}
  def who(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def who=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::SFTP::Protocol::V04::Base < Net::SFTP::Protocol::V03::Base
  DEFAULT_FLAGS = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def attribute_factory(); end

  sig do
    params(
      handle: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fstat(handle, flags=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lstat(path, flags=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def name_factory(); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_name_packet(packet); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def stat(path, flags=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def version(); end
end

class Net::SFTP::Protocol::V04::Name
  sig {returns(::T.untyped)}
  def attributes(); end

  sig {returns(::T.untyped)}
  def directory?(); end

  sig {returns(::T.untyped)}
  def file?(); end

  sig do
    params(
      name: ::T.untyped,
      attributes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(name, attributes); end

  sig {returns(::T.untyped)}
  def longname(); end

  sig {returns(::T.untyped)}
  def name(); end

  sig {returns(::T.untyped)}
  def symlink?(); end
end

module Net::SFTP::Protocol::V05
end

class Net::SFTP::Protocol::V05::Base < Net::SFTP::Protocol::V04::Base
  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open(path, flags, options); end

  sig do
    params(
      name: ::T.untyped,
      new_name: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(name, new_name, flags=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def version(); end
end

module Net::SFTP::Protocol::V06
end

class Net::SFTP::Protocol::V06::Attributes < Net::SFTP::Protocol::V04::Attributes
  F_ALLOCATION_SIZE = ::T.let(nil, ::T.untyped)
  F_BITS = ::T.let(nil, ::T.untyped)
  F_CTIME = ::T.let(nil, ::T.untyped)
  F_LINK_COUNT = ::T.let(nil, ::T.untyped)
  F_MIME_TYPE = ::T.let(nil, ::T.untyped)
  F_TEXT_HINT = ::T.let(nil, ::T.untyped)
  F_UNTRANSLATED_NAME = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def allocation_size(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def allocation_size=(value); end

  sig {returns(::T.untyped)}
  def attrib_bits(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attrib_bits=(value); end

  sig {returns(::T.untyped)}
  def attrib_bits_valid(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attrib_bits_valid=(value); end

  sig {returns(::T.untyped)}
  def ctime(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ctime=(value); end

  sig {returns(::T.untyped)}
  def ctime_nseconds(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ctime_nseconds=(value); end

  sig {returns(::T.untyped)}
  def link_count(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def link_count=(value); end

  sig {returns(::T.untyped)}
  def mime_type(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mime_type=(value); end

  sig {returns(::T.untyped)}
  def text_hint(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def text_hint=(value); end

  sig {returns(::T.untyped)}
  def untranslated_name(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def untranslated_name=(value); end

  sig {returns(::T.untyped)}
  def self.elements(); end
end

class Net::SFTP::Protocol::V06::Base < Net::SFTP::Protocol::V05::Base
  sig {returns(::T.untyped)}
  def attribute_factory(); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      mask: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def block(handle, offset, length, mask); end

  sig do
    params(
      new_link_path: ::T.untyped,
      existing_path: ::T.untyped,
      symlink: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def link(new_link_path, existing_path, symlink); end

  sig do
    params(
      path: ::T.untyped,
      target: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symlink(path, target); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unblock(handle, offset, length); end

  sig {returns(::T.untyped)}
  def version(); end
end

class Net::SFTP::Request
  include ::Net::SFTP::Constants::PacketTypes
  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  sig do
    params(
      key: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(key, value); end

  sig {returns(::T.untyped)}
  def callback(); end

  sig {returns(::T.untyped)}
  def id(); end

  sig do
    params(
      session: ::T.untyped,
      type: ::T.untyped,
      id: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session, type, id, &callback); end

  sig {returns(::T.untyped)}
  def pending?(); end

  sig {returns(::T.untyped)}
  def properties(); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def respond_to(packet); end

  sig {returns(::T.untyped)}
  def response(); end

  sig {returns(::T.untyped)}
  def session(); end

  sig {returns(::T.untyped)}
  def type(); end

  sig {returns(::T.untyped)}
  def wait(); end
end

class Net::SFTP::Response
  include ::Net::SFTP::Constants::StatusCodes
  MAP = ::T.let(nil, ::T.untyped)

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  sig {returns(::T.untyped)}
  def code(); end

  sig {returns(::T.untyped)}
  def data(); end

  sig {returns(::T.untyped)}
  def eof?(); end

  sig do
    params(
      request: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(request, data=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def message(); end

  sig {returns(::T.untyped)}
  def ok?(); end

  sig {returns(::T.untyped)}
  def request(); end

  sig {returns(::T.untyped)}
  def to_s(); end

  sig {returns(::T.untyped)}
  def to_str(); end
end

class Net::SFTP::Session
  include ::Net::SFTP::Constants::PacketTypes
  include ::Net::SSH::Loggable
  HIGHEST_PROTOCOL_VERSION_SUPPORTED = ::T.let(nil, ::T.untyped)

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      mask: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def block(handle, offset, length, mask, &callback); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      mask: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def block!(handle, offset, length, mask, &callback); end

  sig {returns(::T.untyped)}
  def channel(); end

  sig do
    params(
      handle: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def close(handle, &callback); end

  sig do
    params(
      handle: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def close!(handle, &callback); end

  sig {returns(::T.untyped)}
  def close_channel(); end

  sig {returns(::T.untyped)}
  def closed?(); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connect(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connect!(&block); end

  sig {returns(::T.untyped)}
  def dir(); end

  sig do
    params(
      remote: ::T.untyped,
      local: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def download(remote, local, options=T.unsafe(nil), &block); end

  sig do
    params(
      remote: ::T.untyped,
      local: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def download!(remote, local=T.unsafe(nil), options=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def file(); end

  sig do
    params(
      handle: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fsetstat(handle, attrs, &callback); end

  sig do
    params(
      handle: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fsetstat!(handle, attrs, &callback); end

  sig do
    params(
      handle: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fstat(handle, flags=T.unsafe(nil), &callback); end

  sig do
    params(
      handle: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fstat!(handle, flags=T.unsafe(nil), &callback); end

  sig do
    params(
      session: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session, &block); end

  sig do
    params(
      new_link_path: ::T.untyped,
      existing_path: ::T.untyped,
      symlink: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def link(new_link_path, existing_path, symlink=T.unsafe(nil), &callback); end

  sig do
    params(
      new_link_path: ::T.untyped,
      existing_path: ::T.untyped,
      symlink: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def link!(new_link_path, existing_path, symlink=T.unsafe(nil), &callback); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def loop(&block); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lstat(path, flags=T.unsafe(nil), &callback); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lstat!(path, flags=T.unsafe(nil), &callback); end

  sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkdir(path, attrs=T.unsafe(nil), &callback); end

  sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkdir!(path, attrs=T.unsafe(nil), &callback); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      options: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open(path, flags=T.unsafe(nil), options=T.unsafe(nil), &callback); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      options: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open!(path, flags=T.unsafe(nil), options=T.unsafe(nil), &callback); end

  sig {returns(::T.untyped)}
  def open?(); end

  sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def opendir(path, &callback); end

  sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def opendir!(path, &callback); end

  sig {returns(::T.untyped)}
  def opening?(); end

  sig {returns(::T.untyped)}
  def pending_requests(); end

  sig {returns(::T.untyped)}
  def protocol(); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(handle, offset, length, &callback); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read!(handle, offset, length, &callback); end

  sig do
    params(
      handle: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readdir(handle, &callback); end

  sig do
    params(
      handle: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readdir!(handle, &callback); end

  sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readlink(path, &callback); end

  sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readlink!(path, &callback); end

  sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def realpath(path, &callback); end

  sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def realpath!(path, &callback); end

  sig do
    params(
      filename: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove(filename, &callback); end

  sig do
    params(
      filename: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove!(filename, &callback); end

  sig do
    params(
      name: ::T.untyped,
      new_name: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(name, new_name, flags=T.unsafe(nil), &callback); end

  sig do
    params(
      name: ::T.untyped,
      new_name: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename!(name, new_name, flags=T.unsafe(nil), &callback); end

  sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rmdir(path, &callback); end

  sig do
    params(
      path: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rmdir!(path, &callback); end

  sig do
    params(
      type: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_packet(type, *args); end

  sig {returns(::T.untyped)}
  def session(); end

  sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setstat(path, attrs, &callback); end

  sig do
    params(
      path: ::T.untyped,
      attrs: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setstat!(path, attrs, &callback); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def stat(path, flags=T.unsafe(nil), &callback); end

  sig do
    params(
      path: ::T.untyped,
      flags: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def stat!(path, flags=T.unsafe(nil), &callback); end

  sig {returns(::T.untyped)}
  def state(); end

  sig do
    params(
      path: ::T.untyped,
      target: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symlink(path, target, &callback); end

  sig do
    params(
      path: ::T.untyped,
      target: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symlink!(path, target, &callback); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unblock(handle, offset, length, &callback); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      length: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unblock!(handle, offset, length, &callback); end

  sig do
    params(
      local: ::T.untyped,
      remote: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def upload(local, remote=T.unsafe(nil), options=T.unsafe(nil), &block); end

  sig do
    params(
      local: ::T.untyped,
      remote: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def upload!(local, remote=T.unsafe(nil), options=T.unsafe(nil), &block); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      data: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(handle, offset, data, &callback); end

  sig do
    params(
      handle: ::T.untyped,
      offset: ::T.untyped,
      data: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write!(handle, offset, data, &callback); end
end

class Net::SFTP::StatusException < Net::SFTP::Exception
  sig {returns(::T.untyped)}
  def code(); end

  sig {returns(::T.untyped)}
  def description(); end

  sig do
    params(
      response: ::T.untyped,
      text: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(response, text=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def message(); end

  sig {returns(::T.untyped)}
  def response(); end

  sig {returns(::T.untyped)}
  def text(); end
end

# ## What is This Library?
#
# This library provides functionality to send internet mail via
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html), the Simple Mail
# Transfer Protocol. For details of
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) itself, see
# [RFC2821] (http://www.ietf.org/rfc/rfc2821.txt).
#
# ## What is This Library NOT?
#
# This library does NOT provide functions to compose internet mails. You must
# create them by yourself. If you want better mail support, try RubyMail or
# TMail or search for alternatives in [RubyGems.org](https://rubygems.org/) or
# [The Ruby Toolbox](https://www.ruby-toolbox.com/).
#
# FYI: the official documentation on internet mail is: [RFC2822]
# (http://www.ietf.org/rfc/rfc2822.txt).
#
# ## Examples
#
# ### Sending Messages
#
# You must open a connection to an
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) server before
# sending messages. The first argument is the address of your
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) server, and the
# second argument is the port number. Using
# [`SMTP.start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-c-start)
# with a block is the simplest way to do this. This way, the
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) connection is
# closed automatically after the block is executed.
#
# ```ruby
# require 'net/smtp'
# Net::SMTP.start('your.smtp.server', 25) do |smtp|
#   # Use the SMTP object smtp only in this block.
# end
# ```
#
# Replace 'your.smtp.server' with your
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) server. Normally
# your system manager or internet provider supplies a server for you.
#
# Then you can send messages.
#
# ```ruby
# msgstr = <<END_OF_MESSAGE
# From: Your Name <your@mail.address>
# To: Destination Address <someone@example.com>
# Subject: test message
# Date: Sat, 23 Jun 2001 16:26:43 +0900
# Message-Id: <unique.message.id.string@example.com>
#
# This is a test message.
# END_OF_MESSAGE
#
# require 'net/smtp'
# Net::SMTP.start('your.smtp.server', 25) do |smtp|
#   smtp.send_message msgstr,
#                     'your@mail.address',
#                     'his_address@example.com'
# end
# ```
#
# ### Closing the Session
#
# You MUST close the [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html)
# session after sending messages, by calling the
# [`finish`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-finish)
# method:
#
# ```ruby
# # using SMTP#finish
# smtp = Net::SMTP.start('your.smtp.server', 25)
# smtp.send_message msgstr, 'from@address', 'to@address'
# smtp.finish
# ```
#
# You can also use the block form of
# [`SMTP.start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-c-start)/SMTP#start.
# This closes the [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html)
# session automatically:
#
# ```ruby
# # using block form of SMTP.start
# Net::SMTP.start('your.smtp.server', 25) do |smtp|
#   smtp.send_message msgstr, 'from@address', 'to@address'
# end
# ```
#
# I strongly recommend this scheme. This form is simpler and more robust.
#
# ### HELO domain
#
# In almost all situations, you must provide a third argument to
# [`SMTP.start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-c-start)/SMTP#start.
# This is the domain name which you are on (the host to send mail from). It is
# called the "HELO domain". The
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) server will judge
# whether it should send or reject the
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) session by
# inspecting the HELO domain.
#
# ```
# Net::SMTP.start('your.smtp.server', 25,
#                 'mail.from.domain') { |smtp| ... }
# ```
#
# ### [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) Authentication
#
# The [`Net::SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) class
# supports three authentication schemes; PLAIN, LOGIN and CRAM MD5. (SMTP
# Authentication: [RFC2554]) To use
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) authentication,
# pass extra arguments to
# [`SMTP.start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-c-start)/SMTP#start.
#
# ```ruby
# # PLAIN
# Net::SMTP.start('your.smtp.server', 25, 'mail.from.domain',
#                 'Your Account', 'Your Password', :plain)
# # LOGIN
# Net::SMTP.start('your.smtp.server', 25, 'mail.from.domain',
#                 'Your Account', 'Your Password', :login)
#
# # CRAM MD5
# Net::SMTP.start('your.smtp.server', 25, 'mail.from.domain',
#                 'Your Account', 'Your Password', :cram_md5)
# ```
class Net::SMTP < Net::Protocol
  CRAM_BUFSIZE = ::T.let(nil, ::T.untyped)
  # Authentication
  DEFAULT_AUTH_TYPE = ::T.let(nil, ::T.untyped)
  IMASK = ::T.let(nil, ::T.untyped)
  OMASK = ::T.let(nil, ::T.untyped)
  Revision = ::T.let(nil, ::T.untyped)

  # The address of the
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) server to
  # connect to.
  sig {returns(::T.untyped)}
  def address(); end

  sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_cram_md5(user, secret); end

  sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_login(user, secret); end

  sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_plain(user, secret); end

  sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
      authtype: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(user, secret, authtype=T.unsafe(nil)); end

  # Returns supported authentication methods on this server. You cannot get
  # valid value before opening
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) session.
  sig {returns(::T.untyped)}
  def capable_auth_types(); end

  # true if server advertises AUTH CRAM-MD5. You cannot get valid value before
  # opening [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) session.
  sig {returns(::T.untyped)}
  def capable_cram_md5_auth?(); end

  # true if server advertises AUTH LOGIN. You cannot get valid value before
  # opening [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) session.
  sig {returns(::T.untyped)}
  def capable_login_auth?(); end

  # true if server advertises AUTH PLAIN. You cannot get valid value before
  # opening [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) session.
  sig {returns(::T.untyped)}
  def capable_plain_auth?(); end

  # true if server advertises STARTTLS. You cannot get valid value before
  # opening [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) session.
  sig {returns(::T.untyped)}
  def capable_starttls?(); end

  # This method sends a message. If `msgstr` is given, sends it as a message. If
  # block is given, yield a message writer stream. You must write message before
  # the block is closed.
  #
  # ```ruby
  # # Example 1 (by string)
  # smtp.data(<<EndMessage)
  # From: john@example.com
  # To: betty@example.com
  # Subject: I found a bug
  #
  # Check vm.c:58879.
  # EndMessage
  #
  # # Example 2 (by block)
  # smtp.data {|f|
  #   f.puts "From: john@example.com"
  #   f.puts "To: betty@example.com"
  #   f.puts "Subject: I found a bug"
  #   f.puts ""
  #   f.puts "Check vm.c:58879."
  # }
  # ```
  sig do
    params(
      msgstr: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data(msgstr=T.unsafe(nil), &block); end

  # WARNING: This method causes serious security holes. Use this method for only
  # debugging.
  #
  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) an output stream for
  # debug logging. You must call this before
  # [`start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-start).
  #
  # ```
  # # example
  # smtp = Net::SMTP.new(addr, port)
  # smtp.set_debug_output $stderr
  # smtp.start do |smtp|
  #   ....
  # end
  # ```
  #
  #
  # Also aliased as:
  # [`set_debug_output`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-set_debug_output)
  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_output=(arg); end

  # Alias for:
  # [`disable_tls`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-disable_tls)
  sig {returns(::T.untyped)}
  def disable_ssl(); end

  # Disables SMTP/TLS (STARTTLS) for this object. Must be called before the
  # connection is established to have any effect.
  sig {returns(::T.untyped)}
  def disable_starttls(); end

  # Disables SMTP/TLS for this object. Must be called before the connection is
  # established to have any effect.
  #
  # Also aliased as:
  # [`disable_ssl`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-disable_ssl)
  sig {returns(::T.untyped)}
  def disable_tls(); end

  sig do
    params(
      domain: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ehlo(domain); end

  # Alias for:
  # [`enable_tls`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-enable_tls)
  sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_ssl(context=T.unsafe(nil)); end

  # Enables SMTP/TLS (STARTTLS) for this object. `context` is a
  # [`OpenSSL::SSL::SSLContext`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/SSL/SSLContext.html)
  # object.
  sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_starttls(context=T.unsafe(nil)); end

  # Enables SMTP/TLS (STARTTLS) for this object if server accepts. `context` is
  # a
  # [`OpenSSL::SSL::SSLContext`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/SSL/SSLContext.html)
  # object.
  sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_starttls_auto(context=T.unsafe(nil)); end

  # Enables SMTP/TLS (SMTPS:
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) over direct TLS
  # connection) for this object. Must be called before the connection is
  # established to have any effect. `context` is a
  # [`OpenSSL::SSL::SSLContext`](https://docs.ruby-lang.org/en/2.6.0/OpenSSL/SSL/SSLContext.html)
  # object.
  #
  # Also aliased as:
  # [`enable_ssl`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-enable_ssl)
  sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_tls(context=T.unsafe(nil)); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) whether to use ESMTP
  # or not. This should be done before calling
  # [`start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-start).
  # Note that if
  # [`start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-start)
  # is called in ESMTP mode, and the connection fails due to a ProtocolError,
  # the [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) object will
  # automatically switch to plain
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) mode and retry
  # (but not vice versa).
  sig {returns(::T.untyped)}
  def esmtp(); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) whether to use ESMTP
  # or not. This should be done before calling
  # [`start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-start).
  # Note that if
  # [`start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-start)
  # is called in ESMTP mode, and the connection fails due to a ProtocolError,
  # the [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) object will
  # automatically switch to plain
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) mode and retry
  # (but not vice versa).
  sig do
    params(
      esmtp: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def esmtp=(esmtp); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) whether to use ESMTP
  # or not. This should be done before calling
  # [`start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-start).
  # Note that if
  # [`start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-start)
  # is called in ESMTP mode, and the connection fails due to a ProtocolError,
  # the [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) object will
  # automatically switch to plain
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) mode and retry
  # (but not vice versa).
  sig {returns(::T.untyped)}
  def esmtp?(); end

  # Finishes the [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html)
  # session and closes TCP connection. Raises
  # [`IOError`](https://docs.ruby-lang.org/en/2.6.0/IOError.html) if not
  # started.
  sig {returns(::T.untyped)}
  def finish(); end

  sig do
    params(
      domain: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def helo(domain); end

  sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(address, port=T.unsafe(nil)); end

  # Provide human-readable stringification of class state.
  sig {returns(::T.untyped)}
  def inspect(); end

  sig do
    params(
      from_addr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailfrom(from_addr); end

  # Opens a message writer stream and gives it to the block. The stream is valid
  # only in the block, and has these methods:
  #
  # puts(str = '')
  # :   outputs STR and CR LF.
  # print(str)
  # :   outputs STR.
  # printf(fmt, \*args)
  # :   outputs sprintf(fmt,\*args).
  # write(str)
  # :   outputs STR and returns the length of written bytes.
  # <<(str)
  # :   outputs STR and returns self.
  #
  #
  # If a single CR ("r") or LF ("n") is found in the message, it is converted to
  # the CR LF pair. You cannot send a binary message with this method.
  #
  # ### Parameters
  #
  # `from_addr` is a [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html)
  # representing the source mail address.
  #
  # `to_addr` is a [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html)
  # or Strings or [`Array`](https://docs.ruby-lang.org/en/2.6.0/Array.html) of
  # Strings, representing the destination mail address or addresses.
  #
  # ### Example
  #
  # ```ruby
  # Net::SMTP.start('smtp.example.com', 25) do |smtp|
  #   smtp.open_message_stream('from@example.com', ['dest@example.com']) do |f|
  #     f.puts 'From: from@example.com'
  #     f.puts 'To: dest@example.com'
  #     f.puts 'Subject: test message'
  #     f.puts
  #     f.puts 'This is a test message.'
  #   end
  # end
  # ```
  #
  # ### Errors
  #
  # This method may raise:
  #
  # *   [`Net::SMTPServerBusy`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPServerBusy.html)
  # *   [`Net::SMTPSyntaxError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPSyntaxError.html)
  # *   [`Net::SMTPFatalError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPFatalError.html)
  # *   [`Net::SMTPUnknownError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPUnknownError.html)
  # *   [`Net::ReadTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/ReadTimeout.html)
  # *   [`IOError`](https://docs.ruby-lang.org/en/2.6.0/IOError.html)
  #
  #
  # Also aliased as:
  # [`ready`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-ready)
  sig do
    params(
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_message_stream(from_addr, *to_addrs, &block); end

  # Seconds to wait while attempting to open a connection. If the connection
  # cannot be opened within this time, a
  # [`Net::OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html)
  # is raised. The default value is 30 seconds.
  sig {returns(::T.untyped)}
  def open_timeout(); end

  # Seconds to wait while attempting to open a connection. If the connection
  # cannot be opened within this time, a
  # [`Net::OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html)
  # is raised. The default value is 30 seconds.
  sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  # The port number of the
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) server to
  # connect to.
  sig {returns(::T.untyped)}
  def port(); end

  sig {returns(::T.untyped)}
  def quit(); end

  sig do
    params(
      to_addr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rcptto(to_addr); end

  sig do
    params(
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rcptto_list(to_addrs); end

  # Seconds to wait while reading one block (by one read(2) call). If the
  # read(2) call does not complete within this time, a
  # [`Net::ReadTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/ReadTimeout.html)
  # is raised. The default value is 60 seconds.
  sig {returns(::T.untyped)}
  def read_timeout(); end

  # [`Set`](https://docs.ruby-lang.org/en/2.6.0/Set.html) the number of seconds
  # to wait until timing-out a read(2) call.
  sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end

  # Alias for:
  # [`open_message_stream`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-open_message_stream)
  sig do
    params(
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ready(from_addr, *to_addrs, &block); end

  # Aborts the current mail transaction
  sig {returns(::T.untyped)}
  def rset(); end

  # Alias for:
  # [`send_message`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-send_message)
  sig do
    params(
      msgstr: ::T.untyped,
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_mail(msgstr, from_addr, *to_addrs); end

  # Sends `msgstr` as a message. Single CR ("r") and LF ("n") found in the
  # `msgstr`, are converted into the CR LF pair. You cannot send a binary
  # message with this method. `msgstr` should include both the message headers
  # and body.
  #
  # `from_addr` is a [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html)
  # representing the source mail address.
  #
  # `to_addr` is a [`String`](https://docs.ruby-lang.org/en/2.6.0/String.html)
  # or Strings or [`Array`](https://docs.ruby-lang.org/en/2.6.0/Array.html) of
  # Strings, representing the destination mail address or addresses.
  #
  # ### Example
  #
  # ```ruby
  # Net::SMTP.start('smtp.example.com') do |smtp|
  #   smtp.send_message msgstr,
  #                     'from@example.com',
  #                     ['dest@example.com', 'dest2@example.com']
  # end
  # ```
  #
  # ### Errors
  #
  # This method may raise:
  #
  # *   [`Net::SMTPServerBusy`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPServerBusy.html)
  # *   [`Net::SMTPSyntaxError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPSyntaxError.html)
  # *   [`Net::SMTPFatalError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPFatalError.html)
  # *   [`Net::SMTPUnknownError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPUnknownError.html)
  # *   [`Net::ReadTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/ReadTimeout.html)
  # *   [`IOError`](https://docs.ruby-lang.org/en/2.6.0/IOError.html)
  #
  #
  # Also aliased as:
  # [`send_mail`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-send_mail),
  # [`sendmail`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-sendmail)
  sig do
    params(
      msgstr: ::T.untyped,
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_message(msgstr, from_addr, *to_addrs); end

  # Alias for:
  # [`send_message`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-send_message)
  sig do
    params(
      msgstr: ::T.untyped,
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sendmail(msgstr, from_addr, *to_addrs); end

  # Alias for:
  # [`debug_output=`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-debug_output-3D)
  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_debug_output(arg); end

  # Alias for:
  # [`tls?`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-tls-3F)
  sig {returns(::T.untyped)}
  def ssl?(); end

  # Opens a TCP connection and starts the
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) session.
  #
  # ### Parameters
  #
  # `helo` is the *HELO* *domain* that you'll dispatch mails from; see the
  # discussion in the overview notes.
  #
  # If both of `user` and `secret` are given,
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) authentication
  # will be attempted using the AUTH command. `authtype` specifies the type of
  # authentication to attempt; it must be one of :login, :plain, and :cram\_md5.
  # See the notes on [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html)
  # Authentication in the overview.
  #
  # ### Block Usage
  #
  # When this methods is called with a block, the newly-started
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) object is
  # yielded to the block, and automatically closed after the block call
  # finishes. Otherwise, it is the caller's responsibility to close the session
  # when finished.
  #
  # ### Example
  #
  # This is very similar to the class method
  # [`SMTP.start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-c-start).
  #
  # ```ruby
  # require 'net/smtp'
  # smtp = Net::SMTP.new('smtp.mail.server', 25)
  # smtp.start(helo_domain, account, password, authtype) do |smtp|
  #   smtp.send_message msgstr, 'from@example.com', ['dest@example.com']
  # end
  # ```
  #
  # The primary use of this method (as opposed to
  # [`SMTP.start`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-c-start))
  # is probably to set debugging (#set\_debug\_output) or ESMTP (#esmtp=), which
  # must be done before the session is started.
  #
  # ### Errors
  #
  # If session has already been started, an
  # [`IOError`](https://docs.ruby-lang.org/en/2.6.0/IOError.html) will be
  # raised.
  #
  # This method may raise:
  #
  # *   [`Net::SMTPAuthenticationError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPAuthenticationError.html)
  # *   [`Net::SMTPServerBusy`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPServerBusy.html)
  # *   [`Net::SMTPSyntaxError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPSyntaxError.html)
  # *   [`Net::SMTPFatalError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPFatalError.html)
  # *   [`Net::SMTPUnknownError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPUnknownError.html)
  # *   [`Net::OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html)
  # *   [`Net::ReadTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/ReadTimeout.html)
  # *   [`IOError`](https://docs.ruby-lang.org/en/2.6.0/IOError.html)
  sig do
    params(
      helo: ::T.untyped,
      user: ::T.untyped,
      secret: ::T.untyped,
      authtype: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def start(helo=T.unsafe(nil), user=T.unsafe(nil), secret=T.unsafe(nil), authtype=T.unsafe(nil)); end

  # `true` if the [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html)
  # session has been started.
  sig {returns(::T.untyped)}
  def started?(); end

  sig {returns(::T.untyped)}
  def starttls(); end

  # Returns truth value if this object uses STARTTLS. If this object always uses
  # STARTTLS, returns :always. If this object uses STARTTLS when the server
  # support TLS, returns :auto.
  sig {returns(::T.untyped)}
  def starttls?(); end

  # true if this object uses STARTTLS.
  sig {returns(::T.untyped)}
  def starttls_always?(); end

  # true if this object uses STARTTLS when server advertises STARTTLS.
  sig {returns(::T.untyped)}
  def starttls_auto?(); end

  # true if this object uses SMTP/TLS (SMTPS).
  #
  # Also aliased as:
  # [`ssl?`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-i-ssl-3F)
  sig {returns(::T.untyped)}
  def tls?(); end

  # The default [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) port
  # number, 25.
  sig {returns(::T.untyped)}
  def self.default_port(); end

  sig {returns(::T.untyped)}
  def self.default_ssl_context(); end

  # Alias for:
  # [`default_tls_port`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-c-default_tls_port)
  sig {returns(::T.untyped)}
  def self.default_ssl_port(); end

  # The default mail submission port number, 587.
  sig {returns(::T.untyped)}
  def self.default_submission_port(); end

  # The default SMTPS port number, 465.
  #
  # Also aliased as:
  # [`default_ssl_port`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html#method-c-default_ssl_port)
  sig {returns(::T.untyped)}
  def self.default_tls_port(); end

  # Creates a new
  # [`Net::SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) object and
  # connects to the server.
  #
  # This method is equivalent to:
  #
  # ```ruby
  # Net::SMTP.new(address, port).start(helo_domain, account, password, authtype)
  # ```
  #
  # ### Example
  #
  # ```ruby
  # Net::SMTP.start('your.smtp.server') do |smtp|
  #   smtp.send_message msgstr, 'from@example.com', ['dest@example.com']
  # end
  # ```
  #
  # ### Block Usage
  #
  # If called with a block, the newly-opened
  # [`Net::SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) object is
  # yielded to the block, and automatically closed when the block finishes. If
  # called without a block, the newly-opened
  # [`Net::SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) object is
  # returned to the caller, and it is the caller's responsibility to close it
  # when finished.
  #
  # ### Parameters
  #
  # `address` is the hostname or ip address of your smtp server.
  #
  # `port` is the port to connect to; it defaults to port 25.
  #
  # `helo` is the *HELO* *domain* provided by the client to the server (see
  # overview comments); it defaults to 'localhost'.
  #
  # The remaining arguments are used for
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) authentication,
  # if required or desired. `user` is the account name; `secret` is your
  # password or other authentication token; and `authtype` is the authentication
  # type, one of :plain, :login, or :cram\_md5. See the discussion of
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) Authentication
  # in the overview notes.
  #
  # ### Errors
  #
  # This method may raise:
  #
  # *   [`Net::SMTPAuthenticationError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPAuthenticationError.html)
  # *   [`Net::SMTPServerBusy`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPServerBusy.html)
  # *   [`Net::SMTPSyntaxError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPSyntaxError.html)
  # *   [`Net::SMTPFatalError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPFatalError.html)
  # *   [`Net::SMTPUnknownError`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTPUnknownError.html)
  # *   [`Net::OpenTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/OpenTimeout.html)
  # *   [`Net::ReadTimeout`](https://docs.ruby-lang.org/en/2.6.0/Net/ReadTimeout.html)
  # *   [`IOError`](https://docs.ruby-lang.org/en/2.6.0/IOError.html)
  sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
      helo: ::T.untyped,
      user: ::T.untyped,
      secret: ::T.untyped,
      authtype: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(address, port=T.unsafe(nil), helo=T.unsafe(nil), user=T.unsafe(nil), secret=T.unsafe(nil), authtype=T.unsafe(nil), &block); end
end

# This class represents a response received by the
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) server. Instances
# of this class are created by the
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) class; they should
# not be directly created by the user. For more information on
# [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) responses, view
# [Section 4.2 of RFC 5321](http://tools.ietf.org/html/rfc5321#section-4.2)
class Net::SMTP::Response
  # Returns a hash of the human readable reply text in the response if it is
  # multiple lines. It does not return the first line. The key of the hash is
  # the first word the value of the hash is an array with each word thereafter
  # being a value in the array
  sig {returns(::T.untyped)}
  def capabilities(); end

  # Determines whether the response received was a Positive Intermediate reply
  # (3xx reply code)
  sig {returns(::T.untyped)}
  def continue?(); end

  # Creates a CRAM-MD5 challenge. You can view more information on CRAM-MD5 on
  # Wikipedia: https://en.wikipedia.org/wiki/CRAM-MD5
  sig {returns(::T.untyped)}
  def cram_md5_challenge(); end

  # Determines whether there was an error and raises the appropriate error based
  # on the reply code of the response
  sig {returns(::T.untyped)}
  def exception_class(); end

  sig do
    params(
      status: ::T.untyped,
      string: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(status, string); end

  # The first line of the human readable reply text
  sig {returns(::T.untyped)}
  def message(); end

  # The three digit reply code of the
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) response
  sig {returns(::T.untyped)}
  def status(); end

  # Takes the first digit of the reply code to determine the status type
  sig {returns(::T.untyped)}
  def status_type_char(); end

  # The human readable reply text of the
  # [`SMTP`](https://docs.ruby-lang.org/en/2.6.0/Net/SMTP.html) response
  sig {returns(::T.untyped)}
  def string(); end

  # Determines whether the response received was a Positive Completion reply
  # (2xx reply code)
  sig {returns(::T.untyped)}
  def success?(); end

  # Parses the received response and separates the reply code and the human
  # readable reply text
  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(str); end
end

# Represents an SMTP authentication error.
class Net::SMTPAuthenticationError < Net::ProtoAuthError
  include ::Net::SMTPError
end

# [`Module`](https://docs.ruby-lang.org/en/2.6.0/Module.html) mixed in to all
# SMTP error classes
module Net::SMTPError
end

# Represents a fatal SMTP error (error code 5xx, except for 500)
class Net::SMTPFatalError < Net::ProtoFatalError
  include ::Net::SMTPError
end

# Represents SMTP error code 420 or 450, a temporary error.
class Net::SMTPServerBusy < Net::ProtoServerError
  include ::Net::SMTPError
end

# Represents an SMTP command syntax error (error code 500)
class Net::SMTPSyntaxError < Net::ProtoSyntaxError
  include ::Net::SMTPError
end

# Unexpected reply code returned from server.
class Net::SMTPUnknownError < Net::ProtoUnknownError
  include ::Net::SMTPError
end

# Command is not supported on server.
class Net::SMTPUnsupportedCommand < Net::ProtocolError
  include ::Net::SMTPError
end

module Net::SSH
  VALID_OPTIONS = ::T.let(nil, ::T.untyped)

  sig do
    params(
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.assign_defaults(options); end

  sig do
    params(
      host: ::T.untyped,
      use_ssh_config: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.configuration_for(host, use_ssh_config); end

  sig do
    params(
      host: ::T.untyped,
      user: ::T.untyped,
      options: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(host, user=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module Net::SSH::Authentication
end

class Net::SSH::Authentication::Agent
  include ::Net::SSH::Loggable
  SSH2_AGENT_ADD_IDENTITY = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_ADD_ID_CONSTRAINED = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_FAILURE = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_IDENTITIES_ANSWER = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_REMOVE_ALL_IDENTITIES = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_REMOVE_IDENTITY = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_REQUEST_IDENTITIES = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_REQUEST_VERSION = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_SIGN_REQUEST = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_SIGN_RESPONSE = ::T.let(nil, ::T.untyped)
  SSH2_AGENT_VERSION_RESPONSE = ::T.let(nil, ::T.untyped)
  SSH_AGENT_CONSTRAIN_CONFIRM = ::T.let(nil, ::T.untyped)
  SSH_AGENT_CONSTRAIN_LIFETIME = ::T.let(nil, ::T.untyped)
  SSH_AGENT_FAILURE = ::T.let(nil, ::T.untyped)
  SSH_AGENT_REQUEST_RSA_IDENTITIES = ::T.let(nil, ::T.untyped)
  SSH_AGENT_RSA_IDENTITIES_ANSWER1 = ::T.let(nil, ::T.untyped)
  SSH_AGENT_RSA_IDENTITIES_ANSWER2 = ::T.let(nil, ::T.untyped)
  SSH_AGENT_RSA_SHA2_256 = ::T.let(nil, ::T.untyped)
  SSH_AGENT_RSA_SHA2_512 = ::T.let(nil, ::T.untyped)
  SSH_AGENT_SUCCESS = ::T.let(nil, ::T.untyped)
  SSH_COM_AGENT2_FAILURE = ::T.let(nil, ::T.untyped)

  sig do
    params(
      priv_key: ::T.untyped,
      comment: ::T.untyped,
      lifetime: ::T.untyped,
      confirm: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_identity(priv_key, comment, lifetime: T.unsafe(nil), confirm: T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def close(); end

  sig do
    params(
      agent_socket_factory: ::T.untyped,
      identity_agent: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connect!(agent_socket_factory=T.unsafe(nil), identity_agent=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def identities(); end

  sig do
    params(
      logger: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(logger=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def negotiate!(); end

  sig {returns(::T.untyped)}
  def remove_all_identities(); end

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove_identity(key); end

  sig do
    params(
      key: ::T.untyped,
      data: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(key, data, flags=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def socket(); end

  sig do
    params(
      logger: ::T.untyped,
      agent_socket_factory: ::T.untyped,
      identity_agent: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.connect(logger=T.unsafe(nil), agent_socket_factory=T.unsafe(nil), identity_agent=T.unsafe(nil)); end
end

module Net::SSH::Authentication::Agent::Comment
  sig {returns(::T.untyped)}
  def comment(); end

  sig do
    params(
      comment: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def comment=(comment); end
end

class Net::SSH::Authentication::AgentError < Net::SSH::Exception
end

class Net::SSH::Authentication::AgentNotAvailable < Net::SSH::Authentication::AgentError
end

class Net::SSH::Authentication::Certificate
  sig {returns(::T.untyped)}
  def critical_options(); end

  sig do
    params(
      critical_options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def critical_options=(critical_options); end

  sig {returns(::T.untyped)}
  def extensions(); end

  sig do
    params(
      extensions: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extensions=(extensions); end

  sig {returns(::T.untyped)}
  def fingerprint(); end

  sig {returns(::T.untyped)}
  def key(); end

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key=(key); end

  sig {returns(::T.untyped)}
  def key_id(); end

  sig do
    params(
      key_id: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key_id=(key_id); end

  sig {returns(::T.untyped)}
  def nonce(); end

  sig do
    params(
      nonce: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def nonce=(nonce); end

  sig {returns(::T.untyped)}
  def reserved(); end

  sig do
    params(
      reserved: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reserved=(reserved); end

  sig {returns(::T.untyped)}
  def serial(); end

  sig do
    params(
      serial: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def serial=(serial); end

  sig do
    params(
      key: ::T.untyped,
      sign_nonce: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(key, sign_nonce=T.unsafe(nil)); end

  sig do
    params(
      key: ::T.untyped,
      sign_nonce: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign!(key, sign_nonce=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def signature(); end

  sig do
    params(
      signature: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def signature=(signature); end

  sig {returns(::T.untyped)}
  def signature_key(); end

  sig do
    params(
      signature_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def signature_key=(signature_key); end

  sig {returns(::T.untyped)}
  def signature_valid?(); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssh_do_sign(data); end

  sig do
    params(
      sig: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssh_do_verify(sig, data); end

  sig {returns(::T.untyped)}
  def ssh_signature_type(); end

  sig {returns(::T.untyped)}
  def ssh_type(); end

  sig {returns(::T.untyped)}
  def to_blob(); end

  sig {returns(::T.untyped)}
  def to_pem(); end

  sig {returns(::T.untyped)}
  def type(); end

  sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def type=(type); end

  sig {returns(::T.untyped)}
  def valid_after(); end

  sig do
    params(
      valid_after: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def valid_after=(valid_after); end

  sig {returns(::T.untyped)}
  def valid_before(); end

  sig do
    params(
      valid_before: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def valid_before=(valid_before); end

  sig {returns(::T.untyped)}
  def valid_principals(); end

  sig do
    params(
      valid_principals: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def valid_principals=(valid_principals); end

  sig do
    params(
      buffer: ::T.untyped,
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.read_certblob(buffer, type); end
end

module Net::SSH::Authentication::Constants
  USERAUTH_BANNER = ::T.let(nil, ::T.untyped)
  USERAUTH_FAILURE = ::T.let(nil, ::T.untyped)
  USERAUTH_METHOD_RANGE = ::T.let(nil, ::T.untyped)
  USERAUTH_PASSWD_CHANGEREQ = ::T.let(nil, ::T.untyped)
  USERAUTH_PK_OK = ::T.let(nil, ::T.untyped)
  USERAUTH_REQUEST = ::T.let(nil, ::T.untyped)
  USERAUTH_SUCCESS = ::T.let(nil, ::T.untyped)
end

class Net::SSH::Authentication::DisallowedMethod < Net::SSH::Exception
end

module Net::SSH::Authentication::ED25519Loader
  ERROR = ::T.let(nil, ::T.untyped)
  LOADED = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def self.dependenciesRequiredForED25519(); end

  sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.raiseUnlessLoaded(message); end
end

class Net::SSH::Authentication::KeyManager
  include ::Net::SSH::Loggable
  sig do
    params(
      key_file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add(key_file); end

  sig do
    params(
      key_data_: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_key_data(key_data_); end

  sig {returns(::T.untyped)}
  def agent(); end

  sig {returns(::T.untyped)}
  def clear!(); end

  sig {returns(::T.untyped)}
  def each_identity(); end

  sig {returns(::T.untyped)}
  def finish(); end

  sig do
    params(
      logger: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(logger, options=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def key_data(); end

  sig {returns(::T.untyped)}
  def key_files(); end

  sig {returns(::T.untyped)}
  def known_identities(); end

  sig {returns(::T.untyped)}
  def no_keys?(); end

  sig {returns(::T.untyped)}
  def options(); end

  sig do
    params(
      identity: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sign(identity, data); end

  sig do
    params(
      use_agent: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def use_agent=(use_agent); end

  sig {returns(::T.untyped)}
  def use_agent?(); end
end

class Net::SSH::Authentication::KeyManagerError < Net::SSH::Exception
end

module Net::SSH::Authentication::Methods
end

class Net::SSH::Authentication::Methods::Abstract
  include ::Net::SSH::Authentication::Constants
  include ::Net::SSH::Loggable
  sig do
    params(
      session: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session, options=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def key_manager(); end

  sig do
    params(
      msg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_message(msg); end

  sig {returns(::T.untyped)}
  def session(); end

  sig {returns(::T.untyped)}
  def session_id(); end

  sig do
    params(
      username: ::T.untyped,
      next_service: ::T.untyped,
      auth_method: ::T.untyped,
      others: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def userauth_request(username, next_service, auth_method, *others); end
end

class Net::SSH::Authentication::Methods::Hostbased < Net::SSH::Authentication::Methods::Abstract
  sig do
    params(
      next_service: ::T.untyped,
      username: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, username, password=T.unsafe(nil)); end
end

class Net::SSH::Authentication::Methods::KeyboardInteractive < Net::SSH::Authentication::Methods::Abstract
  USERAUTH_INFO_REQUEST = ::T.let(nil, ::T.untyped)
  USERAUTH_INFO_RESPONSE = ::T.let(nil, ::T.untyped)

  sig do
    params(
      next_service: ::T.untyped,
      username: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, username, password=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def interactive?(); end
end

class Net::SSH::Authentication::Methods::None < Net::SSH::Authentication::Methods::Abstract
  sig do
    params(
      next_service: ::T.untyped,
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, user=T.unsafe(nil), password=T.unsafe(nil)); end
end

class Net::SSH::Authentication::Methods::Password < Net::SSH::Authentication::Methods::Abstract
  NUMBER_OF_PASSWORD_PROMPTS = ::T.let(nil, ::T.untyped)

  sig do
    params(
      next_service: ::T.untyped,
      username: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, username, password=T.unsafe(nil)); end
end

class Net::SSH::Authentication::Methods::Publickey < Net::SSH::Authentication::Methods::Abstract
  sig do
    params(
      next_service: ::T.untyped,
      username: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, username, password=T.unsafe(nil)); end
end

module Net::SSH::Authentication::PubKeyFingerprint
  sig do
    params(
      algorithm: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fingerprint(algorithm=T.unsafe(nil)); end

  sig do
    params(
      blob: ::T.untyped,
      algorithm: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.fingerprint(blob, algorithm=T.unsafe(nil)); end
end

class Net::SSH::Authentication::Session
  include ::Net::SSH::Transport::Constants
  include ::Net::SSH::Authentication::Constants
  include ::Net::SSH::Loggable
  sig {returns(::T.untyped)}
  def allowed_auth_methods(); end

  sig {returns(::T.untyped)}
  def auth_methods(); end

  sig do
    params(
      next_service: ::T.untyped,
      username: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(next_service, username, password=T.unsafe(nil)); end

  sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def expect_message(type); end

  sig do
    params(
      transport: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(transport, options=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def next_message(); end

  sig {returns(::T.untyped)}
  def options(); end

  sig {returns(::T.untyped)}
  def transport(); end
end

class Net::SSH::AuthenticationFailed < Net::SSH::Exception
end

class Net::SSH::Buffer
  sig do
    params(
      buffer: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ==(buffer); end

  sig do
    params(
      text: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def append(text); end

  sig {returns(::T.untyped)}
  def available(); end

  sig {returns(::T.untyped)}
  def clear!(); end

  sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def consume!(n=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def content(); end

  sig {returns(::T.untyped)}
  def empty?(); end

  sig {returns(::T.untyped)}
  def eof?(); end

  sig do
    params(
      content: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(content=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def length(); end

  sig {returns(::T.untyped)}
  def position(); end

  sig do
    params(
      position: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def position=(position); end

  sig do
    params(
      count: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(count=T.unsafe(nil)); end

  sig do
    params(
      count: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read!(count=T.unsafe(nil)); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_all(&block); end

  sig {returns(::T.untyped)}
  def read_bignum(); end

  sig {returns(::T.untyped)}
  def read_bool(); end

  sig {returns(::T.untyped)}
  def read_buffer(); end

  sig {returns(::T.untyped)}
  def read_byte(); end

  sig {returns(::T.untyped)}
  def read_int64(); end

  sig {returns(::T.untyped)}
  def read_key(); end

  sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_keyblob(type); end

  sig {returns(::T.untyped)}
  def read_long(); end

  sig do
    params(
      type: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_private_keyblob(type); end

  sig {returns(::T.untyped)}
  def read_string(); end

  sig do
    params(
      pattern: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_to(pattern); end

  sig {returns(::T.untyped)}
  def remainder_as_buffer(); end

  sig {returns(::T.untyped)}
  def reset!(); end

  sig {returns(::T.untyped)}
  def to_s(); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(*data); end

  sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_bignum(*n); end

  sig do
    params(
      b: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_bool(*b); end

  sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_byte(*n); end

  sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_int64(*n); end

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_key(*key); end

  sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_long(*n); end

  sig do
    params(
      string: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_moved(string); end

  sig do
    params(
      text: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_mstring(*text); end

  sig do
    params(
      text: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_string(*text); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.from(*args); end
end

module Net::SSH::BufferedIo
  include ::Net::SSH::Loggable
  sig {returns(::T.untyped)}
  def available(); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enqueue(data); end

  sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fill(n=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def pending_write?(); end

  sig do
    params(
      length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_available(length=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def read_buffer(); end

  sig {returns(::T.untyped)}
  def send_pending(); end

  sig {returns(::T.untyped)}
  def wait_for_pending_sends(); end

  sig {returns(::T.untyped)}
  def write_buffer(); end

  sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.extended(object); end
end

class Net::SSH::ChannelOpenFailed < Net::SSH::Exception
  sig {returns(::T.untyped)}
  def code(); end

  sig do
    params(
      code: ::T.untyped,
      reason: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(code, reason); end

  sig {returns(::T.untyped)}
  def reason(); end
end

class Net::SSH::ChannelRequestFailed < Net::SSH::Exception
end

class Net::SSH::Config
  sig {returns(::T.untyped)}
  def self.default_auth_methods(); end

  sig {returns(::T.untyped)}
  def self.default_files(); end

  sig {returns(::T.untyped)}
  def self.expandable_default_files(); end

  sig do
    params(
      host: ::T.untyped,
      files: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.for(host, files=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      host: ::T.untyped,
      settings: ::T.untyped,
      base_dir: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load(path, host, settings=T.unsafe(nil), base_dir=T.unsafe(nil)); end

  sig do
    params(
      settings: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.translate(settings); end
end

module Net::SSH::Connection
end

class Net::SSH::Connection::Channel
  include ::Net::SSH::Connection::Constants
  include ::Net::SSH::Loggable
  GOOD_LOCAL_MAXIUMUM_WINDOW_SIZE = ::T.let(nil, ::T.untyped)
  LOCAL_WINDOW_SIZE_INCREMENT = ::T.let(nil, ::T.untyped)
  VALID_PTY_OPTIONS = ::T.let(nil, ::T.untyped)

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](name); end

  sig do
    params(
      name: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(name, value); end

  sig {returns(::T.untyped)}
  def active?(); end

  sig {returns(::T.untyped)}
  def close(); end

  sig {returns(::T.untyped)}
  def closing?(); end

  sig {returns(::T.untyped)}
  def connection(); end

  sig {returns(::T.untyped)}
  def do_close(); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_data(data); end

  sig {returns(::T.untyped)}
  def do_eof(); end

  sig do
    params(
      type: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_extended_data(type, data); end

  sig {returns(::T.untyped)}
  def do_failure(); end

  sig do
    params(
      remote_id: ::T.untyped,
      max_window: ::T.untyped,
      max_packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_open_confirmation(remote_id, max_window, max_packet); end

  sig do
    params(
      reason_code: ::T.untyped,
      description: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_open_failed(reason_code, description); end

  sig do
    params(
      request: ::T.untyped,
      want_reply: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_request(request, want_reply, data); end

  sig {returns(::T.untyped)}
  def do_success(); end

  sig do
    params(
      bytes: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def do_window_adjust(bytes); end

  sig {returns(::T.untyped)}
  def enqueue_pending_output(); end

  sig do
    params(
      variable_name: ::T.untyped,
      variable_value: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def env(variable_name, variable_value, &block); end

  sig {returns(::T.untyped)}
  def eof!(); end

  sig {returns(::T.untyped)}
  def eof?(); end

  sig do
    params(
      command: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def exec(command, &block); end

  sig do
    params(
      connection: ::T.untyped,
      type: ::T.untyped,
      local_id: ::T.untyped,
      max_pkt_size: ::T.untyped,
      max_win_size: ::T.untyped,
      on_confirm_open: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(connection, type, local_id, max_pkt_size=T.unsafe(nil), max_win_size=T.unsafe(nil), &on_confirm_open); end

  sig {returns(::T.untyped)}
  def local_closed?(); end

  sig {returns(::T.untyped)}
  def local_id(); end

  sig {returns(::T.untyped)}
  def local_maximum_packet_size(); end

  sig {returns(::T.untyped)}
  def local_maximum_window_size(); end

  sig {returns(::T.untyped)}
  def local_window_size(); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_close(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_data(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_eof(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_extended_data(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_open_failed(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_process(&block); end

  sig do
    params(
      type: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_request(type, &block); end

  sig {returns(::T.untyped)}
  def output(); end

  sig {returns(::T.untyped)}
  def pending_requests(); end

  sig {returns(::T.untyped)}
  def process(); end

  sig {returns(::T.untyped)}
  def properties(); end

  sig {returns(::T.untyped)}
  def remote_closed!(); end

  sig {returns(::T.untyped)}
  def remote_closed?(); end

  sig {returns(::T.untyped)}
  def remote_id(); end

  sig {returns(::T.untyped)}
  def remote_maximum_packet_size(); end

  sig {returns(::T.untyped)}
  def remote_maximum_window_size(); end

  sig {returns(::T.untyped)}
  def remote_window_size(); end

  sig do
    params(
      opts: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_pty(opts=T.unsafe(nil), &block); end

  sig do
    params(
      request_name: ::T.untyped,
      data: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_channel_request(request_name, *data, &callback); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(data); end

  sig do
    params(
      subsystem: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subsystem(subsystem, &block); end

  sig {returns(::T.untyped)}
  def type(); end

  sig {returns(::T.untyped)}
  def wait(); end
end

module Net::SSH::Connection::Constants
  CHANNEL_CLOSE = ::T.let(nil, ::T.untyped)
  CHANNEL_DATA = ::T.let(nil, ::T.untyped)
  CHANNEL_EOF = ::T.let(nil, ::T.untyped)
  CHANNEL_EXTENDED_DATA = ::T.let(nil, ::T.untyped)
  CHANNEL_FAILURE = ::T.let(nil, ::T.untyped)
  CHANNEL_OPEN = ::T.let(nil, ::T.untyped)
  CHANNEL_OPEN_CONFIRMATION = ::T.let(nil, ::T.untyped)
  CHANNEL_OPEN_FAILURE = ::T.let(nil, ::T.untyped)
  CHANNEL_REQUEST = ::T.let(nil, ::T.untyped)
  CHANNEL_SUCCESS = ::T.let(nil, ::T.untyped)
  CHANNEL_WINDOW_ADJUST = ::T.let(nil, ::T.untyped)
  GLOBAL_REQUEST = ::T.let(nil, ::T.untyped)
  REQUEST_FAILURE = ::T.let(nil, ::T.untyped)
  REQUEST_SUCCESS = ::T.let(nil, ::T.untyped)
end

class Net::SSH::Connection::EventLoop
  include ::Net::SSH::Loggable
  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ev_preprocess(&block); end

  sig do
    params(
      wait: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ev_select_and_postprocess(wait); end

  sig do
    params(
      logger: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(logger=T.unsafe(nil)); end

  sig do
    params(
      wait: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(wait=T.unsafe(nil), &block); end

  sig do
    params(
      session: ::T.untyped,
      wait: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process_only(session, wait=T.unsafe(nil)); end

  sig do
    params(
      session: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def register(session); end
end

class Net::SSH::Connection::Keepalive
  include ::Net::SSH::Loggable
  sig {returns(::T.untyped)}
  def enabled?(); end

  sig do
    params(
      session: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session); end

  sig {returns(::T.untyped)}
  def interval(); end

  sig {returns(::T.untyped)}
  def keepalive_maxcount(); end

  sig {returns(::T.untyped)}
  def options(); end

  sig do
    params(
      was_events: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_as_needed(was_events); end

  sig {returns(::T.untyped)}
  def should_send?(); end
end

class Net::SSH::Connection::Session
  include ::Net::SSH::Connection::Constants
  include ::Net::SSH::Loggable
  DEFAULT_IO_SELECT_TIMEOUT = ::T.let(nil, ::T.untyped)
  MAP = ::T.let(nil, ::T.untyped)

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  sig do
    params(
      key: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(key, value); end

  sig do
    params(
      include_invisible: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def busy?(include_invisible=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def channel_open_handlers(); end

  sig {returns(::T.untyped)}
  def channels(); end

  sig do
    params(
      channel: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cleanup_channel(channel); end

  sig {returns(::T.untyped)}
  def close(); end

  sig {returns(::T.untyped)}
  def closed?(); end

  sig do
    params(
      wait: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ev_do_calculate_rw_wait(wait); end

  sig do
    params(
      readers: ::T.untyped,
      writers: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ev_do_handle_events(readers, writers); end

  sig do
    params(
      was_events: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ev_do_postprocess(was_events); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ev_preprocess(&block); end

  sig do
    params(
      command: ::T.untyped,
      status: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def exec(command, status: T.unsafe(nil), &block); end

  sig do
    params(
      command: ::T.untyped,
      status: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def exec!(command, status: T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def forward(); end

  sig {returns(::T.untyped)}
  def host(); end

  sig do
    params(
      transport: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(transport, options=T.unsafe(nil)); end

  sig do
    params(
      io: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def listen_to(io, &callback); end

  sig {returns(::T.untyped)}
  def listeners(); end

  sig do
    params(
      wait: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def loop(wait=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def max_select_wait_time(); end

  sig do
    params(
      type: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_global_request(type, &block); end

  sig do
    params(
      type: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def on_open_channel(type, &block); end

  sig do
    params(
      type: ::T.untyped,
      extra: ::T.untyped,
      on_confirm: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_channel(type=T.unsafe(nil), *extra, &on_confirm); end

  sig {returns(::T.untyped)}
  def options(); end

  sig {returns(::T.untyped)}
  def pending_requests(); end

  sig do
    params(
      readers: ::T.untyped,
      writers: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def postprocess(readers, writers); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def preprocess(&block); end

  sig do
    params(
      wait: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(wait=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def properties(); end

  sig do
    params(
      type: ::T.untyped,
      extra: ::T.untyped,
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_global_request(type, *extra, &callback); end

  sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_message(message); end

  sig do
    params(
      wait: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sftp(wait=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def shutdown!(); end

  sig do
    params(
      io: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def stop_listening_to(io); end

  sig {returns(::T.untyped)}
  def transport(); end
end

class Net::SSH::Connection::Session::NilChannel
  sig do
    params(
      session: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session); end

  sig do
    params(
      sym: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def method_missing(sym, *args); end
end

class Net::SSH::Connection::Session::StringWithExitstatus < String
  sig {returns(::T.untyped)}
  def exitstatus(); end

  sig do
    params(
      str: ::T.untyped,
      exitstatus: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(str, exitstatus); end
end

class Net::SSH::Connection::SingleSessionEventLoop < Net::SSH::Connection::EventLoop
  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ev_preprocess(&block); end

  sig do
    params(
      wait: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ev_select_and_postprocess(wait); end
end

module Net::SSH::Connection::Term
  CS7 = ::T.let(nil, ::T.untyped)
  CS8 = ::T.let(nil, ::T.untyped)
  ECHO = ::T.let(nil, ::T.untyped)
  ECHOCTL = ::T.let(nil, ::T.untyped)
  ECHOE = ::T.let(nil, ::T.untyped)
  ECHOK = ::T.let(nil, ::T.untyped)
  ECHOKE = ::T.let(nil, ::T.untyped)
  ECHONL = ::T.let(nil, ::T.untyped)
  ICANON = ::T.let(nil, ::T.untyped)
  ICRNL = ::T.let(nil, ::T.untyped)
  IEXTEN = ::T.let(nil, ::T.untyped)
  IGNCR = ::T.let(nil, ::T.untyped)
  IGNPAR = ::T.let(nil, ::T.untyped)
  IMAXBEL = ::T.let(nil, ::T.untyped)
  INCLR = ::T.let(nil, ::T.untyped)
  INPCK = ::T.let(nil, ::T.untyped)
  ISIG = ::T.let(nil, ::T.untyped)
  ISTRIP = ::T.let(nil, ::T.untyped)
  IUCLC = ::T.let(nil, ::T.untyped)
  IXANY = ::T.let(nil, ::T.untyped)
  IXOFF = ::T.let(nil, ::T.untyped)
  IXON = ::T.let(nil, ::T.untyped)
  NOFLSH = ::T.let(nil, ::T.untyped)
  OCRNL = ::T.let(nil, ::T.untyped)
  OLCUC = ::T.let(nil, ::T.untyped)
  ONLCR = ::T.let(nil, ::T.untyped)
  ONLRET = ::T.let(nil, ::T.untyped)
  ONOCR = ::T.let(nil, ::T.untyped)
  OPOST = ::T.let(nil, ::T.untyped)
  PARENB = ::T.let(nil, ::T.untyped)
  PARMRK = ::T.let(nil, ::T.untyped)
  PARODD = ::T.let(nil, ::T.untyped)
  PENDIN = ::T.let(nil, ::T.untyped)
  TOSTOP = ::T.let(nil, ::T.untyped)
  TTY_OP_ISPEED = ::T.let(nil, ::T.untyped)
  TTY_OP_OSPEED = ::T.let(nil, ::T.untyped)
  VDISCARD = ::T.let(nil, ::T.untyped)
  VDSUSP = ::T.let(nil, ::T.untyped)
  VEOF = ::T.let(nil, ::T.untyped)
  VEOL = ::T.let(nil, ::T.untyped)
  VEOL2 = ::T.let(nil, ::T.untyped)
  VERASE = ::T.let(nil, ::T.untyped)
  VFLUSH = ::T.let(nil, ::T.untyped)
  VINTR = ::T.let(nil, ::T.untyped)
  VKILL = ::T.let(nil, ::T.untyped)
  VLNEXT = ::T.let(nil, ::T.untyped)
  VQUIT = ::T.let(nil, ::T.untyped)
  VREPRINT = ::T.let(nil, ::T.untyped)
  VSTART = ::T.let(nil, ::T.untyped)
  VSTATUS = ::T.let(nil, ::T.untyped)
  VSTOP = ::T.let(nil, ::T.untyped)
  VSUSP = ::T.let(nil, ::T.untyped)
  VSWITCH = ::T.let(nil, ::T.untyped)
  VWERASE = ::T.let(nil, ::T.untyped)
  XCASE = ::T.let(nil, ::T.untyped)
end

class Net::SSH::ConnectionTimeout < Net::SSH::Exception
end

class Net::SSH::Disconnect < Net::SSH::Exception
end

class Net::SSH::Exception < RuntimeError
end

module Net::SSH::ForwardedBufferedIo
  sig do
    params(
      n: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fill(n=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def send_pending(); end
end

class Net::SSH::HostKeyError < Net::SSH::Exception
  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  sig do
    params(
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def callback=(callback); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(data); end

  sig {returns(::T.untyped)}
  def fingerprint(); end

  sig {returns(::T.untyped)}
  def host(); end

  sig {returns(::T.untyped)}
  def ip(); end

  sig {returns(::T.untyped)}
  def key(); end

  sig {returns(::T.untyped)}
  def port(); end

  sig {returns(::T.untyped)}
  def remember_host!(); end
end

class Net::SSH::HostKeyMismatch < Net::SSH::HostKeyError
end

class Net::SSH::HostKeyUnknown < Net::SSH::HostKeyError
end

class Net::SSH::HostKeys
  include ::Enumerable

  Elem = type_member(fixed: T.untyped)

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_host_key(key); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each(&block); end

  sig {returns(::T.untyped)}
  def empty?(); end

  sig {returns(::T.untyped)}
  def host(); end

  sig do
    params(
      host_keys: ::T.untyped,
      host: ::T.untyped,
      known_hosts: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(host_keys, host, known_hosts, options=T.unsafe(nil)); end
end

class Net::SSH::KeyFactory
  MAP = ::T.let(nil, ::T.untyped)

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get(name); end

  sig do
    params(
      data: ::T.untyped,
      passphrase: ::T.untyped,
      ask_passphrase: ::T.untyped,
      filename: ::T.untyped,
      prompt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load_data_private_key(data, passphrase=T.unsafe(nil), ask_passphrase=T.unsafe(nil), filename=T.unsafe(nil), prompt=T.unsafe(nil)); end

  sig do
    params(
      data: ::T.untyped,
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load_data_public_key(data, filename=T.unsafe(nil)); end

  sig do
    params(
      filename: ::T.untyped,
      passphrase: ::T.untyped,
      ask_passphrase: ::T.untyped,
      prompt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load_private_key(filename, passphrase=T.unsafe(nil), ask_passphrase=T.unsafe(nil), prompt=T.unsafe(nil)); end

  sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.load_public_key(filename); end
end

class Net::SSH::KnownHosts
  SUPPORTED_TYPE = ::T.let(nil, ::T.untyped)

  sig do
    params(
      host: ::T.untyped,
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add(host, key); end

  sig do
    params(
      source: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(source); end

  sig do
    params(
      host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def keys_for(host); end

  sig do
    params(
      hostlist: ::T.untyped,
      entries: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def known_host_hash?(hostlist, entries); end

  sig {returns(::T.untyped)}
  def source(); end

  sig do
    params(
      host: ::T.untyped,
      key: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.add(host, key, options=T.unsafe(nil)); end

  sig do
    params(
      options: ::T.untyped,
      which: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.hostfiles(options, which=T.unsafe(nil)); end

  sig do
    params(
      host: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.search_for(host, options=T.unsafe(nil)); end

  sig do
    params(
      files: ::T.untyped,
      host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.search_in(files, host); end
end

module Net::SSH::Loggable
  sig {returns(::T.untyped)}
  def debug(); end

  sig {returns(::T.untyped)}
  def error(); end

  sig {returns(::T.untyped)}
  def fatal(); end

  sig {returns(::T.untyped)}
  def info(); end

  sig {returns(::T.untyped)}
  def logger(); end

  sig do
    params(
      logger: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def logger=(logger); end

  sig {returns(::T.untyped)}
  def lwarn(); end
end

class Net::SSH::Packet < Net::SSH::Buffer
  include ::Net::SSH::Transport::Constants
  include ::Net::SSH::Authentication::Constants
  include ::Net::SSH::Connection::Constants
  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](name); end

  sig do
    params(
      payload: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(payload); end

  sig {returns(::T.untyped)}
  def type(); end

  sig do
    params(
      type: ::T.untyped,
      pairs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.register(type, *pairs); end
end

class Net::SSH::Prompt
  sig do
    params(
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(options=T.unsafe(nil)); end

  sig do
    params(
      info: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def start(info); end

  sig do
    params(
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.default(options=T.unsafe(nil)); end
end

class Net::SSH::Prompt::Prompter
  sig do
    params(
      prompt: ::T.untyped,
      echo: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ask(prompt, echo=T.unsafe(nil)); end

  sig do
    params(
      info: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(info); end

  sig {returns(::T.untyped)}
  def success(); end
end

module Net::SSH::Proxy
end

class Net::SSH::Proxy::ConnectError < Net::SSH::Proxy::Error
end

class Net::SSH::Proxy::Error < Net::SSH::Exception
end

class Net::SSH::Proxy::HTTP
  sig do
    params(
      connect_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def establish_connection(connect_timeout); end

  sig do
    params(
      proxy_host: ::T.untyped,
      proxy_port: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(proxy_host, proxy_port=T.unsafe(nil), options=T.unsafe(nil)); end

  sig do
    params(
      host: ::T.untyped,
      port: ::T.untyped,
      connection_options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open(host, port, connection_options); end

  sig {returns(::T.untyped)}
  def options(); end

  sig do
    params(
      socket: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse_response(socket); end

  sig {returns(::T.untyped)}
  def proxy_host(); end

  sig {returns(::T.untyped)}
  def proxy_port(); end
end

class Net::SSH::Proxy::UnauthorizedError < Net::SSH::Proxy::Error
end

module Net::SSH::Service
end

class Net::SSH::Service::Forward
  include ::Net::SSH::Loggable
  sig {returns(::T.untyped)}
  def active_local_sockets(); end

  sig {returns(::T.untyped)}
  def active_locals(); end

  sig {returns(::T.untyped)}
  def active_remote_destinations(); end

  sig {returns(::T.untyped)}
  def active_remotes(); end

  sig do
    params(
      channel: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def agent(channel); end

  sig do
    params(
      port: ::T.untyped,
      bind_address: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cancel_local(port, bind_address=T.unsafe(nil)); end

  sig do
    params(
      local_socket_path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cancel_local_socket(local_socket_path); end

  sig do
    params(
      port: ::T.untyped,
      host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cancel_remote(port, host=T.unsafe(nil)); end

  sig do
    params(
      session: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local(*args); end

  sig do
    params(
      local_socket_path: ::T.untyped,
      remote_socket_path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local_socket(local_socket_path, remote_socket_path); end

  sig do
    params(
      port: ::T.untyped,
      host: ::T.untyped,
      remote_port: ::T.untyped,
      remote_host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote(port, host, remote_port, remote_host=T.unsafe(nil)); end

  sig do
    params(
      port: ::T.untyped,
      host: ::T.untyped,
      remote_port: ::T.untyped,
      remote_host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote_to(port, host, remote_port, remote_host=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def session(); end
end

class Net::SSH::Service::Forward::Remote < Struct
  Elem = type_member(fixed: T.untyped)

  sig {returns(::T.untyped)}
  def host(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def host=(_); end

  sig {returns(::T.untyped)}
  def port(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def port=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::SSH::Timeout < Net::SSH::Disconnect
end

module Net::SSH::Transport
end

class Net::SSH::Transport::Algorithms
  include ::Net::SSH::Transport::Constants
  include ::Net::SSH::Loggable
  ALGORITHMS = ::T.let(nil, ::T.untyped)

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def accept_kexinit(packet); end

  sig {returns(::T.untyped)}
  def algorithms(); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def allow?(packet); end

  sig {returns(::T.untyped)}
  def compression_client(); end

  sig {returns(::T.untyped)}
  def compression_server(); end

  sig {returns(::T.untyped)}
  def encryption_client(); end

  sig {returns(::T.untyped)}
  def encryption_server(); end

  sig {returns(::T.untyped)}
  def hmac_client(); end

  sig {returns(::T.untyped)}
  def hmac_server(); end

  sig {returns(::T.untyped)}
  def host_key(); end

  sig {returns(::T.untyped)}
  def host_key_format(); end

  sig do
    params(
      session: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(session, options=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def initialized?(); end

  sig {returns(::T.untyped)}
  def kex(); end

  sig {returns(::T.untyped)}
  def language_client(); end

  sig {returns(::T.untyped)}
  def language_server(); end

  sig {returns(::T.untyped)}
  def options(); end

  sig {returns(::T.untyped)}
  def pending?(); end

  sig {returns(::T.untyped)}
  def rekey!(); end

  sig {returns(::T.untyped)}
  def session(); end

  sig {returns(::T.untyped)}
  def session_id(); end

  sig {returns(::T.untyped)}
  def start(); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.allowed_packet?(packet); end
end

module Net::SSH::Transport::CTR
  sig do
    params(
      orig: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.extended(orig); end
end

class Net::SSH::Transport::CipherFactory
  KEY_LEN_OVERRIDE = ::T.let(nil, ::T.untyped)
  SSH_TO_OSSL = ::T.let(nil, ::T.untyped)

  sig do
    params(
      name: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get(name, options=T.unsafe(nil)); end

  sig do
    params(
      name: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get_lengths(name, options=T.unsafe(nil)); end

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.supported?(name); end
end

module Net::SSH::Transport::Constants
  DEBUG = ::T.let(nil, ::T.untyped)
  DISCONNECT = ::T.let(nil, ::T.untyped)
  IGNORE = ::T.let(nil, ::T.untyped)
  KEXDH_INIT = ::T.let(nil, ::T.untyped)
  KEXDH_REPLY = ::T.let(nil, ::T.untyped)
  KEXECDH_INIT = ::T.let(nil, ::T.untyped)
  KEXECDH_REPLY = ::T.let(nil, ::T.untyped)
  KEXINIT = ::T.let(nil, ::T.untyped)
  NEWKEYS = ::T.let(nil, ::T.untyped)
  SERVICE_ACCEPT = ::T.let(nil, ::T.untyped)
  SERVICE_REQUEST = ::T.let(nil, ::T.untyped)
  UNIMPLEMENTED = ::T.let(nil, ::T.untyped)
end

module Net::SSH::Transport::HMAC
  MAP = ::T.let(nil, ::T.untyped)

  sig do
    params(
      name: ::T.untyped,
      key: ::T.untyped,
      parameters: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get(name, key=T.unsafe(nil), parameters=T.unsafe(nil)); end

  sig do
    params(
      name: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.key_length(name); end
end

class Net::SSH::Transport::HMAC::Abstract
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def digest(data); end

  sig {returns(::T.untyped)}
  def digest_class(); end

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(key=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def key(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key=(value); end

  sig {returns(::T.untyped)}
  def key_length(); end

  sig {returns(::T.untyped)}
  def mac_length(); end

  sig do
    params(
      v: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.digest_class(*v); end

  sig do
    params(
      v: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.key_length(*v); end

  sig do
    params(
      v: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.mac_length(*v); end
end

class Net::SSH::Transport::HMAC::MD5 < Net::SSH::Transport::HMAC::Abstract
end

class Net::SSH::Transport::HMAC::MD5_96 < Net::SSH::Transport::HMAC::MD5
end

class Net::SSH::Transport::HMAC::None < Net::SSH::Transport::HMAC::Abstract
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def digest(data); end
end

class Net::SSH::Transport::HMAC::RIPEMD160 < Net::SSH::Transport::HMAC::Abstract
end

class Net::SSH::Transport::HMAC::SHA1 < Net::SSH::Transport::HMAC::Abstract
end

class Net::SSH::Transport::HMAC::SHA1_96 < Net::SSH::Transport::HMAC::SHA1
end

class Net::SSH::Transport::HMAC::SHA2_256 < Net::SSH::Transport::HMAC::Abstract
end

class Net::SSH::Transport::HMAC::SHA2_256_96 < Net::SSH::Transport::HMAC::SHA2_256
end

class Net::SSH::Transport::HMAC::SHA2_512 < Net::SSH::Transport::HMAC::Abstract
end

class Net::SSH::Transport::HMAC::SHA2_512_96 < Net::SSH::Transport::HMAC::SHA2_512
end

class Net::SSH::Transport::IdentityCipher
  sig {returns(::T.untyped)}
  def self.block_size(); end

  sig {returns(::T.untyped)}
  def self.decrypt(); end

  sig {returns(::T.untyped)}
  def self.encrypt(); end

  sig {returns(::T.untyped)}
  def self.final(); end

  sig do
    params(
      v: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.iv=(v); end

  sig {returns(::T.untyped)}
  def self.iv_len(); end

  sig {returns(::T.untyped)}
  def self.name(); end

  sig {returns(::T.untyped)}
  def self.reset(); end

  sig do
    params(
      text: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.update(text); end
end

module Net::SSH::Transport::Kex
  MAP = ::T.let(nil, ::T.untyped)
end

class Net::SSH::Transport::Kex::DiffieHellmanGroup14SHA1 < Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1
  G = ::T.let(nil, ::T.untyped)
  P_r = ::T.let(nil, ::T.untyped)
  P_s = ::T.let(nil, ::T.untyped)
end

class Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1
  include ::Net::SSH::Transport::Constants
  include ::Net::SSH::Loggable
  G = ::T.let(nil, ::T.untyped)
  P_r = ::T.let(nil, ::T.untyped)
  P_s = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def algorithms(); end

  sig {returns(::T.untyped)}
  def connection(); end

  sig {returns(::T.untyped)}
  def data(); end

  sig {returns(::T.untyped)}
  def dh(); end

  sig {returns(::T.untyped)}
  def digester(); end

  sig {returns(::T.untyped)}
  def exchange_keys(); end

  sig {returns(::T.untyped)}
  def g(); end

  sig do
    params(
      algorithms: ::T.untyped,
      connection: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(algorithms, connection, data); end

  sig {returns(::T.untyped)}
  def p(); end
end

class Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1 < Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1
  KEXDH_GEX_GROUP = ::T.let(nil, ::T.untyped)
  KEXDH_GEX_INIT = ::T.let(nil, ::T.untyped)
  KEXDH_GEX_REPLY = ::T.let(nil, ::T.untyped)
  KEXDH_GEX_REQUEST = ::T.let(nil, ::T.untyped)
  MAXIMUM_BITS = ::T.let(nil, ::T.untyped)
  MINIMUM_BITS = ::T.let(nil, ::T.untyped)
end

class Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA256 < Net::SSH::Transport::Kex::DiffieHellmanGroupExchangeSHA1
  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end
end

class Net::SSH::Transport::Kex::EcdhSHA2NistP256 < Net::SSH::Transport::Kex::DiffieHellmanGroup1SHA1
  sig {returns(::T.untyped)}
  def curve_name(); end

  sig {returns(::T.untyped)}
  def digester(); end

  sig {returns(::T.untyped)}
  def ecdh(); end

  sig do
    params(
      algorithms: ::T.untyped,
      connection: ::T.untyped,
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(algorithms, connection, data); end
end

class Net::SSH::Transport::Kex::EcdhSHA2NistP384 < Net::SSH::Transport::Kex::EcdhSHA2NistP256
  sig {returns(::T.untyped)}
  def curve_name(); end

  sig {returns(::T.untyped)}
  def digester(); end
end

class Net::SSH::Transport::Kex::EcdhSHA2NistP521 < Net::SSH::Transport::Kex::EcdhSHA2NistP256
  sig {returns(::T.untyped)}
  def curve_name(); end

  sig {returns(::T.untyped)}
  def digester(); end
end

module Net::SSH::Transport::KeyExpander
  sig do
    params(
      bytes: ::T.untyped,
      start: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.expand_key(bytes, start, options=T.unsafe(nil)); end
end

class Net::SSH::Transport::OpenSSLAESCTR < SimpleDelegator
  sig {returns(::T.untyped)}
  def block_size(); end

  sig {returns(::T.untyped)}
  def class(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def clone(*_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def define_singleton_method(*_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def display(*_); end

  sig {returns(::T.untyped)}
  def dup(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enum_for(*_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extend(*_); end

  sig {returns(::T.untyped)}
  def freeze(); end

  sig {returns(::T.untyped)}
  def frozen?(); end

  sig do
    params(
      original: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(original); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def instance_of?(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def instance_variable_defined?(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def instance_variable_get(_); end

  sig do
    params(
      _: ::T.untyped,
      _1: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def instance_variable_set(_, _1); end

  sig {returns(::T.untyped)}
  def instance_variables(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def is_a?(_); end

  sig {returns(::T.untyped)}
  def itself(); end

  sig do
    params(
      iv_s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def iv=(iv_s); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def kind_of?(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def method(_); end

  sig do
    params(
      all: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def methods(all=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def nil?(); end

  sig {returns(::T.untyped)}
  def object_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def private_methods(*_); end

  sig do
    params(
      all: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def protected_methods(all=T.unsafe(nil)); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def public_method(_); end

  sig do
    params(
      all: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def public_methods(all=T.unsafe(nil)); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def public_send(*_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove_instance_variable(_); end

  sig {returns(::T.untyped)}
  def reset(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def respond_to?(*_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send(*_); end

  sig {returns(::T.untyped)}
  def singleton_class(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def singleton_method(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def singleton_methods(*_); end

  sig {returns(::T.untyped)}
  def taint(); end

  sig {returns(::T.untyped)}
  def tainted?(); end

  sig {returns(::T.untyped)}
  def tap(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to_enum(*_); end

  sig {returns(::T.untyped)}
  def trust(); end

  sig {returns(::T.untyped)}
  def untaint(); end

  sig {returns(::T.untyped)}
  def untrust(); end

  sig {returns(::T.untyped)}
  def untrusted?(); end

  sig {returns(::T.untyped)}
  def self.block_size(); end
end

module Net::SSH::Transport::PacketStream
  include ::Net::SSH::BufferedIo
  include ::Net::SSH::Loggable
  PROXY_COMMAND_HOST_IP = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def available_for_read?(); end

  sig {returns(::T.untyped)}
  def cleanup(); end

  sig {returns(::T.untyped)}
  def client(); end

  sig {returns(::T.untyped)}
  def client_name(); end

  sig do
    params(
      payload: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enqueue_packet(payload); end

  sig {returns(::T.untyped)}
  def hints(); end

  sig {returns(::T.untyped)}
  def if_needs_rekey?(); end

  sig {returns(::T.untyped)}
  def initialize_ssh(); end

  sig do
    params(
      mode: ::T.untyped,
      timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def next_packet(mode=T.unsafe(nil), timeout=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def peer_ip(); end

  sig {returns(::T.untyped)}
  def poll_next_packet(); end

  sig do
    params(
      payload: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_packet(payload); end

  sig {returns(::T.untyped)}
  def server(); end

  sig do
    params(
      object: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.extended(object); end
end

class Net::SSH::Transport::ServerVersion
  include ::Net::SSH::Loggable
  PROTO_VERSION = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def header(); end

  sig do
    params(
      socket: ::T.untyped,
      logger: ::T.untyped,
      timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(socket, logger, timeout=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def version(); end
end

class Net::SSH::Transport::Session
  include ::Net::SSH::Transport::Constants
  include ::Net::SSH::Loggable
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def algorithms(); end

  sig {returns(::T.untyped)}
  def close(); end

  sig {returns(::T.untyped)}
  def closed?(); end

  sig do
    params(
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def configure_client(options=T.unsafe(nil)); end

  sig do
    params(
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def configure_server(options=T.unsafe(nil)); end

  sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enqueue_message(message); end

  sig do
    params(
      which: ::T.untyped,
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def hint(which, value=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def host(); end

  sig {returns(::T.untyped)}
  def host_as_string(); end

  sig {returns(::T.untyped)}
  def host_key_verifier(); end

  sig {returns(::T.untyped)}
  def host_keys(); end

  sig do
    params(
      host: ::T.untyped,
      options: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(host, options=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def next_message(); end

  sig {returns(::T.untyped)}
  def options(); end

  sig {returns(::T.untyped)}
  def peer(); end

  sig do
    params(
      mode: ::T.untyped,
      consume_queue: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def poll_message(mode=T.unsafe(nil), consume_queue=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def port(); end

  sig do
    params(
      packet: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def push(packet); end

  sig {returns(::T.untyped)}
  def queue(); end

  sig {returns(::T.untyped)}
  def rekey!(); end

  sig {returns(::T.untyped)}
  def rekey_as_needed(); end

  sig do
    params(
      message: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_message(message); end

  sig {returns(::T.untyped)}
  def server_version(); end

  sig do
    params(
      service: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def service_request(service); end

  sig {returns(::T.untyped)}
  def shutdown!(); end

  sig {returns(::T.untyped)}
  def socket(); end

  sig {returns(::T.untyped)}
  def wait(); end
end

class Net::SSH::Transport::Session::CompatibleVerifier
  sig do
    params(
      verifier: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(verifier); end

  sig do
    params(
      arguments: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(arguments); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_signature(&block); end
end

class Net::SSH::Transport::State
  sig {returns(::T.untyped)}
  def block_size(); end

  sig {returns(::T.untyped)}
  def blocks(); end

  sig {returns(::T.untyped)}
  def cipher(); end

  sig {returns(::T.untyped)}
  def cleanup(); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def compress(data); end

  sig {returns(::T.untyped)}
  def compression(); end

  sig {returns(::T.untyped)}
  def compression?(); end

  sig {returns(::T.untyped)}
  def compression_level(); end

  sig {returns(::T.untyped)}
  def compressor(); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def decompress(data); end

  sig {returns(::T.untyped)}
  def decompressor(); end

  sig {returns(::T.untyped)}
  def final_cipher(); end

  sig {returns(::T.untyped)}
  def hmac(); end

  sig do
    params(
      packet_length: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def increment(packet_length); end

  sig do
    params(
      socket: ::T.untyped,
      role: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(socket, role); end

  sig {returns(::T.untyped)}
  def max_blocks(); end

  sig do
    params(
      max_blocks: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def max_blocks=(max_blocks); end

  sig {returns(::T.untyped)}
  def max_packets(); end

  sig do
    params(
      max_packets: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def max_packets=(max_packets); end

  sig {returns(::T.untyped)}
  def needs_rekey?(); end

  sig {returns(::T.untyped)}
  def packets(); end

  sig {returns(::T.untyped)}
  def rekey_limit(); end

  sig do
    params(
      rekey_limit: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rekey_limit=(rekey_limit); end

  sig {returns(::T.untyped)}
  def reset!(); end

  sig {returns(::T.untyped)}
  def role(); end

  sig {returns(::T.untyped)}
  def sequence_number(); end

  sig do
    params(
      values: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set(values); end

  sig {returns(::T.untyped)}
  def socket(); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def update_cipher(data); end
end

module Net::SSH::Verifiers
end

class Net::SSH::Verifiers::AcceptNew < Net::SSH::Verifiers::Always
  sig do
    params(
      arguments: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(arguments); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_signature(&block); end
end

class Net::SSH::Verifiers::AcceptNewOrLocalTunnel < Net::SSH::Verifiers::AcceptNew
  sig do
    params(
      arguments: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(arguments); end
end

class Net::SSH::Verifiers::Always
  sig do
    params(
      arguments: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(arguments); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_signature(&block); end
end

class Net::SSH::Verifiers::Never
  sig do
    params(
      arguments: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify(arguments); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_signature(&block); end
end

class Net::SSH::Version
  include ::Comparable
  CURRENT = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)

  sig do
    params(
      version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <=>(version); end

  sig do
    params(
      major: ::T.untyped,
      minor: ::T.untyped,
      tiny: ::T.untyped,
      pre: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(major, minor, tiny, pre=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def major(); end

  sig {returns(::T.untyped)}
  def minor(); end

  sig {returns(::T.untyped)}
  def tiny(); end

  sig {returns(::T.untyped)}
  def to_i(); end

  sig {returns(::T.untyped)}
  def to_s(); end

  sig do
    params(
      major: ::T.untyped,
      minor: ::T.untyped,
      tiny: ::T.untyped,
      pre: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](major, minor, tiny, pre=T.unsafe(nil)); end
end

# The writer adapter class
class Net::WriteAdapter
  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(str); end

  sig do
    params(
      socket: ::T.untyped,
      method: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(socket, method); end

  sig {returns(::T.untyped)}
  def inspect(); end

  # Alias for:
  # [`write`](https://docs.ruby-lang.org/en/2.6.0/Net/WriteAdapter.html#method-i-write)
  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def print(str); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def printf(*args); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def puts(str=T.unsafe(nil)); end

  # Also aliased as:
  # [`print`](https://docs.ruby-lang.org/en/2.6.0/Net/WriteAdapter.html#method-i-print)
  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(str); end
end
