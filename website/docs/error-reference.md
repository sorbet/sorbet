---
id: error-reference
title: Sorbet Error Reference
sidebar_label: Error Reference
---

This is one of three docs aimed at helping answer common questions about Sorbet:

1.  [Troubleshooting](troubleshooting.md)
1.  [Frequently Asked Questions](faq.md)
1.  [Sorbet Error Reference](error-reference.md) (this doc)

This page contains tips and tricks for common errors from `sorbet`. Note: this
list is not exhaustive! Some errors are very context dependent to solve, and
some error codes are very uncommon. Contributions to this list are welcome!


## 1001

Sorbet has crashed. Please [report an issue]!

## 2001

There was a Ruby syntax error. Sorbet was unable to parse the source code. If
you encounter this error but your code is accepted by Ruby itself, this is a bug
in our parser; please [report an issue] to us so we can address it.


## 4002

Sorbet requires that every `include` references a constant literal. For example,
this is an error, even in `# typed: false` files:

```ruby
module A; end
module B; end

def x
  rand.round == 0 ? A : B
end

class Main
  include x  # error: `include` must be passed a constant literal
end
```

Non-constant literals make it hard to impossible to determine the complete
inheritance hierarchy in a codebase. Sorbet must know the complete inheritance
hierarchy of a codebase in order to check a variable is a valid instance of a
type.

It is possible to silence this error, but it should be done with **utmost
caution**, as Sorbet will fail in strange ways and make far less accurate
predictions about a codebase. To silence this error, use `T.unsafe`:

```ruby
module A; end
module B; end

def x
  rand.round == 0 ? A : B
end

class Main
  T.unsafe(self).include x
end
```


## 4010

There are multiple definitions for a method. Having multiple definitions for a
method is problematic, because it can make a codebase's behavior dependent on
the order in which files are loaded.

The only way to silence this error currently is to make the offending file as `#
typed: false`.


## 4015

This error usually comes when a class or module is dynamically defined and
stored into a constant, like this:

```ruby
A = ...
A::B = 1
```

where `...` is some expression which computes a class or module. Sorbet can't
know statically what this `...` code does (and for example even if could assume
that it's defining a class, Sorbet can't know what methods or constants it has).
Therefore, Sorbet does not support this pattern.


## 5002

This means that the typechecker has been unable to resolve a reference to a
constant (e.g. a Ruby class). Most commonly, this indicates that there's a typo.

First, try confirming whether the code runs successfully. Does the code raise an
"uninitialized constant" error when run? If so, Sorbet caught a bug! Try finding
out why that constant is actually uninitialized.

If it isn't a typo, then there are a few other things to look at. If it looks
like the constant is related to a gem, maybe one of these helps:

- Is it coming from a gem? Sorbet does not look through the gems' source code.
  Instead, there must be an `*.rbi` file for this gem. Try finding the `*.rbi`
  corresponding to this gem, and searching through it for the constant. If it's
  not there, consider asking the Developer Productivity team at your company why
  the gem's `*.rbi` file is missing some constants.

  At Stripe, gem `*.rbi` files are in `sorbet/shims/autogenerated/gems/`.

- If the gem was recently updated, it's `*.rbi` might need to be regenerated.
  At Stripe, each gem has a line at the top which can be copy / pasted to
  re-generate the file when the underlying gem has changed.

- Sometimes gems register that their constants should be autoloaded. If that's
  the case for this constant, make sure that the `*.rbi` generation script
  explicitly references the constant somewhere to force it to be loaded. This
  will make the constant visible via runtime reflection.

- When deleting constants, sometimes they are still referenced from an
  autogenerated `*.rbi` file. If that's the case, consider deleting the constant
  or regenerating the file.

Another thing it could be: Sorbet explicitly does not support resolving
constants through ancestors (both mixins or superclasses).

-   Concretely, here's an example of code rejected and accepted by Sorbet:

    ```ruby
    class Parent
      MY_CONST = 91
    end

    class Child < Parent; end

    Child::MY_CONST    # error
    Parent::MY_CONST   # ok
    ```

-   Alternatively, if it's much more preferable to access the constant on the
    child, we can set up an explicit alias:

    ```ruby
    class Parent
      MY_CONST = 91
    end

    class Child < Parent
      MY_CONST = Parent::MY_CONST
    end

    Child::MY_CONST    # ok
    Parent::MY_CONST   # ok
    ```

## 5028

In `# typed: strict` files, Sorbet requires that all constants are annotated
with a `T.let`.

For how to fix, see [Strict Mode](strict.md).

See also: [6002](#6002), [7017](#7017).

## 5034

Sorbet does not support creating normal Ruby constant aliases to type aliases.
Once a type alias is created, all subsequent aliases must also be type aliases.

Concretely, this is not allowed:

```ruby
A = T.type_alias(Integer)
B = A # error: Reassigning a type alias is not allowed
```

while this is:

```ruby
A = T.type_alias(Integer)
B = T.type_alias(A)
```

(Why? This is due to design tradeoffs to enforce stronger internal invariants.
Basically, Sorbet can emit more reliable warnings when users declare their
intent to create a new type alias.)

## 6002

In `# typed: strict` files, Sorbet requires that all instance and class
variables are annotated with a `T.let`.

For how to fix, see [Strict Mode](strict.md).

See also: [5028](#5028), [7017](#7017).


## 7001

Sorbet does not allow reassigning a variable to a different type within a loop
or block. (Note that we model blocks similarly to loops, as in general they may
execute 0, 1, or more times). Due to implementation constraints, Sorbet does not
permit this behavior.

A prototypical example of code that might trigger this is code that sets a
variable to `nil`, and then updates it if some value is found inside a loop:

```ruby
found = nil

list.each do |elem|
  found = elem if want?(elem)
end
```

In most cases, we can fix this error by declaring the type of the loop variable
outside the loop using `T.let`:

```ruby
# This is a type annotation that explicitly widens the type:
found = T.let(nil, T.nilable(String))

list.each do |elem|
  found = elem if want?(elem)
end
```


## 7002

This is a standard type mismatch. A method's `sig` declares one type, but the
actual value didn't match. For example:

```ruby
'str' + :sym  # error: `Symbol(:"sym")` doesn't match `String` for argument `arg0`
```

Even still, sometimes these errors can be rather confusing. Consider using
[`T.reveal_type`](troubleshooting.md) to pin down the origin of why Sorbet
thinks the types are what it says.

**Why does Sorbet think this is `nil`? I just checked that it's not!**

That's a [great question](flow-sensitive#limitations-of-flow-sensitivity), and
probably the most common question people have when using Sorbet!

It's answered here:
[Limitations of flow-sensitivity](flow-sensitive#limitations-of-flow-sensitivity)

## 7003

This error indicates a call to a method we believe does not exist (a la Ruby's
`NoMethodError` exception). Some steps to debug:

1.  Double check that the code actually runs, either in the REPL, in CI, or with
    manual tests. If the method doesn't actually exist when run, Sorbet caught a
    bug!

1.  Even if the method exists when run, Sorbet still might report an error
    because the method won't **always** be there. For example, maybe sometimes
    the value is [nilable](nilable-types.md), or we have a
    [union](union-types.md) of a handful of different types.

1.  Many times, methods are defined dynamically in Ruby. Sorbet cannot see
    methods defined with `define_method`. Sorbet also can't see methods defined
    using Ruby's `included` + `other.extend(self)` pattern. For such dynamically
    defined methods, Sorbet requires `*.rbi` files which define the method
    statically.

    See the [RBI](rbi.md) docs for how to regenerate the `*.rbi` files.

1.  Sorbet will complain about this code:

    ```ruby
    module MyModule; end

    sig {params(x: MyModule).void}
    def foo(x)
      x.nil? # error: Method `nil?` does not exist on `MyModule`
    end
    ```

    The `nil?` method is defined on `Kernel` in Ruby. `Kernel` is included in
    `Object` (which classes default to inheriting from), but not on
    `BasicObject` (which classes can optionally inherit from).

    The solution is to `include Kernel` in our module:

    ```ruby
    module MyModule
      include Kernel
    end
    ```

1.  Sorbet will complain about this code:

    ```ruby
    module MyModule
      def foo; puts 'hello'; end
    end
    ```

    The issue is similar to the above: `puts` is defined on `Kernel`, which is
    not necessarily included in our module. For this situation, there are
    actually two fixes:

    ```ruby
    # Option 1: include Kernel
    module MyModule
      include Kernel

      def foo; puts 'hello'; end
    end
    ```

    ```ruby
    # Option 2: Kernel.puts
    module MyModule
      def foo; Kernel.puts 'hello'; end
    end
    ```

## 7014

Sorbet has a special method called `T.reveal_type` which can be useful for
debugging. `T.reveal_type(expr)` will report an error that shows what the static
component of Sorbet thinks the result type of `expr` is.

Making this an error is nice for two reasons:

- It makes our internal implementation easier ðŸ˜… We don't have some special-case
  messages and then error messages. The only thing Sorbet prints under normal
  circumstances are error messages.

- It serves as a reminder to remove `T.reveal_type` before committing a change.
  Since it's a proper error, Sorbet will exit with non-zero status until it's
  removed.

For more information, see [Troubleshooting](troubleshooting.md).

> Looking for how to assert that an expression has a certain type? Check out
> [Type Assertions](type-assertions.md).


## 7017

In typed: strict files, Sorbet requires that all methods are annotated with a
`sig`. In a `# typed: true` file Sorbet implicitly assumes that definitions
without types are `T.untyped`, but in a `# typed: strict` file, Sorbet will no
longer make this implicit assumption.

You can still add a `sig` which declares the arguments or return as `T.untyped`, so
`# typed: strict` does not outright ban `T.untyped`. The upside is that usage of
`T.untyped` is more explicit, which makes it easier to drive the number of
occurrences down. If you're seeing this warning, there's no time like the
present to add proper types to your public-facing API (i.e., your top-level
constant and method definitions)!

For how to fix, see [Method Signatures](sigs.md).

See also: [5028](#5028), [6002](#6002).

## 7019

Sorbet does not have great support for splats right now.

In general, when considering taking a variable number of arguments, consider
instead taking a single argument that's an array instead of a "rest" arg:

```ruby
# ----- AVOID THIS ----------------------------
sig {params(xs: Integer).void}
def foo(*xs); end

xs = Array.new(3) {|i| i}
foo(*xs)
# ---------------------------------------------

# ----- Do this instead -----------------------

sig {params(ys: T::Array[Integer]).void}
def bar(ys); end

ys = Array.new(3) {|i| i}
bar(ys)
# ---------------------------------------------
```

If it is not possible to refactor the code, the current work around is to use
replace `*xs` with `*T.unsafe(xs)`:


```ruby
# ----- WORST CASE ----------------------------
# Prefer the solution described above

sig {params(xs: Integer).void}
def foo(*xs); end

xs = Array.new(3) {|i| i}
foo(*T.unsafe(xs))
# ---------------------------------------------
```

## 7021

The method called declares a block parameter that is not `T.nilable`,
but a block was not passed when it was called.

This can be fixed by either passing a block to the method, or changing the method's
signature for the block parameter from `T.proc...` to `T.nilable(T.proc...)` (and then
changing the method to deal with a nilable block parameter).

## 7023

This error occurs when a method is passed in a `Proc` object that Sorbet does not
know the arity for statically.

One instance where this can happen is when using `method`, since the arity of method
corresponding to the symbol is unknown. This can be fixed by passing in a block with the correct arity:

```ruby
# typed: strict

extend T::Sig

sig {params(blk: T.proc.params(arg0: String).void).void}
def foo(&blk)
end

# ----- AVOID THIS ----------------------------
foo(&method(:puts))
# ---------------------------------------------

# ----- Do this instead -----------------------
foo do |arg0|
    method(:puts).call(arg0)
end
# ---------------------------------------------
```

## 7024

This error occurs when a generic argument is passed in as a block parameter.

In `# typed: strict` files, using a parameter from a method that does not have a signature will
cause this issue to be reported. Adding a signature to the method will fix the issue.

```ruby
# typed: strict

extend T::Sig

# ----- This will error -----------------------
def foo(&blk)
    proc(&blk)
end
# ---------------------------------------------

# ----- This will not error -------------------
sig {params(blk: T.untyped).returns(T.untyped)}
def bar(&blk)
    proc(&blk)
end
# ---------------------------------------------
```


[report an issue]: https://github.com/stripe/sorbet/issues
