#include "core/Files.h"
#include "core/Context.h"
#include "core/GlobalState.h"
#include <vector>

#include "absl/strings/match.h"

template class std::vector<std::shared_ptr<sorbet::core::File>>;
template class std::shared_ptr<sorbet::core::File>;
using namespace std;

namespace sorbet::core {

vector<int> findLineBreaks(string_view s) {
    vector<int> res;
    int i = -1;
    res.emplace_back(-1);
    for (auto c : s) {
        i++;
        if (c == '\n') {
            res.emplace_back(i);
        }
    }
    res.emplace_back(i);
    return res;
}

StrictLevel fileSigil(string_view source) {
    /*
     * StrictLevel::None: <none>
     * StrictLevel::Stripe: # typed: false
     * StrictLevel::Typed: # typed: true
     * StrictLevel::Strict: # typed: strict
     * StrictLevel::String: # typed: strong
     * StrictLevel::Autogenerated: # typed: autogenerated
     */
    size_t start = 0;
    while (true) {
        start = source.find("typed:", start);
        if (start == string_view::npos) {
            return StrictLevel::None;
        }
        start += 6;
        while (start < source.size() && source[start] == ' ') {
            ++start;
        }

        if (start >= source.size()) {
            return StrictLevel::None;
        }
        auto end = start + 1;
        while (end < source.size() && source[end] != ' ' && source[end] != '\n') {
            ++end;
        }

        string_view suffix = source.substr(start, end - start);
        if (suffix == "ignore") {
            return StrictLevel::Ignore;
        } else if (suffix == "false") {
            return StrictLevel::Stripe;
        } else if (suffix == "true") {
            return StrictLevel::Typed;
        } else if (suffix == "strict") {
            return StrictLevel::Strict;
        } else if (suffix == "strong") {
            return StrictLevel::Strong;
        } else if (suffix == "autogenerated") {
            return StrictLevel::Autogenerated;
        } else {
            // TODO(nelhage): We should report an error here to help catch
            // typos. This would require refactoring so this function has
            // access to GlobalState or can return errors to someone who
            // does.
        }

        start = end;
    }
}

File::File(string &&path_, string &&source_, Type sourceType)
    : sourceType(sourceType), path_(path_), source_(source_), globalStateHash(GlobalState::HASH_STATE_NOT_COMPUTED),
      originalSigil(fileSigil(this->source_)), strictLevel(originalSigil) {}

unique_ptr<File> File::deepCopy(GlobalState &gs) const {
    string sourceCopy = source_;
    string pathCopy = path_;
    auto ret = make_unique<File>(move(pathCopy), move(sourceCopy), sourceType);
    ret->lineBreaks_ = lineBreaks_;
    ret->minErrorLevel_ = minErrorLevel_;
    ret->globalStateHash = globalStateHash.load();
    ret->strictLevel = strictLevel;
    return ret;
}

optional<unsigned int> File::getDefinitionHash() const {
    auto current = globalStateHash.load();
    if (current != GlobalState::HASH_STATE_NOT_COMPUTED) {
        return current;
    }
    return nullopt;
}

void File::setDefinitionHash(unsigned int hash) const {
    auto current = globalStateHash.load();
    while (true) {
        if (current != GlobalState::HASH_STATE_NOT_COMPUTED) {
            ENFORCE(current == hash);
        } else {
            if (globalStateHash.compare_exchange_weak(current, hash)) {
                return;
            }
        }
    }
}

FileRef::FileRef(unsigned int id) : _id(id) {
    ENFORCE(((u2)id) == id, "FileRef overflow. Do you have 2^16 files?");
}

const File &FileRef::data(const GlobalState &gs) const {
    ENFORCE(gs.files[_id]->sourceType != File::TombStone);
    ENFORCE(gs.files[_id]->sourceType != File::NotYetRead);
    return dataAllowingUnsafe(gs);
}

File &FileRef::data(GlobalState &gs) const {
    ENFORCE(gs.files[_id]->sourceType != File::TombStone);
    ENFORCE(gs.files[_id]->sourceType != File::NotYetRead);
    return dataAllowingUnsafe(gs);
}

const File &FileRef::dataAllowingUnsafe(const GlobalState &gs) const {
    ENFORCE(_id < gs.filesUsed());
    return *(gs.files[_id]);
}

File &FileRef::dataAllowingUnsafe(GlobalState &gs) const {
    ENFORCE(_id < gs.filesUsed());
    return *(gs.files[_id]);
}

string_view File::path() const {
    return this->path_;
}

string_view File::source() const {
    ENFORCE(this->sourceType != Type::TombStone);
    ENFORCE(this->sourceType != File::NotYetRead);
    return this->source_;
}

StrictLevel File::minErrorLevel() const {
    return minErrorLevel_;
}

bool File::isPayload() const {
    return sourceType == Type::PayloadGeneration || sourceType == Type::Payload;
}

bool File::isRBI() const {
    return absl::EndsWith(path(), ".rbi");
}

vector<int> &File::lineBreaks() const {
    ENFORCE(this->sourceType != Type::TombStone);
    ENFORCE(this->sourceType != File::NotYetRead);
    auto ptr = atomic_load(&lineBreaks_);
    if (ptr) {
        return *ptr;
    } else {
        auto my = make_shared<vector<int>>(findLineBreaks(this->source_));
        atomic_compare_exchange_weak(&lineBreaks_, &ptr, my);
        return lineBreaks();
    }
}

int File::lineCount() const {
    return lineBreaks().size() - 1;
}

string_view File::getLine(int i) {
    ENFORCE(i < lineBreaks().size());
    ENFORCE(i > 0);
    auto start = lineBreaks().at(i - 1) + 1;
    auto end = lineBreaks().at(i);
    return source().substr(start, end - start);
}

} // namespace sorbet::core
