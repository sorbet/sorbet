#include <ruby_parser/driver.hh>
#include <ruby_parser/lexer.hh>

// Autogenerated code
#include "parser/parser/typedruby_debug_bison.h"
#include "parser/parser/typedruby_release_bison.h"

namespace ruby_parser {

base_driver::base_driver(ruby_version version, std::string_view source, sorbet::StableStringStorage<> &scratch,
                         const struct builder &builder, bool traceLexer, bool indentationAware)
    : build(builder), lex(diagnostics, version, source, scratch, traceLexer), pending_error(false), def_level(0),
      ast(nullptr), indentationAware(indentationAware) {}

const char *const base_driver::token_name(token_type type) {
    // We have two tokens matching `..` and `...`. Bison won't let us specify the same
    // human-readable string for both of them (because bison lets you use those names like ".."
    // directly in the productcion rules, which would lead to ambiguity).
    //
    // This hack allows to display the real token string instead of tBDOT2/tBDOT3 in parsing errors.
    switch (type) {
        case token_type::kDO_COND:
            return "\"do\"";
        case token_type::kDO_BLOCK:
            return "\"do\"";
        case token_type::kDO_LAMBDA:
            return "\"do\"";
        case token_type::kIF_MOD:
            return "\"if\"";
        case token_type::kUNLESS_MOD:
            return "\"unless\"";
        case token_type::kWHILE_MOD:
            return "\"while\"";
        case token_type::kUNTIL_MOD:
            return "\"until\"";
        case token_type::kRESCUE_MOD:
            return "\"rescue\"";
        case token_type::tPOW:
            return "\"**\"";
        case token_type::tCOLON3:
            return "\"::\"";
        case token_type::tLPAREN2:
            return "\"(\"";
        case token_type::tLPAREN_ARG:
            return "\"(\"";
        case token_type::tLBRACK2:
            return "\"[\"";
        case token_type::tLBRACE_ARG:
            return "\"{\"";
        case token_type::tSTAR2:
            return "\"*\"";
        case token_type::tAMPER2:
            return "\"&\"";
        case token_type::tLCURLY:
            return "\"{\"";
        case token_type::tRCURLY:
            return "\"}\"";
        case token_type::tUMINUS:
            return "\"-\"";
        case token_type::tUPLUS:
            return "\"+\"";
        case token_type::tBDOT2:
            return "\"..\"";
        case token_type::tBDOT3:
            return "\"...\"";
        default:
            return this->yytname[this->yytranslate(static_cast<int>(type))];
    }
}

void base_driver::rewind_and_reset(size_t newPos) {
    this->clear_lookahead();
    this->lex.rewind_and_reset_to_expr_end(newPos);
}

void base_driver::rewind_if_dedented(token_t token, token_t kEND, bool force) {
    if ((force || this->indentationAware) && this->lex.compare_indent_level(token, kEND) < 0) {
        this->rewind_and_reset(kEND->start());
        const char *token_str_name = this->token_name(token->type());
        this->diagnostics.emplace_back(dlevel::ERROR, dclass::DedentedEnd, token, token_str_name, kEND);
    }
}

typedruby_release27::typedruby_release27(std::string_view source, sorbet::StableStringStorage<> &scratch,
                                         const struct builder &builder, bool traceLexer, bool indentationAware)
    : base_driver(ruby_version::RUBY_27, source, scratch, builder, traceLexer, indentationAware) {}

ForeignPtr typedruby_release27::parse(SelfPtr self, bool) {
    bison::typedruby_release27::parser p(*this, self);
    p.parse();
    return ast;
}

typedruby_debug27::typedruby_debug27(std::string_view source, sorbet::StableStringStorage<> &scratch,
                                     const struct builder &builder, bool traceLexer, bool indentationAware)
    : base_driver(ruby_version::RUBY_27, source, scratch, builder, traceLexer, indentationAware) {}

ForeignPtr typedruby_debug27::parse(SelfPtr self, bool traceParser) {
    bison::typedruby_debug27::parser p(*this, self);
    p.set_debug_level(traceParser ? 1 : 0);
    p.parse();
    return ast;
}

} // namespace ruby_parser
