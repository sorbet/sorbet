#ifndef SORBET_PARSER_PRISM_TRANSLATOR_H
#define SORBET_PARSER_PRISM_TRANSLATOR_H

#include "absl/types/span.h"
#include "core/errors/parser.h"
#include "parser/Node.h" // To clarify: these are Sorbet Parser nodes, not Prism ones.
#include "parser/prism/Parser.h"
#include <memory>

extern "C" {
#include "prism.h"
}

namespace sorbet::parser::Prism {

class ExprOnly;

// Enum to specify the type of compound assignment operation.
// Used by the desugar*OpAssign functions to determine the appropriate desugaring strategy.
enum class OpAssignKind { And, Or, Operator };

class Translator final {
    const Parser &parser;
    // This context holds a reference to the GlobalState allocated up the call stack, which is why we don't allow
    // Translator objects to be copied or moved.
    core::MutableContext ctx;

    // The errors that were found by Prism during parsing
    absl::Span<const ParseError> parseErrors;

    // When true, desugar less aggressively so that refactoring actions operate on the code that was actually written,
    // instead of synthetic code that was generated by the desugarer.
    const bool preserveConcreteSyntax;

    // Unique counters used to create synthetic names via `ctx.state.freshNameUnique`.
    // - The storage integers either store an "active" count used by a translator and some of its children,
    //   or a dummy value.
    // - The pointer variables point to the "active" count for each translator,
    //   which is either pointing to its own storage, or to a parent's storage.
    uint16_t parserUniqueCounterStorage;  // Minics the `Builder::Impl.uniqueCounter_` in `parser/Builder.cc`
    uint32_t desugarUniqueCounterStorage; // Minics the `DesugarContext.uniqueCounter`  in `ast/desugar/Desugar.cc`
    uint16_t &parserUniqueCounter;        // Points to the active `parserUniqueCounterStorage`
    uint32_t &desugarUniqueCounter;       // Points to the active `desugarUniqueCounterStorage`

    // Context variables
    const core::LocOffsets enclosingMethodLoc; // The location of the method we're in, or `none()`
    const core::NameRef enclosingMethodName;   // The name of the method we're in, or `noName()`
    core::LocOffsets &enclosingBlockParamLoc;  // The loc of the `yield` or `block_given?` that triggered a block param
                                               // to be created, or else the original location of the block parameter.
    core::NameRef &enclosingBlockParamName;    // The name of the block param of the method we're in, or `noName()`
    const bool isInModule = false;   // True if we're in a Module definition. False for classes and singleton classes
    const bool isInAnyBlock = false; // True if we're in a `{ }`/`do end` block

    Translator(Translator &&) = delete;                 // Move constructor
    Translator(const Translator &) = delete;            // Copy constructor
    Translator &operator=(Translator &&) = delete;      // Move assignment
    Translator &operator=(const Translator &) = delete; // Copy assignment
public:
    Translator(const Parser &parser, core::MutableContext ctx, absl::Span<const ParseError> parseErrors,
               bool preserveConcreteSyntax, core::LocOffsets &enclosingBlockParamLoc,
               core::NameRef &enclosingBlockParamName)
        : parser(parser), ctx(ctx), parseErrors(parseErrors), preserveConcreteSyntax(preserveConcreteSyntax),
          parserUniqueCounterStorage(1), desugarUniqueCounterStorage(1),
          parserUniqueCounter(this->parserUniqueCounterStorage),
          desugarUniqueCounter(this->desugarUniqueCounterStorage), enclosingBlockParamLoc(enclosingBlockParamLoc),
          enclosingBlockParamName(enclosingBlockParamName) {}

    ast::ExpressionPtr desugar(pm_node_t *node);
    ast::ExpressionPtr desugarNullable(pm_node_t *node);

    // Translates the given AST from Prism's node types into the equivalent AST in Sorbet's legacy parser node types.
    std::unique_ptr<parser::Node> translate_TODO(pm_node_t *node);

private:
    // This private constructor is used for creating child translators with modified context.
    // uniqueCounterStorage is passed as a dummy value and is never used
    Translator(const Translator &parent, bool resetDesugarUniqueCounter, core::LocOffsets enclosingMethodLoc,
               core::NameRef enclosingMethodName, core::LocOffsets &enclosingBlockParamLoc,
               core::NameRef &enclosingBlockParamName, bool isInModule, bool isInAnyBlock)
        : parser(parent.parser), ctx(parent.ctx), parseErrors(parent.parseErrors),
          preserveConcreteSyntax(parent.preserveConcreteSyntax), parserUniqueCounterStorage(9999),
          desugarUniqueCounterStorage(resetDesugarUniqueCounter ? 1 : 999999),
          parserUniqueCounter(parent.parserUniqueCounter),
          desugarUniqueCounter(resetDesugarUniqueCounter ? this->desugarUniqueCounterStorage
                                                         : parent.desugarUniqueCounter),
          enclosingMethodLoc(enclosingMethodLoc), enclosingMethodName(enclosingMethodName),
          enclosingBlockParamLoc(enclosingBlockParamLoc), enclosingBlockParamName(enclosingBlockParamName),
          isInModule(isInModule), isInAnyBlock(isInAnyBlock) {}

    ast::ExpressionPtr make_unsupported_node(core::LocOffsets loc, std::string_view nodeName) const;

    core::LocOffsets translateLoc(pm_location_t loc) const;
    core::LocOffsets translateLoc(const uint8_t *start, const uint8_t *end) const;

    // Collect pattern variable assignments from a prism pattern node
    void collectPatternMatchingVarsPrism(ast::InsSeq::STATS_store &vars, pm_node_t *node);

    std::tuple<ast::MethodDef::PARAMS_store, ast::InsSeq::STATS_store, core::LocOffsets /* enclosingBlockParamLoc */,
               core::NameRef /* enclosingBlockParamName */>
    desugarParametersNode(pm_parameters_node *paramsNode, core::LocOffsets location,
                          absl::Span<pm_node_t *> blockLocalVariables = {});

    core::LocOffsets findItParamUsageLoc(pm_statements_node *statements);

    std::array<core::LocOffsets, 9> findNumberedParamsUsageLocs(core::LocOffsets loc, pm_statements_node *statements,
                                                                uint8_t maxParamNumber);

    ast::MethodDef::PARAMS_store translateNumberedParametersNode(pm_numbered_parameters_node *numberedParamsNode,
                                                                 pm_statements_node_t *statements);

    // Method call helpers
    class DesugaredBlockArgument;

    DesugaredBlockArgument desugarBlock(pm_node_t *block, pm_arguments_node *otherArgs, pm_location_t parentLoc);

    ast::ExpressionPtr desugarLiteralBlock(pm_node *blockBodyNode, pm_node *blockParameters,
                                           pm_location_t blockLocation, pm_location_t blockNodeOpeningLoc);

    DesugaredBlockArgument desugarBlockPassArgument(pm_block_argument_node *bp);

    ast::ExpressionPtr desugarSymbolProc(pm_symbol_node *symbol);

    template <typename StoreType>
    StoreType desugarArguments(pm_arguments_node *node, pm_node *blockArgumentNode = nullptr);

    // Helper to convert a pm_node_list to any store type (e.g., ast::Array::ENTRY_store, ast::Send::ARGS_store, etc.)
    template <typename StoreType> StoreType nodeListToStore(const pm_node_list &nodeList);

    // Flattens key/value pairs from a keyword hash into the destination, or desugars the whole hash if there are splats
    template <typename Container> void flattenKwargs(pm_keyword_hash_node *kwargsHashNode, Container &destination);

    // Helper for Break/Next/Return nodes that take optional arguments
    ast::ExpressionPtr desugarBreakNextReturn(pm_arguments_node *argsNode);

    ast::ExpressionPtr desugarKeyValuePairs(core::LocOffsets loc, pm_node_list_t elements);

    ast::ExpressionPtr desugarArray(core::LocOffsets location, absl::Span<pm_node_t *> prismElements,
                                    ast::Array::ENTRY_store elements);

    ast::ExpressionPtr desugarBegin(pm_begin_node *beginNode);
    ast::Rescue::RESCUE_CASE_store desugarRescueCases(pm_rescue_node *firstRescueNode);
    uint32_t rescueCaseEndPos(const pm_rescue_node &rescueNode);

    // Helper to desugar statements from a clause node (rescue/ensure/else), returning EmptyTree if null or empty.
    template <typename ClauseNode> ast::ExpressionPtr desugarClauseStatements(ClauseNode *clause);

    ast::ExpressionPtr desugarStatements(pm_statements_node *stmtsNode, bool inlineIfSingle = true,
                                         core::LocOffsets overrideLocation = core::LocOffsets::none());

    ast::ExpressionPtr desugarRegexpOptions(pm_location_t closingLoc);
    ast::ExpressionPtr desugarRegexp(core::LocOffsets location, core::LocOffsets contentLoc, pm_string_t content,
                                     pm_location_t closingLoc);

    template <typename PrismAssignmentNode, typename SorbetAssignmentNode, typename SorbetLHSNode>
    ast::ExpressionPtr translateAnyOpAssignment(PrismAssignmentNode *node, core::LocOffsets location,
                                                ast::ExpressionPtr lhs);

    // Translate operator assignment targeting an indexed expression (e.g., `a[0] += 1`).
    template <typename PrismAssignmentNode, typename SorbetAssignmentNode>
    ast::ExpressionPtr translateIndexAssignment(pm_node_t *node, core::LocOffsets location);

    // Translate AndAsgn/OrAsgn operator assignments (e.g., `x &&= y`, `x ||= y`).
    template <typename SorbetAssignmentNode>
    ast::ExpressionPtr translateAndOrAssignment(core::LocOffsets location, ast::ExpressionPtr lhs,
                                                ast::ExpressionPtr rhs);

    template <typename PrismLhsNode, bool checkForDynamicConstAssign = false>
    ast::ExpressionPtr translateConst(pm_node_t *node);
    core::NameRef translateConstantName(pm_constant_id_t constantId);

    // Generates a unique name for a `parser::Node`.
    core::NameRef nextUniqueParserName(core::NameRef original);

    // Generates a unique name for a directly desugared `ast::ExpressionPtr`.
    core::NameRef nextUniqueDesugarName(core::NameRef original);

    // Structure for holding the scaffolding needed for op-assignment desugaring
    struct OpAsgnScaffolding {
        core::NameRef temporaryName;
        ast::InsSeq::STATS_store statementBody;
        uint16_t numPosArgs;
        ast::Send::ARGS_store readArgs;
        ast::Send::ARGS_store assgnArgs;
    };

    // Copy arguments in op-assignment desugaring
    OpAsgnScaffolding copyArgsForOpAsgn(ast::Send *s);

    // Translate OpAsgn operator assignments
    template <typename SorbetAssignmentNode, typename PrismAssignmentNode>
    ast::ExpressionPtr translateOpAssignment(PrismAssignmentNode *node, core::LocOffsets location,
                                             ast::ExpressionPtr lhs, ast::ExpressionPtr rhs);

    // ========================================================================
    // Direct Desugaring Functions for Op-Assignment Nodes
    // ========================================================================
    // These functions return ast::ExpressionPtr directly without creating
    // intermediate parser::Node objects.

    // Core desugaring helper for &&= and ||= with reference LHS (local, instance, class, global variables)
    template <OpAssignKind Kind>
    ast::ExpressionPtr desugarAndOrReference(core::LocOffsets location, ast::ExpressionPtr lhs, ast::ExpressionPtr rhs,
                                             bool isIvarOrCvar);

    // Core desugaring helper for operator assignment (+=, -=, etc.) with reference LHS
    ast::ExpressionPtr desugarOpReference(core::LocOffsets location, ast::ExpressionPtr lhs, core::NameRef op,
                                          core::LocOffsets opLoc, ast::ExpressionPtr rhs);

    // Desugar compound assignment when LHS is a Send expression
    template <OpAssignKind Kind>
    ast::ExpressionPtr desugarOpAssignSend(core::LocOffsets location, ast::Send *s, ast::ExpressionPtr rhs,
                                           core::NameRef op, core::LocOffsets opLoc);

    // Desugar compound assignment when LHS is a safe navigation send (InsSeq from CSend)
    template <OpAssignKind Kind>
    ast::ExpressionPtr desugarOpAssignCSend(core::LocOffsets location, ast::InsSeq *insSeq, ast::ExpressionPtr rhs,
                                            core::NameRef op, core::LocOffsets opLoc);

    // Core dispatcher for compound assignment desugaring based on LHS expression type
    template <OpAssignKind Kind>
    ast::ExpressionPtr desugarAnyOpAssign(core::LocOffsets location, ast::ExpressionPtr lhs, ast::ExpressionPtr rhs,
                                          core::NameRef op, core::LocOffsets opLoc, bool isIvarOrCvar);

    // Desugar variable compound assignment (local, instance, class, global)
    template <typename PrismVariableNode, OpAssignKind Kind, ast::UnresolvedIdent::Kind IdentKind>
    ast::ExpressionPtr desugarVariableOpAssign(pm_node_t *node);

    // Desugar constant compound assignment (e.g., `CONST &&= val`)
    template <typename PrismConstantNode, OpAssignKind Kind>
    ast::ExpressionPtr desugarConstantOpAssign(pm_node_t *node);

    // Desugar constant path compound assignment (e.g., `A::B &&= val`)
    template <typename PrismConstantPathNode, OpAssignKind Kind>
    ast::ExpressionPtr desugarConstantPathOpAssign(pm_node_t *node);

    // Desugar index compound assignment (e.g., `arr[i] &&= val`)
    template <typename PrismIndexNode, OpAssignKind Kind> ast::ExpressionPtr desugarIndexOpAssign(pm_node_t *node);

    // Desugar send compound assignment (e.g., `obj.method &&= val`, handles both regular and safe navigation)
    template <typename PrismSendNode, OpAssignKind Kind> ast::ExpressionPtr desugarSendOpAssign(pm_node_t *node);

    // Desugar regular (non-compound) assignment (e.g., `x = 1`, `@x = 1`, `CONST = 1`)
    template <typename PrismAssignmentNode, ast::UnresolvedIdent::Kind IdentKind = ast::UnresolvedIdent::Kind::Local>
    ast::ExpressionPtr desugarAssignment(pm_node_t *node);

    // Pattern-matching
    // ... variation of the main desugaring functions for pattern-matching related node.
    ast::ExpressionPtr desugarPattern(pm_node_t *node);
    ast::ExpressionPtr desugarOnelinePattern(core::LocOffsets loc, pm_node_t *match);

    std::string_view sliceLocation(pm_location_t loc) const;

    std::pair<core::NameRef, core::LocOffsets> translateSymbol(pm_symbol_node *symbol);

    // String interpolation desugaring
    sorbet::ast::ExpressionPtr desugarDString(core::LocOffsets loc, pm_node_list prismNodeList);

    // Multi-assignment desugaring
    template <typename PrismNode>
    ast::ExpressionPtr desugarMlhs(core::LocOffsets loc, PrismNode *lhs, ast::ExpressionPtr rhs);

    std::pair<ast::ExpressionPtr, ast::ExpressionPtr> desugarMlhsParam(core::LocOffsets loc, pm_multi_target_node *lhs);

    // Desugar a class, singleton class or module body.
    ast::ClassDef::RHS_store desugarClassOrModule(pm_node *prismBodyNode);

    void reportError(core::LocOffsets loc, const std::string &message) const;

    // Helper to determine whether to use super or untypedSuper based on context
    core::NameRef maybeTypedSuper() const;

    // Context management helpers. These return a copy of `this` with some change to the context.
    bool isInMethodDef() const;
    Translator enterMethodDef(bool isSingletonMethod, core::LocOffsets methodLoc, core::NameRef methodName,
                              core::LocOffsets &enclosingBlockParamLoc, core::NameRef &enclosingBlockParamName) const;
    Translator enterBlockContext() const;
    Translator enterModuleContext(core::LocOffsets &enclosingBlockParamLoc,
                                  core::NameRef &enclosingBlockParamName) const;
    Translator enterClassContext(core::LocOffsets &enclosingBlockParamLoc,
                                 core::NameRef &enclosingBlockParamName) const;

    std::pair<core::LocOffsets, core::LocOffsets> computeMethodCallLoc(core::LocOffsets initialLoc, pm_node_t *receiver,
                                                                       absl::Span<pm_node_t *> prismArgs,
                                                                       pm_location_t closing_loc,
                                                                       const Translator::DesugaredBlockArgument &block);
};

} // namespace sorbet::parser::Prism
#endif // SORBET_PARSER_PRISM_TRANSLATOR_H
