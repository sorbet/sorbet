begin
  class <emptyTree><<C <root>>> < (::<todo sym>)
    begin
      class ::Test<<C Test>> < (::<todo sym>)
        <self>.sig() do ||
          <self>.params({:"x" => <emptyTree>::<C String>}).returns(<emptyTree>::<C String>)
        end

        def foo(x, <blk>)
          x
        end

        <self>.sig() do ||
          <self>.params({:"y" => <emptyTree>::<C String>}).returns(<emptyTree>::<C String>)
        end

        def bar(y, <blk>)
          y
        end

        <self>.sig() do ||
          <self>.params({:"z" => <emptyTree>::<C String>}).returns(<emptyTree>::<C String>)
        end

        def qux(z, <blk>)
          z
        end

        <self>.sig() do ||
          <self>.params({:"w" => <emptyTree>::<C String>}).returns(<emptyTree>::<C String>)
        end

        def baz(w, <blk>)
          w
        end

        <self>.sig() do ||
          <self>.params({:"x" => <emptyTree>::<C String>}).returns(<emptyTree>::<C String>)
        end

        def foo<defaultArg>1(x, <blk>)
          nil
        end

        <self>.sig() do ||
          <self>.params({:"y" => <emptyTree>::<C String>}).returns(<emptyTree>::<C String>)
        end

        def bar<defaultArg>1(y, <blk>)
          nil
        end

        <self>.sig() do ||
          <self>.params({:"z" => <emptyTree>::<C String>}).returns(<emptyTree>::<C String>)
        end

        def qux<defaultArg>1(z, <blk>)
          ""
        end

        <self>.sig() do ||
          <self>.params({:"w" => <emptyTree>::<C String>}).returns(<emptyTree>::<C String>)
        end

        def baz<defaultArg>1(w, <blk>)
          ""
        end

        <self>.extend(<emptyTree>::<C T>::<C Sig>)

        :"foo"

        :"bar"

        :"qux"

        :"baz"

        :"foo<defaultArg>1"

        :"bar<defaultArg>1"

        :"qux<defaultArg>1"

        :"baz<defaultArg>1"
      end
      ::Sorbet::Private::Static.keep_for_ide(::Test)
      <emptyTree>
    end
  end
  <emptyTree>
end
