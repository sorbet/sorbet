method ::Object#rnd {

bb0[firstDead=2]():
    <self>: T.self_type (of Object) = cast(<self>: NilClass, T.self_type (of Object));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:<root>>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.self_type (of T.class_of(<root>)) = cast(<self>: NilClass, T.self_type (of T.class_of(<root>)));
    <cfgAlias>$5: T.class_of(Normal) = alias <C Normal>
    keep_for_ide$4: T.class_of(Normal) = <cfgAlias>$5
    keep_for_ide$4: T.untyped = <keep-alive> keep_for_ide$4
    <cfgAlias>$9: T.class_of(Normal) = alias <C Normal>
    <statTemp>$7: Normal = <cfgAlias>$9: T.class_of(Normal).new()
    <castTemp>$6: Normal = <statTemp>$7: Normal.returns_self()
    <statTemp>$3: Normal = cast(<castTemp>$6: Normal, Normal);
    <cfgAlias>$13: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$15: T.class_of(String) = alias <C String>
    keep_for_ide$11: Runtime object representing type: Generic[String] = <cfgAlias>$13: T.class_of(Generic).[](<cfgAlias>$15: T.class_of(String))
    keep_for_ide$11: T.untyped = <keep-alive> keep_for_ide$11
    <cfgAlias>$20: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$22: T.class_of(String) = alias <C String>
    <statTemp>$18: Runtime object representing type: Generic[String] = <cfgAlias>$20: T.class_of(Generic).[](<cfgAlias>$22: T.class_of(String))
    <statTemp>$17: Generic[String] = <statTemp>$18: Runtime object representing type: Generic[String].new()
    <castTemp>$16: Generic[String] = <statTemp>$17: Generic[String].returns_self()
    <statTemp>$10: Generic[String] = cast(<castTemp>$16: Generic[String], Generic[String]);
    <cfgAlias>$26: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$28: T.class_of(String) = alias <C String>
    <statTemp>$24: Runtime object representing type: Generic[String] = <cfgAlias>$26: T.class_of(Generic).[](<cfgAlias>$28: T.class_of(String))
    a: Generic[String] = <statTemp>$24: Runtime object representing type: Generic[String].new()
    <cfgAlias>$33: T.class_of(B) = alias <C B>
    <ifTemp>$30: T::Boolean = a: Generic[String].is_a?(<cfgAlias>$33: T.class_of(B))
    <ifTemp>$30 -> (T::Boolean ? bb2 : bb4)

# backedges
# - bb7
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
bb2[firstDead=-1](<self>: T.self_type (of T.class_of(<root>)), a: T.all(Generic[String], B)):
    <cfgAlias>$36: T.class_of(T) = alias <C T>
    <cfgAlias>$39: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$41: T.class_of(String) = alias <C String>
    <statTemp>$37: Runtime object representing type: Generic[String] = <cfgAlias>$39: T.class_of(Generic).[](<cfgAlias>$41: T.class_of(String))
    <cfgAlias>$43: T.class_of(B) = alias <C B>
    keep_for_ide$34: Runtime object representing type: T.all(Generic[String], B) = <cfgAlias>$36: T.class_of(T).all(<statTemp>$37: Runtime object representing type: Generic[String], <cfgAlias>$43: T.class_of(B))
    keep_for_ide$34: T.untyped = <keep-alive> keep_for_ide$34
    <castTemp>$44: T.all(Generic[String], B) = a: T.all(Generic[String], B).returns_self()
    <statTemp>$29: T.all(Generic[String], B) = cast(<castTemp>$44: T.all(Generic[String], B), T.all(Generic[String], B));
    <unconditional> -> bb4

# backedges
# - bb0
# - bb2
bb4[firstDead=-1](<self>: T.self_type (of T.class_of(<root>))):
    <cfgAlias>$50: T.class_of(Integer) = alias <C Integer>
    <cfgAlias>$52: T.class_of(Integer) = alias <C Integer>
    <magic>$48: T.class_of(<Magic>) = alias <C <Magic>>
    keep_for_ide$47: [T.class_of(Integer), T.class_of(Integer)] = <magic>$48: T.class_of(<Magic>).<build-array>(<cfgAlias>$50: T.class_of(Integer), <cfgAlias>$52: T.class_of(Integer))
    keep_for_ide$47: T.untyped = <keep-alive> keep_for_ide$47
    <arrayTemp>$56: Integer(1) = 1
    <arrayTemp>$57: Integer(2) = 2
    <magic>$55: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$54: [Integer(1), Integer(2)] = <magic>$55: T.class_of(<Magic>).<build-array>(<arrayTemp>$56: Integer(1), <arrayTemp>$57: Integer(2))
    <castTemp>$53: [Integer(1), Integer(2)] = <statTemp>$54: [Integer(1), Integer(2)].returns_self()
    <statTemp>$46: [Integer, Integer] = cast(<castTemp>$53: [Integer(1), Integer(2)], [Integer, Integer]);
    <cfgAlias>$60: T.class_of(A) = alias <C A>
    s: A = <cfgAlias>$60: T.class_of(A).new()
    <unconditional> -> bb5

# backedges
# - bb4
# - bb8
# - bb9
bb5[firstDead=-1](<self>: T.self_type (of T.class_of(<root>)), s: A):
    # outerLoops: 1
    <whileTemp>$63: T.untyped = <self>: T.self_type (of T.class_of(<root>)).rnd()
    <whileTemp>$63 -> (T.untyped ? bb8 : bb7)

# backedges
# - bb5
bb7[firstDead=2](<self>: T.self_type (of T.class_of(<root>)), s: A):
    <statTemp>$71: NilClass = <self>: T.self_type (of T.class_of(<root>)).puts(s: A)
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb5
bb8[firstDead=-1](<self>: T.self_type (of T.class_of(<root>)), s: A):
    # outerLoops: 1
    <cfgAlias>$69: T.class_of(B) = alias <C B>
    <ifTemp>$66: T::Boolean = s: A.is_a?(<cfgAlias>$69: T.class_of(B))
    <ifTemp>$66 -> (T::Boolean ? bb9 : bb5)

# backedges
# - bb8
bb9[firstDead=-1](<self>: T.self_type (of T.class_of(<root>)), s: T.all(A, B)):
    # outerLoops: 1
    <statTemp>$70: T.all(A, B) = s
    s: T.all(A, B) = <statTemp>$70: T.all(A, B).returns_self()
    <unconditional> -> bb5

}

method ::Parent#returns_self {

bb0[firstDead=3]():
    <self>: T.self_type (of Parent) = cast(<self>: NilClass, T.self_type (of Parent));
    <returnMethodTemp>$2: T.self_type (of Parent) = <self>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.self_type (of Parent)
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Parent>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.self_type (of T.class_of(Parent)) = cast(<self>: NilClass, T.self_type (of T.class_of(Parent)));
    <block-pre-call-temp>$5: Sorbet::Private::Static::Void = <self>: T.self_type (of T.class_of(Parent)).sig()
    <selfRestore>$6: T.self_type (of T.class_of(Parent)) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.self_type (of T.class_of(Parent)), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(Parent))):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=6](<block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(Parent))):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$5, sig>
    <self>: T.self_type (of T.class_of(Parent)) = <selfRestore>$6
    <cfgAlias>$17: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$19: T.class_of(T) = alias <C T>
    <statTemp>$14: T.self_type (of T.class_of(Parent)) = <self>: T.self_type (of T.class_of(Parent)).extend(<cfgAlias>$17: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=5](<self>: T.self_type (of T.class_of(Parent)), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(Parent))):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <cfgAlias>$11: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$9: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder) = <cfgAlias>$11: T.class_of(<Magic>).self_type(<self>: T::Private::Methods::DeclBuilder)
    <blockReturnTemp>$7: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.returns(<statTemp>$9: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder))
    <blockReturnTemp>$13: T.noreturn = blockreturn<sig> <blockReturnTemp>$7: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

}

method ::<Class:Normal>#<static-init> {

bb0[firstDead=2]():
    <self>: T.self_type (of T.class_of(Normal)) = cast(<self>: NilClass, T.self_type (of T.class_of(Normal)));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Generic#good {

bb0[firstDead=-1]():
    <self>: T.self_type (of Generic[Generic::TM]) = cast(<self>: NilClass, T.self_type (of Generic[Generic::TM]));
    <arrayTemp>$6: TrueClass = true
    <arrayTemp>$7: FalseClass = false
    <magic>$5: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$4: [TrueClass, FalseClass] = <magic>$5: T.class_of(<Magic>).<build-array>(<arrayTemp>$6: TrueClass, <arrayTemp>$7: FalseClass)
    <ifTemp>$3: T::Boolean = <statTemp>$4: [TrueClass, FalseClass].sample()
    <ifTemp>$3 -> (T::Boolean ? bb2 : bb3)

# backedges
# - bb2
# - bb3
bb1[firstDead=-1](<returnMethodTemp>$2):
    <finalReturn> = return <returnMethodTemp>$2
    <unconditional> -> bb1

# backedges
# - bb0
bb2[firstDead=6](<self>: T.self_type (of Generic[Generic::TM])):
    <cfgAlias>$11: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$14: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$12: Runtime object representing type: T.self_type (of Generic[Generic::TM]) = <cfgAlias>$14: T.class_of(<Magic>).self_type(<self>: T.self_type (of Generic[Generic::TM]))
    <statTemp>$9: Runtime object representing type: Generic[T.self_type (of Generic[Generic::TM])] = <cfgAlias>$11: T.class_of(Generic).[](<statTemp>$12: Runtime object representing type: T.self_type (of Generic[Generic::TM]))
    <returnTemp>$8: Generic[T.self_type (of Generic[Generic::TM])] = <statTemp>$9: Runtime object representing type: Generic[T.self_type (of Generic[Generic::TM])].new()
    <returnMethodTemp>$2: T.noreturn = return <returnTemp>$8: Generic[T.self_type (of Generic[Generic::TM])]
    <unconditional> -> bb1

# backedges
# - bb0
bb3[firstDead=5]():
    <cfgAlias>$19: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$21: T.class_of(Parent) = alias <C Parent>
    <statTemp>$17: Runtime object representing type: Generic[Parent] = <cfgAlias>$19: T.class_of(Generic).[](<cfgAlias>$21: T.class_of(Parent))
    <returnTemp>$16: Generic[Parent] = <statTemp>$17: Runtime object representing type: Generic[Parent].new()
    <returnMethodTemp>$2: T.noreturn = return <returnTemp>$16: Generic[Parent]
    <unconditional> -> bb1

}

method ::<Class:Generic>#<static-init> {

bb0[firstDead=-1]():
    <C TM>$24: Runtime object representing type: Generic::TM = alias <C TM>
    <self>: T.self_type (of T.class_of(Generic)) = cast(<self>: NilClass, T.self_type (of T.class_of(Generic)));
    <block-pre-call-temp>$5: Sorbet::Private::Static::Void = <self>: T.self_type (of T.class_of(Generic)).sig()
    <selfRestore>$6: T.self_type (of T.class_of(Generic)) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.self_type (of T.class_of(Generic)), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(Generic))):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=7](<block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(Generic))):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$5, sig>
    <self>: T.self_type (of T.class_of(Generic)) = <selfRestore>$6
    <cfgAlias>$20: T.class_of(T::Generic) = alias <C Generic>
    <cfgAlias>$22: T.class_of(T) = alias <C T>
    <statTemp>$17: T.self_type (of T.class_of(Generic)) = <self>: T.self_type (of T.class_of(Generic)).extend(<cfgAlias>$20: T.class_of(T::Generic))
    <C TM>$24: T::Types::TypeMember = <self>: T.self_type (of T.class_of(Generic)).type_member()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=7](<self>: T.self_type (of T.class_of(Generic)), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(Generic))):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <cfgAlias>$11: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$14: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$12: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder) = <cfgAlias>$14: T.class_of(<Magic>).self_type(<self>: T::Private::Methods::DeclBuilder)
    <statTemp>$9: Runtime object representing type: Generic[T.self_type (of T::Private::Methods::DeclBuilder)] = <cfgAlias>$11: T.class_of(Generic).[](<statTemp>$12: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder))
    <blockReturnTemp>$7: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.returns(<statTemp>$9: Runtime object representing type: Generic[T.self_type (of T::Private::Methods::DeclBuilder)])
    <blockReturnTemp>$16: T.noreturn = blockreturn<sig> <blockReturnTemp>$7: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

}

method ::<Class:B>#<static-init> {

bb0[firstDead=2]():
    <self>: T.self_type (of T.class_of(B)) = cast(<self>: NilClass, T.self_type (of T.class_of(B)));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Array#returns_self {

bb0[firstDead=3]():
    <self>: T.self_type (of T::Array[Array::Elem]) = cast(<self>: NilClass, T.self_type (of T::Array[Array::Elem]));
    <returnMethodTemp>$2: T.self_type (of T::Array[Array::Elem]) = <self>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.self_type (of T::Array[Array::Elem])
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Array>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.self_type (of T.class_of(Array)) = cast(<self>: NilClass, T.self_type (of T.class_of(Array)));
    <block-pre-call-temp>$5: Sorbet::Private::Static::Void = <self>: T.self_type (of T.class_of(Array)).sig()
    <selfRestore>$6: T.self_type (of T.class_of(Array)) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.self_type (of T.class_of(Array)), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(Array))):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=6](<block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(Array))):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$5, sig>
    <self>: T.self_type (of T.class_of(Array)) = <selfRestore>$6
    <cfgAlias>$17: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$19: T.class_of(T) = alias <C T>
    <statTemp>$14: T.self_type (of T.class_of(Array)) = <self>: T.self_type (of T.class_of(Array)).extend(<cfgAlias>$17: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=5](<self>: T.self_type (of T.class_of(Array)), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(Array))):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <cfgAlias>$11: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$9: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder) = <cfgAlias>$11: T.class_of(<Magic>).self_type(<self>: T::Private::Methods::DeclBuilder)
    <blockReturnTemp>$7: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.returns(<statTemp>$9: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder))
    <blockReturnTemp>$13: T.noreturn = blockreturn<sig> <blockReturnTemp>$7: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

}

method ::<Class:A>#<static-init> {

bb0[firstDead=2]():
    <self>: T.self_type (of T.class_of(A)) = cast(<self>: NilClass, T.self_type (of T.class_of(A)));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#returns_self {

bb0[firstDead=3]():
    <self>: T.self_type (of B) = cast(<self>: NilClass, T.self_type (of B));
    <returnMethodTemp>$2: T.self_type (of B) = <self>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.self_type (of B)
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#takes_self_public {

bb0[firstDead=4]():
    <self>: T.self_type (of B) = cast(<self>: NilClass, T.self_type (of B));
    x: T.self_type (of B) = load_arg(x)
    <returnMethodTemp>$2: T.self_type (of B) = x
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.self_type (of B)
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#takes_self_private {

bb0[firstDead=6]():
    <self>: T.self_type (of B) = cast(<self>: NilClass, T.self_type (of B));
    x: T.self_type (of B) = load_arg(x)
    <cfgAlias>$5: T.class_of(T) = alias <C T>
    <statTemp>$3: T.self_type (of B) = <cfgAlias>$5: T.class_of(T).reveal_type(x: T.self_type (of B))
    <returnMethodTemp>$2: T.self_type (of B) = x
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.self_type (of B)
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#yield_self_void {

bb0[firstDead=4]():
    <self>: T.self_type (of B) = cast(<self>: NilClass, T.self_type (of B));
    blk: T.proc.params(arg0: T.self_type (of B)).void = load_arg(blk)
    <returnMethodTemp>$2: Sorbet::Private::Static::Void = blk: T.proc.params(arg0: T.self_type (of B)).void.call(<self>: T.self_type (of B))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Sorbet::Private::Static::Void
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#takes_self_or_integer {

bb0[firstDead=6]():
    <self>: T.self_type (of B) = cast(<self>: NilClass, T.self_type (of B));
    x: T.any(Integer, T.self_type (of B)) = load_arg(x)
    <cfgAlias>$5: T.class_of(T) = alias <C T>
    <statTemp>$3: T.any(Integer, T.self_type (of B)) = <cfgAlias>$5: T.class_of(T).reveal_type(x: T.any(Integer, T.self_type (of B)))
    <returnMethodTemp>$2: T.any(Integer, T.self_type (of B)) = x
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.any(Integer, T.self_type (of B))
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#== {

bb0[firstDead=6]():
    <self>: T.self_type (of B) = cast(<self>: NilClass, T.self_type (of B));
    other: T.self_type (of B) = load_arg(other)
    <statTemp>$4: T.untyped = <self>: T.self_type (of B).class()
    <statTemp>$6: T.untyped = other: T.self_type (of B).class()
    <returnTemp>$3: T.untyped = <statTemp>$4: T.untyped.==(<statTemp>$6: T.untyped)
    <returnMethodTemp>$2: T.noreturn = return <returnTemp>$3: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1](<returnMethodTemp>$2):
    <finalReturn> = return <returnMethodTemp>$2
    <unconditional> -> bb1

}

method ::<Class:B>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.self_type (of T.class_of(B)) = cast(<self>: NilClass, T.self_type (of T.class_of(B)));
    <block-pre-call-temp>$5: Sorbet::Private::Static::Void = <self>: T.self_type (of T.class_of(B)).sig()
    <selfRestore>$6: T.self_type (of T.class_of(B)) = <self>
    <unconditional> -> bb2

# backedges
# - bb23
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=-1](<block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(B))):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$5, sig>
    <self>: T.self_type (of T.class_of(B)) = <selfRestore>$6
    <block-pre-call-temp>$16: Sorbet::Private::Static::Void = <self>: T.self_type (of T.class_of(B)).sig()
    <selfRestore>$17: T.self_type (of T.class_of(B)) = <self>
    <unconditional> -> bb6

# backedges
# - bb2
bb5[firstDead=5](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <cfgAlias>$11: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$9: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder) = <cfgAlias>$11: T.class_of(<Magic>).self_type(<self>: T::Private::Methods::DeclBuilder)
    <blockReturnTemp>$7: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.returns(<statTemp>$9: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder))
    <blockReturnTemp>$13: T.noreturn = blockreturn<sig> <blockReturnTemp>$7: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

# backedges
# - bb3
# - bb9
bb6[firstDead=-1](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$16: Sorbet::Private::Static::Void, <selfRestore>$17: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb9 : bb7)

# backedges
# - bb6
bb7[firstDead=-1](<block-pre-call-temp>$16: Sorbet::Private::Static::Void, <selfRestore>$17: T.self_type (of T.class_of(B))):
    <statTemp>$14: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$16, sig>
    <self>: T.self_type (of T.class_of(B)) = <selfRestore>$17
    <block-pre-call-temp>$29: Sorbet::Private::Static::Void = <self>: T.self_type (of T.class_of(B)).sig()
    <selfRestore>$30: T.self_type (of T.class_of(B)) = <self>
    <unconditional> -> bb10

# backedges
# - bb6
bb9[firstDead=7](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$16: Sorbet::Private::Static::Void, <selfRestore>$17: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$21: Symbol(:x) = :x
    <cfgAlias>$24: T.class_of(<Magic>) = alias <C <Magic>>
    <hashTemp>$22: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder) = <cfgAlias>$24: T.class_of(<Magic>).self_type(<self>: T::Private::Methods::DeclBuilder)
    <statTemp>$19: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$21: Symbol(:x), <hashTemp>$22: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder))
    <blockReturnTemp>$18: T::Private::Methods::DeclBuilder = <statTemp>$19: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$26: T.noreturn = blockreturn<sig> <blockReturnTemp>$18: T::Private::Methods::DeclBuilder
    <unconditional> -> bb6

# backedges
# - bb7
# - bb13
bb10[firstDead=-1](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$29: Sorbet::Private::Static::Void, <selfRestore>$30: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb13 : bb11)

# backedges
# - bb10
bb11[firstDead=-1](<block-pre-call-temp>$29: Sorbet::Private::Static::Void, <selfRestore>$30: T.self_type (of T.class_of(B))):
    <statTemp>$27: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$29, sig>
    <self>: T.self_type (of T.class_of(B)) = <selfRestore>$30
    <block-pre-call-temp>$42: Sorbet::Private::Static::Void = <self>: T.self_type (of T.class_of(B)).sig()
    <selfRestore>$43: T.self_type (of T.class_of(B)) = <self>
    <unconditional> -> bb14

# backedges
# - bb10
bb13[firstDead=7](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$29: Sorbet::Private::Static::Void, <selfRestore>$30: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$34: Symbol(:x) = :x
    <cfgAlias>$37: T.class_of(<Magic>) = alias <C <Magic>>
    <hashTemp>$35: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder) = <cfgAlias>$37: T.class_of(<Magic>).self_type(<self>: T::Private::Methods::DeclBuilder)
    <statTemp>$32: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$34: Symbol(:x), <hashTemp>$35: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder))
    <blockReturnTemp>$31: T::Private::Methods::DeclBuilder = <statTemp>$32: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$39: T.noreturn = blockreturn<sig> <blockReturnTemp>$31: T::Private::Methods::DeclBuilder
    <unconditional> -> bb10

# backedges
# - bb11
# - bb17
bb14[firstDead=-1](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$42: Sorbet::Private::Static::Void, <selfRestore>$43: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb17 : bb15)

# backedges
# - bb14
bb15[firstDead=-1](<block-pre-call-temp>$42: Sorbet::Private::Static::Void, <selfRestore>$43: T.self_type (of T.class_of(B))):
    <statTemp>$40: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$42, sig>
    <self>: T.self_type (of T.class_of(B)) = <selfRestore>$43
    <block-pre-call-temp>$61: Sorbet::Private::Static::Void = <self>: T.self_type (of T.class_of(B)).sig()
    <selfRestore>$62: T.self_type (of T.class_of(B)) = <self>
    <unconditional> -> bb18

# backedges
# - bb14
bb17[firstDead=12](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$42: Sorbet::Private::Static::Void, <selfRestore>$43: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$47: Symbol(:blk) = :blk
    <cfgAlias>$52: T.class_of(T) = alias <C T>
    <statTemp>$50: T.class_of(T.proc) = <cfgAlias>$52: T.class_of(T).proc()
    <hashTemp>$53: Symbol(:arg0) = :arg0
    <cfgAlias>$56: T.class_of(<Magic>) = alias <C <Magic>>
    <hashTemp>$54: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder) = <cfgAlias>$56: T.class_of(<Magic>).self_type(<self>: T::Private::Methods::DeclBuilder)
    <statTemp>$49: Runtime object representing type: T.proc.params(arg0: T.self_type (of T::Private::Methods::DeclBuilder)).returns(<todo sym>) = <statTemp>$50: T.class_of(T.proc).params(<hashTemp>$53: Symbol(:arg0), <hashTemp>$54: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder))
    <hashTemp>$48: Runtime object representing type: T.proc.params(arg0: T.self_type (of T::Private::Methods::DeclBuilder)).void = <statTemp>$49: Runtime object representing type: T.proc.params(arg0: T.self_type (of T::Private::Methods::DeclBuilder)).returns(<todo sym>).void()
    <statTemp>$45: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$47: Symbol(:blk), <hashTemp>$48: Runtime object representing type: T.proc.params(arg0: T.self_type (of T::Private::Methods::DeclBuilder)).void)
    <blockReturnTemp>$44: T::Private::Methods::DeclBuilder = <statTemp>$45: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$58: T.noreturn = blockreturn<sig> <blockReturnTemp>$44: T::Private::Methods::DeclBuilder
    <unconditional> -> bb14

# backedges
# - bb15
# - bb21
bb18[firstDead=-1](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$61: Sorbet::Private::Static::Void, <selfRestore>$62: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb21 : bb19)

# backedges
# - bb18
bb19[firstDead=-1](<block-pre-call-temp>$61: Sorbet::Private::Static::Void, <selfRestore>$62: T.self_type (of T.class_of(B))):
    <statTemp>$59: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$61, sig>
    <self>: T.self_type (of T.class_of(B)) = <selfRestore>$62
    <block-pre-call-temp>$79: Sorbet::Private::Static::Void = <self>: T.self_type (of T.class_of(B)).sig()
    <selfRestore>$80: T.self_type (of T.class_of(B)) = <self>
    <unconditional> -> bb22

# backedges
# - bb18
bb21[firstDead=10](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$61: Sorbet::Private::Static::Void, <selfRestore>$62: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$66: Symbol(:x) = :x
    <cfgAlias>$69: T.class_of(T) = alias <C T>
    <cfgAlias>$72: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$70: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder) = <cfgAlias>$72: T.class_of(<Magic>).self_type(<self>: T::Private::Methods::DeclBuilder)
    <cfgAlias>$75: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$67: Runtime object representing type: T.any(Integer, T.self_type (of T::Private::Methods::DeclBuilder)) = <cfgAlias>$69: T.class_of(T).any(<statTemp>$70: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder), <cfgAlias>$75: T.class_of(Integer))
    <statTemp>$64: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$66: Symbol(:x), <hashTemp>$67: Runtime object representing type: T.any(Integer, T.self_type (of T::Private::Methods::DeclBuilder)))
    <blockReturnTemp>$63: T::Private::Methods::DeclBuilder = <statTemp>$64: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$76: T.noreturn = blockreturn<sig> <blockReturnTemp>$63: T::Private::Methods::DeclBuilder
    <unconditional> -> bb18

# backedges
# - bb19
# - bb25
bb22[firstDead=-1](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$79: Sorbet::Private::Static::Void, <selfRestore>$80: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb25 : bb23)

# backedges
# - bb22
bb23[firstDead=10](<block-pre-call-temp>$79: Sorbet::Private::Static::Void, <selfRestore>$80: T.self_type (of T.class_of(B))):
    <statTemp>$77: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$79, sig>
    <self>: T.self_type (of T.class_of(B)) = <selfRestore>$80
    <cfgAlias>$93: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$95: T.class_of(T) = alias <C T>
    <statTemp>$90: T.self_type (of T.class_of(B)) = <self>: T.self_type (of T.class_of(B)).extend(<cfgAlias>$93: T.class_of(T::Sig))
    <statTemp>$100: Symbol(:takes_self_private) = :takes_self_private
    <statTemp>$98: T.self_type (of T.class_of(B)) = <self>: T.self_type (of T.class_of(B)).private(<statTemp>$100: Symbol(:takes_self_private))
    <statTemp>$104: Symbol(:takes_self_or_integer) = :takes_self_or_integer
    <statTemp>$102: T.self_type (of T.class_of(B)) = <self>: T.self_type (of T.class_of(B)).private(<statTemp>$104: Symbol(:takes_self_or_integer))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb22
bb25[firstDead=7](<self>: T.self_type (of T.class_of(B)), <block-pre-call-temp>$79: Sorbet::Private::Static::Void, <selfRestore>$80: T.self_type (of T.class_of(B))):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$84: Symbol(:other) = :other
    <cfgAlias>$87: T.class_of(<Magic>) = alias <C <Magic>>
    <hashTemp>$85: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder) = <cfgAlias>$87: T.class_of(<Magic>).self_type(<self>: T::Private::Methods::DeclBuilder)
    <statTemp>$82: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$84: Symbol(:other), <hashTemp>$85: Runtime object representing type: T.self_type (of T::Private::Methods::DeclBuilder))
    <blockReturnTemp>$81: T::Private::Methods::DeclBuilder = <statTemp>$82: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$89: T.noreturn = blockreturn<sig> <blockReturnTemp>$81: T::Private::Methods::DeclBuilder
    <unconditional> -> bb22

}

