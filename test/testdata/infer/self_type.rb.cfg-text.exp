method ::Object#rnd {

bb0[firstDead=2]():
    <self>: Object = cast(<self>: NilClass, Object);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:<root>>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(<root>) = cast(<self>: NilClass, T.class_of(<root>));
    <cfgAlias>$5: T.class_of(Normal) = alias <C Normal>
    keep_for_ide$4: T.class_of(Normal) = <cfgAlias>$5
    keep_for_ide$4: T.untyped = <keep-alive> keep_for_ide$4
    <cfgAlias>$9: T.class_of(Normal) = alias <C Normal>
    <statTemp>$7: Normal = <cfgAlias>$9: T.class_of(Normal).new()
    <castTemp>$6: Normal = <statTemp>$7: Normal.returns_self()
    <statTemp>$3: Normal = cast(<castTemp>$6: Normal, Normal);
    <cfgAlias>$13: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$15: T.class_of(String) = alias <C String>
    keep_for_ide$11: Runtime object representing type: Generic[String] = <cfgAlias>$13: T.class_of(Generic).[](<cfgAlias>$15: T.class_of(String))
    keep_for_ide$11: T.untyped = <keep-alive> keep_for_ide$11
    <cfgAlias>$20: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$22: T.class_of(String) = alias <C String>
    <statTemp>$18: Runtime object representing type: Generic[String] = <cfgAlias>$20: T.class_of(Generic).[](<cfgAlias>$22: T.class_of(String))
    <statTemp>$17: Generic[String] = <statTemp>$18: Runtime object representing type: Generic[String].new()
    <castTemp>$16: Generic[String] = <statTemp>$17: Generic[String].returns_self()
    <statTemp>$10: Generic[String] = cast(<castTemp>$16: Generic[String], Generic[String]);
    <cfgAlias>$26: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$28: T.class_of(String) = alias <C String>
    <statTemp>$24: Runtime object representing type: Generic[String] = <cfgAlias>$26: T.class_of(Generic).[](<cfgAlias>$28: T.class_of(String))
    a: Generic[String] = <statTemp>$24: Runtime object representing type: Generic[String].new()
    <cfgAlias>$33: T.class_of(B) = alias <C B>
    <ifTemp>$30: T::Boolean = a: Generic[String].is_a?(<cfgAlias>$33: T.class_of(B))
    <ifTemp>$30 -> (T::Boolean ? bb2 : bb4)

# backedges
# - bb7
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
bb2[firstDead=-1](<self>: T.class_of(<root>), a: T.all(Generic[String], B)):
    <cfgAlias>$36: T.class_of(T) = alias <C T>
    <cfgAlias>$39: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$41: T.class_of(String) = alias <C String>
    <statTemp>$37: Runtime object representing type: Generic[String] = <cfgAlias>$39: T.class_of(Generic).[](<cfgAlias>$41: T.class_of(String))
    <cfgAlias>$43: T.class_of(B) = alias <C B>
    keep_for_ide$34: Runtime object representing type: T.all(Generic[String], B) = <cfgAlias>$36: T.class_of(T).all(<statTemp>$37: Runtime object representing type: Generic[String], <cfgAlias>$43: T.class_of(B))
    keep_for_ide$34: T.untyped = <keep-alive> keep_for_ide$34
    <castTemp>$44: T.all(Generic[String], B) = a: T.all(Generic[String], B).returns_self()
    <statTemp>$29: T.all(Generic[String], B) = cast(<castTemp>$44: T.all(Generic[String], B), T.all(Generic[String], B));
    <unconditional> -> bb4

# backedges
# - bb0
# - bb2
bb4[firstDead=-1](<self>: T.class_of(<root>)):
    <cfgAlias>$49: T.class_of(Integer) = alias <C Integer>
    <cfgAlias>$51: T.class_of(Integer) = alias <C Integer>
    <magic>$52: T.class_of(<Magic>) = alias <C <Magic>>
    keep_for_ide$47: [T.class_of(Integer), T.class_of(Integer)] = <magic>$52: T.class_of(<Magic>).<build-array>(<cfgAlias>$49: T.class_of(Integer), <cfgAlias>$51: T.class_of(Integer))
    keep_for_ide$47: T.untyped = <keep-alive> keep_for_ide$47
    <arrayTemp>$55: Integer(1) = 1
    <arrayTemp>$56: Integer(2) = 2
    <magic>$57: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$54: [Integer(1), Integer(2)] = <magic>$57: T.class_of(<Magic>).<build-array>(<arrayTemp>$55: Integer(1), <arrayTemp>$56: Integer(2))
    <castTemp>$53: [Integer(1), Integer(2)] = <statTemp>$54: [Integer(1), Integer(2)].returns_self()
    <statTemp>$46: [Integer, Integer] = cast(<castTemp>$53: [Integer(1), Integer(2)], [Integer, Integer]);
    <cfgAlias>$60: T.class_of(A) = alias <C A>
    s: A = <cfgAlias>$60: T.class_of(A).new()
    <unconditional> -> bb5

# backedges
# - bb4
# - bb8
# - bb9
bb5[firstDead=-1](<self>: T.class_of(<root>), s: A):
    # outerLoops: 1
    <whileTemp>$63: T.untyped = <self>: T.class_of(<root>).rnd()
    <whileTemp>$63 -> (T.untyped ? bb8 : bb7)

# backedges
# - bb5
bb7[firstDead=2](<self>: T.class_of(<root>), s: A):
    <statTemp>$71: NilClass = <self>: T.class_of(<root>).puts(s: A)
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb5
bb8[firstDead=-1](<self>: T.class_of(<root>), s: A):
    # outerLoops: 1
    <cfgAlias>$69: T.class_of(B) = alias <C B>
    <ifTemp>$66: T::Boolean = s: A.is_a?(<cfgAlias>$69: T.class_of(B))
    <ifTemp>$66 -> (T::Boolean ? bb9 : bb5)

# backedges
# - bb8
bb9[firstDead=-1](<self>: T.class_of(<root>), s: T.all(A, B)):
    # outerLoops: 1
    <statTemp>$70: T.all(A, B) = s
    s: T.all(A, B) = <statTemp>$70: T.all(A, B).returns_self()
    <unconditional> -> bb5

}

method ::Parent#returns_self {

bb0[firstDead=3]():
    <self>: Parent = cast(<self>: NilClass, Parent);
    <returnMethodTemp>$2: Parent = <self>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Parent
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Parent>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(Parent) = cast(<self>: NilClass, T.class_of(Parent));
    <block-pre-call-temp>$5: Sorbet::Private::Static::Void = <self>: T.class_of(Parent).sig()
    <selfRestore>$6: T.class_of(Parent) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(Parent), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Parent)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=6](<block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Parent)):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$5, sig>
    <self>: T.class_of(Parent) = <selfRestore>$6
    <cfgAlias>$16: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$18: T.class_of(T) = alias <C T>
    <statTemp>$13: T.class_of(Parent) = <self>: T.class_of(Parent).extend(<cfgAlias>$16: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=5](<self>: T.class_of(Parent), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Parent)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <cfgAlias>$11: T.class_of(T) = alias <C T>
    <statTemp>$9: Runtime object representing type: T.untyped = <cfgAlias>$11: T.class_of(T).self_type()
    <blockReturnTemp>$7: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.returns(<statTemp>$9: Runtime object representing type: T.untyped)
    <blockReturnTemp>$12: T.noreturn = blockreturn<sig> <blockReturnTemp>$7: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

}

method ::<Class:Normal>#<static-init> {

bb0[firstDead=2]():
    <self>: T.class_of(Normal) = cast(<self>: NilClass, T.class_of(Normal));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Generic#bad {

bb0[firstDead=7]():
    <self>: Generic[Generic::TM] = cast(<self>: NilClass, Generic[Generic::TM]);
    <cfgAlias>$5: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$6: Runtime object representing type: T.untyped = <cfgAlias>$8: T.class_of(T).untyped()
    <statTemp>$3: Runtime object representing type: Generic[T.untyped] = <cfgAlias>$5: T.class_of(Generic).[](<statTemp>$6: Runtime object representing type: T.untyped)
    <returnMethodTemp>$2: Generic[T.untyped] = <statTemp>$3: Runtime object representing type: Generic[T.untyped].new()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Generic[T.untyped]
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Generic>#<static-init> {

bb0[firstDead=-1]():
    <C TM>$23: Runtime object representing type: Generic::TM = alias <C TM>
    <self>: T.class_of(Generic) = cast(<self>: NilClass, T.class_of(Generic));
    <block-pre-call-temp>$5: Sorbet::Private::Static::Void = <self>: T.class_of(Generic).sig()
    <selfRestore>$6: T.class_of(Generic) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(Generic), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Generic)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=7](<block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Generic)):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$5, sig>
    <self>: T.class_of(Generic) = <selfRestore>$6
    <cfgAlias>$19: T.class_of(T::Generic) = alias <C Generic>
    <cfgAlias>$21: T.class_of(T) = alias <C T>
    <statTemp>$16: T.class_of(Generic) = <self>: T.class_of(Generic).extend(<cfgAlias>$19: T.class_of(T::Generic))
    <C TM>$23: T::Types::TypeMember = <self>: T.class_of(Generic).type_member()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=7](<self>: T.class_of(Generic), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Generic)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <cfgAlias>$11: T.class_of(Generic) = alias <C Generic>
    <cfgAlias>$14: T.class_of(T) = alias <C T>
    <statTemp>$12: Runtime object representing type: T.untyped = <cfgAlias>$14: T.class_of(T).self_type()
    <statTemp>$9: Runtime object representing type: Generic[T.untyped] = <cfgAlias>$11: T.class_of(Generic).[](<statTemp>$12: Runtime object representing type: T.untyped)
    <blockReturnTemp>$7: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.returns(<statTemp>$9: Runtime object representing type: Generic[T.untyped])
    <blockReturnTemp>$15: T.noreturn = blockreturn<sig> <blockReturnTemp>$7: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

}

method ::<Class:B>#<static-init> {

bb0[firstDead=2]():
    <self>: T.class_of(B) = cast(<self>: NilClass, T.class_of(B));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Array#returns_self {

bb0[firstDead=3]():
    <self>: T::Array[Array::Elem] = cast(<self>: NilClass, T::Array[Array::Elem]);
    <returnMethodTemp>$2: T::Array[Array::Elem] = <self>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T::Array[Array::Elem]
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Array>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(Array) = cast(<self>: NilClass, T.class_of(Array));
    <block-pre-call-temp>$5: Sorbet::Private::Static::Void = <self>: T.class_of(Array).sig()
    <selfRestore>$6: T.class_of(Array) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(Array), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Array)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=6](<block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Array)):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$5, sig>
    <self>: T.class_of(Array) = <selfRestore>$6
    <cfgAlias>$16: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$18: T.class_of(T) = alias <C T>
    <statTemp>$13: T.class_of(Array) = <self>: T.class_of(Array).extend(<cfgAlias>$16: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=5](<self>: T.class_of(Array), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Array)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <cfgAlias>$11: T.class_of(T) = alias <C T>
    <statTemp>$9: Runtime object representing type: T.untyped = <cfgAlias>$11: T.class_of(T).self_type()
    <blockReturnTemp>$7: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.returns(<statTemp>$9: Runtime object representing type: T.untyped)
    <blockReturnTemp>$12: T.noreturn = blockreturn<sig> <blockReturnTemp>$7: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

}

method ::<Class:A>#<static-init> {

bb0[firstDead=2]():
    <self>: T.class_of(A) = cast(<self>: NilClass, T.class_of(A));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#returns_self {

bb0[firstDead=3]():
    <self>: B = cast(<self>: NilClass, B);
    <returnMethodTemp>$2: B = <self>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: B
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#takes_self_public {

bb0[firstDead=4]():
    <self>: B = cast(<self>: NilClass, B);
    x: T.untyped = load_arg(x)
    <returnMethodTemp>$2: T.untyped = x
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#takes_self_private {

bb0[firstDead=6]():
    <self>: B = cast(<self>: NilClass, B);
    x: T.untyped = load_arg(x)
    <cfgAlias>$5: T.class_of(T) = alias <C T>
    <statTemp>$3: T.untyped = <cfgAlias>$5: T.class_of(T).reveal_type(x: T.untyped)
    <returnMethodTemp>$2: T.untyped = x
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#yield_self_void {

bb0[firstDead=4]():
    <self>: B = cast(<self>: NilClass, B);
    blk: T.proc.params(arg0: T.untyped).void = load_arg(blk)
    <returnMethodTemp>$2: Sorbet::Private::Static::Void = blk: T.proc.params(arg0: T.untyped).void.call(<self>: B)
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Sorbet::Private::Static::Void
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#takes_self_or_integer {

bb0[firstDead=6]():
    <self>: B = cast(<self>: NilClass, B);
    x: T.untyped = load_arg(x)
    <cfgAlias>$5: T.class_of(T) = alias <C T>
    <statTemp>$3: T.untyped = <cfgAlias>$5: T.class_of(T).reveal_type(x: T.untyped)
    <returnMethodTemp>$2: T.untyped = x
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#== {

bb0[firstDead=6]():
    <self>: B = cast(<self>: NilClass, B);
    other: T.untyped = load_arg(other)
    <statTemp>$4: T.untyped = <self>: B.class()
    <statTemp>$6: T.untyped = other: T.untyped.class()
    <returnTemp>$3: T.untyped = <statTemp>$4: T.untyped.==(<statTemp>$6: T.untyped)
    <returnMethodTemp>$2: T.noreturn = return <returnTemp>$3: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1](<returnMethodTemp>$2):
    <finalReturn> = return <returnMethodTemp>$2
    <unconditional> -> bb1

}

method ::<Class:B>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(B) = cast(<self>: NilClass, T.class_of(B));
    <block-pre-call-temp>$5: Sorbet::Private::Static::Void = <self>: T.class_of(B).sig()
    <selfRestore>$6: T.class_of(B) = <self>
    <unconditional> -> bb2

# backedges
# - bb23
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(B), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(B)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=-1](<block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(B)):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$5, sig>
    <self>: T.class_of(B) = <selfRestore>$6
    <block-pre-call-temp>$15: Sorbet::Private::Static::Void = <self>: T.class_of(B).sig()
    <selfRestore>$16: T.class_of(B) = <self>
    <unconditional> -> bb6

# backedges
# - bb2
bb5[firstDead=5](<self>: T.class_of(B), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(B)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <cfgAlias>$11: T.class_of(T) = alias <C T>
    <statTemp>$9: Runtime object representing type: T.untyped = <cfgAlias>$11: T.class_of(T).self_type()
    <blockReturnTemp>$7: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.returns(<statTemp>$9: Runtime object representing type: T.untyped)
    <blockReturnTemp>$12: T.noreturn = blockreturn<sig> <blockReturnTemp>$7: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

# backedges
# - bb3
# - bb9
bb6[firstDead=-1](<self>: T.class_of(B), <block-pre-call-temp>$15: Sorbet::Private::Static::Void, <selfRestore>$16: T.class_of(B)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb9 : bb7)

# backedges
# - bb6
bb7[firstDead=-1](<block-pre-call-temp>$15: Sorbet::Private::Static::Void, <selfRestore>$16: T.class_of(B)):
    <statTemp>$13: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$15, sig>
    <self>: T.class_of(B) = <selfRestore>$16
    <block-pre-call-temp>$27: Sorbet::Private::Static::Void = <self>: T.class_of(B).sig()
    <selfRestore>$28: T.class_of(B) = <self>
    <unconditional> -> bb10

# backedges
# - bb6
bb9[firstDead=7](<self>: T.class_of(B), <block-pre-call-temp>$15: Sorbet::Private::Static::Void, <selfRestore>$16: T.class_of(B)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$20: Symbol(:x) = :x
    <cfgAlias>$23: T.class_of(T) = alias <C T>
    <hashTemp>$21: Runtime object representing type: T.untyped = <cfgAlias>$23: T.class_of(T).self_type()
    <statTemp>$18: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$20: Symbol(:x), <hashTemp>$21: Runtime object representing type: T.untyped)
    <blockReturnTemp>$17: T::Private::Methods::DeclBuilder = <statTemp>$18: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$24: T.noreturn = blockreturn<sig> <blockReturnTemp>$17: T::Private::Methods::DeclBuilder
    <unconditional> -> bb6

# backedges
# - bb7
# - bb13
bb10[firstDead=-1](<self>: T.class_of(B), <block-pre-call-temp>$27: Sorbet::Private::Static::Void, <selfRestore>$28: T.class_of(B)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb13 : bb11)

# backedges
# - bb10
bb11[firstDead=-1](<block-pre-call-temp>$27: Sorbet::Private::Static::Void, <selfRestore>$28: T.class_of(B)):
    <statTemp>$25: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$27, sig>
    <self>: T.class_of(B) = <selfRestore>$28
    <block-pre-call-temp>$39: Sorbet::Private::Static::Void = <self>: T.class_of(B).sig()
    <selfRestore>$40: T.class_of(B) = <self>
    <unconditional> -> bb14

# backedges
# - bb10
bb13[firstDead=7](<self>: T.class_of(B), <block-pre-call-temp>$27: Sorbet::Private::Static::Void, <selfRestore>$28: T.class_of(B)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$32: Symbol(:x) = :x
    <cfgAlias>$35: T.class_of(T) = alias <C T>
    <hashTemp>$33: Runtime object representing type: T.untyped = <cfgAlias>$35: T.class_of(T).self_type()
    <statTemp>$30: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$32: Symbol(:x), <hashTemp>$33: Runtime object representing type: T.untyped)
    <blockReturnTemp>$29: T::Private::Methods::DeclBuilder = <statTemp>$30: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$36: T.noreturn = blockreturn<sig> <blockReturnTemp>$29: T::Private::Methods::DeclBuilder
    <unconditional> -> bb10

# backedges
# - bb11
# - bb17
bb14[firstDead=-1](<self>: T.class_of(B), <block-pre-call-temp>$39: Sorbet::Private::Static::Void, <selfRestore>$40: T.class_of(B)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb17 : bb15)

# backedges
# - bb14
bb15[firstDead=-1](<block-pre-call-temp>$39: Sorbet::Private::Static::Void, <selfRestore>$40: T.class_of(B)):
    <statTemp>$37: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$39, sig>
    <self>: T.class_of(B) = <selfRestore>$40
    <block-pre-call-temp>$57: Sorbet::Private::Static::Void = <self>: T.class_of(B).sig()
    <selfRestore>$58: T.class_of(B) = <self>
    <unconditional> -> bb18

# backedges
# - bb14
bb17[firstDead=12](<self>: T.class_of(B), <block-pre-call-temp>$39: Sorbet::Private::Static::Void, <selfRestore>$40: T.class_of(B)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$44: Symbol(:blk) = :blk
    <cfgAlias>$49: T.class_of(T) = alias <C T>
    <statTemp>$47: T.class_of(T.proc) = <cfgAlias>$49: T.class_of(T).proc()
    <hashTemp>$50: Symbol(:arg0) = :arg0
    <cfgAlias>$53: T.class_of(T) = alias <C T>
    <hashTemp>$51: Runtime object representing type: T.untyped = <cfgAlias>$53: T.class_of(T).self_type()
    <statTemp>$46: Runtime object representing type: T.proc.params(arg0: T.untyped).returns(<todo sym>) = <statTemp>$47: T.class_of(T.proc).params(<hashTemp>$50: Symbol(:arg0), <hashTemp>$51: Runtime object representing type: T.untyped)
    <hashTemp>$45: Runtime object representing type: T.proc.params(arg0: T.untyped).void = <statTemp>$46: Runtime object representing type: T.proc.params(arg0: T.untyped).returns(<todo sym>).void()
    <statTemp>$42: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$44: Symbol(:blk), <hashTemp>$45: Runtime object representing type: T.proc.params(arg0: T.untyped).void)
    <blockReturnTemp>$41: T::Private::Methods::DeclBuilder = <statTemp>$42: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$54: T.noreturn = blockreturn<sig> <blockReturnTemp>$41: T::Private::Methods::DeclBuilder
    <unconditional> -> bb14

# backedges
# - bb15
# - bb21
bb18[firstDead=-1](<self>: T.class_of(B), <block-pre-call-temp>$57: Sorbet::Private::Static::Void, <selfRestore>$58: T.class_of(B)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb21 : bb19)

# backedges
# - bb18
bb19[firstDead=-1](<block-pre-call-temp>$57: Sorbet::Private::Static::Void, <selfRestore>$58: T.class_of(B)):
    <statTemp>$55: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$57, sig>
    <self>: T.class_of(B) = <selfRestore>$58
    <block-pre-call-temp>$74: Sorbet::Private::Static::Void = <self>: T.class_of(B).sig()
    <selfRestore>$75: T.class_of(B) = <self>
    <unconditional> -> bb22

# backedges
# - bb18
bb21[firstDead=10](<self>: T.class_of(B), <block-pre-call-temp>$57: Sorbet::Private::Static::Void, <selfRestore>$58: T.class_of(B)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$62: Symbol(:x) = :x
    <cfgAlias>$65: T.class_of(T) = alias <C T>
    <cfgAlias>$68: T.class_of(T) = alias <C T>
    <statTemp>$66: Runtime object representing type: T.untyped = <cfgAlias>$68: T.class_of(T).self_type()
    <cfgAlias>$70: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$63: Runtime object representing type: T.untyped = <cfgAlias>$65: T.class_of(T).any(<statTemp>$66: Runtime object representing type: T.untyped, <cfgAlias>$70: T.class_of(Integer))
    <statTemp>$60: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$62: Symbol(:x), <hashTemp>$63: Runtime object representing type: T.untyped)
    <blockReturnTemp>$59: T::Private::Methods::DeclBuilder = <statTemp>$60: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$71: T.noreturn = blockreturn<sig> <blockReturnTemp>$59: T::Private::Methods::DeclBuilder
    <unconditional> -> bb18

# backedges
# - bb19
# - bb25
bb22[firstDead=-1](<self>: T.class_of(B), <block-pre-call-temp>$74: Sorbet::Private::Static::Void, <selfRestore>$75: T.class_of(B)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb25 : bb23)

# backedges
# - bb22
bb23[firstDead=10](<block-pre-call-temp>$74: Sorbet::Private::Static::Void, <selfRestore>$75: T.class_of(B)):
    <statTemp>$72: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$74, sig>
    <self>: T.class_of(B) = <selfRestore>$75
    <cfgAlias>$87: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$89: T.class_of(T) = alias <C T>
    <statTemp>$84: T.class_of(B) = <self>: T.class_of(B).extend(<cfgAlias>$87: T.class_of(T::Sig))
    <statTemp>$94: Symbol(:takes_self_private) = :takes_self_private
    <statTemp>$92: T.class_of(B) = <self>: T.class_of(B).private(<statTemp>$94: Symbol(:takes_self_private))
    <statTemp>$98: Symbol(:takes_self_or_integer) = :takes_self_or_integer
    <statTemp>$96: T.class_of(B) = <self>: T.class_of(B).private(<statTemp>$98: Symbol(:takes_self_or_integer))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb22
bb25[firstDead=7](<self>: T.class_of(B), <block-pre-call-temp>$74: Sorbet::Private::Static::Void, <selfRestore>$75: T.class_of(B)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$79: Symbol(:other) = :other
    <cfgAlias>$82: T.class_of(T) = alias <C T>
    <hashTemp>$80: Runtime object representing type: T.untyped = <cfgAlias>$82: T.class_of(T).self_type()
    <statTemp>$77: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$79: Symbol(:other), <hashTemp>$80: Runtime object representing type: T.untyped)
    <blockReturnTemp>$76: T::Private::Methods::DeclBuilder = <statTemp>$77: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$83: T.noreturn = blockreturn<sig> <blockReturnTemp>$76: T::Private::Methods::DeclBuilder
    <unconditional> -> bb22

}

