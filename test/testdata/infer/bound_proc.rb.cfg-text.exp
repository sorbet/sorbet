method ::<Class:<root>>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U <root>>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$8: T.class_of(Base) = alias <C Base>
    <statTemp>$4: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$8: T.class_of(Base))
    <cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$13: T.class_of(Base) = alias <C Base>
    <statTemp>$9: Sorbet::Private::Static::Void = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$13: T.class_of(Base))
    <cfgAlias>$17: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$19: T.class_of(Concern) = alias <C Concern>
    <statTemp>$15: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$19: T.class_of(Concern))
    <cfgAlias>$22: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$24: T.class_of(Concern) = alias <C Concern>
    <statTemp>$20: Sorbet::Private::Static::Void = <cfgAlias>$22: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$24: T.class_of(Concern))
    <cfgAlias>$28: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$30: T.class_of(Readable) = alias <C Readable>
    <statTemp>$26: Sorbet::Private::Static::Void = <cfgAlias>$28: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$30: T.class_of(Readable))
    <cfgAlias>$33: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$35: T.class_of(Readable) = alias <C Readable>
    <statTemp>$31: Sorbet::Private::Static::Void = <cfgAlias>$33: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$35: T.class_of(Readable))
    <cfgAlias>$39: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$41: T.class_of(Writable) = alias <C Writable>
    <statTemp>$37: Sorbet::Private::Static::Void = <cfgAlias>$39: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$41: T.class_of(Writable))
    <cfgAlias>$44: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$46: T.class_of(Writable) = alias <C Writable>
    <statTemp>$42: Sorbet::Private::Static::Void = <cfgAlias>$44: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$46: T.class_of(Writable))
    <cfgAlias>$50: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$52: T.class_of(Shareable) = alias <C Shareable>
    <statTemp>$48: Sorbet::Private::Static::Void = <cfgAlias>$50: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$52: T.class_of(Shareable))
    <cfgAlias>$55: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$57: T.class_of(Shareable) = alias <C Shareable>
    <statTemp>$53: Sorbet::Private::Static::Void = <cfgAlias>$55: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$57: T.class_of(Shareable))
    <cfgAlias>$61: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$63: T.class_of(Post) = alias <C Post>
    <statTemp>$59: Sorbet::Private::Static::Void = <cfgAlias>$61: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$63: T.class_of(Post))
    <cfgAlias>$66: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$68: T.class_of(Post) = alias <C Post>
    <statTemp>$64: Sorbet::Private::Static::Void = <cfgAlias>$66: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$68: T.class_of(Post))
    <cfgAlias>$71: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$73: T.class_of(Base) = alias <C Base>
    <statTemp>$69: Sorbet::Private::Static::Void = <cfgAlias>$71: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$73: T.class_of(Base))
    <cfgAlias>$77: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$79: T.class_of(Article) = alias <C Article>
    <statTemp>$75: Sorbet::Private::Static::Void = <cfgAlias>$77: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$79: T.class_of(Article))
    <cfgAlias>$82: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$84: T.class_of(Article) = alias <C Article>
    <statTemp>$80: Sorbet::Private::Static::Void = <cfgAlias>$82: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$84: T.class_of(Article))
    <cfgAlias>$87: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$89: T.class_of(Base) = alias <C Base>
    <statTemp>$85: Sorbet::Private::Static::Void = <cfgAlias>$87: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$89: T.class_of(Base))
    <cfgAlias>$93: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$95: T.class_of(A) = alias <C A>
    <statTemp>$91: Sorbet::Private::Static::Void = <cfgAlias>$93: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$95: T.class_of(A))
    <cfgAlias>$98: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$100: T.class_of(A) = alias <C A>
    <statTemp>$96: Sorbet::Private::Static::Void = <cfgAlias>$98: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$100: T.class_of(A))
    <cfgAlias>$104: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$106: T.class_of(B) = alias <C B>
    <statTemp>$102: Sorbet::Private::Static::Void = <cfgAlias>$104: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$106: T.class_of(B))
    <cfgAlias>$109: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$111: T.class_of(B) = alias <C B>
    <statTemp>$107: Sorbet::Private::Static::Void = <cfgAlias>$109: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$111: T.class_of(B))
    <cfgAlias>$114: T.class_of(B) = alias <C B>
    <block-pre-call-temp>$115: Sorbet::Private::Static::Void = <cfgAlias>$114: T.class_of(B).class_helper()
    <selfRestore>$116: T.class_of(<root>) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(<root>), <block-pre-call-temp>$115: Sorbet::Private::Static::Void, <selfRestore>$116: T.class_of(<root>))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$115: Sorbet::Private::Static::Void, <selfRestore>$116: T.class_of(<root>))
    <statTemp>$112: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$115, class_helper>
    <self>: T.class_of(<root>) = <selfRestore>$116
    <cfgAlias>$135: T.class_of(T) = alias <C T>
    <statTemp>$133: T.class_of(<root>) = <cfgAlias>$135: T.class_of(T).reveal_type(<self>: T.class_of(<root>))
    <cfgAlias>$140: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$142: T.class_of(N) = alias <C N>
    <statTemp>$138: Sorbet::Private::Static::Void = <cfgAlias>$140: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$142: T.class_of(N))
    <cfgAlias>$145: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$147: T.class_of(N) = alias <C N>
    <statTemp>$143: Sorbet::Private::Static::Void = <cfgAlias>$145: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$147: T.class_of(N))
    <cfgAlias>$151: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$153: T.class_of(M) = alias <C M>
    <statTemp>$149: Sorbet::Private::Static::Void = <cfgAlias>$151: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$153: T.class_of(M))
    <cfgAlias>$156: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$158: T.class_of(M) = alias <C M>
    <statTemp>$154: Sorbet::Private::Static::Void = <cfgAlias>$156: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$158: T.class_of(M))
    <cfgAlias>$162: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$164: T.class_of(ThisSelf) = alias <C ThisSelf>
    <statTemp>$160: Sorbet::Private::Static::Void = <cfgAlias>$162: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$164: T.class_of(ThisSelf))
    <cfgAlias>$167: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$169: T.class_of(ThisSelf) = alias <C ThisSelf>
    <statTemp>$165: Sorbet::Private::Static::Void = <cfgAlias>$167: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$169: T.class_of(ThisSelf))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb3 -> bb1)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(<root>), <block-pre-call-temp>$115: Sorbet::Private::Static::Void, <selfRestore>$116: T.class_of(<root>))
    outerLoops: 1
    <self>: T.class_of(<root>) = loadSelf
    <cfgAlias>$123: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$125: T.class_of(B) = alias <C B>
    <statTemp>$121: Sorbet::Private::Static::Void = <cfgAlias>$123: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$125: T.class_of(B))
    <castTemp>$126: T.class_of(<root>) = <self>
    <self>: B = cast(<castTemp>$126: T.class_of(<root>), B);
    <cfgAlias>$129: T.class_of(T) = alias <C T>
    <statTemp>$127: B = <cfgAlias>$129: T.class_of(T).reveal_type(<self>: B)
    <blockReturnTemp>$119: T.untyped = <self>: B.instance_helper()
    <blockReturnTemp>$132: T.noreturn = blockreturn<class_helper> <blockReturnTemp>$119: T.untyped
    <unconditional>(bb5 -> bb2)

}

method ::<Class:Base>#before_save {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Base) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Base>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Base>> $1><C <U <AttachedClass>>>)
      ]
    });
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Base>#before_create {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Base) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Base>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Base>> $1><C <U <AttachedClass>>>)
      ]
    });
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Base>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Base) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Base>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Base>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$7: Symbol(:before_save) = :before_save
    <statTemp>$8: Symbol(:normal) = :normal
    <statTemp>$3: Symbol(:before_save) = <cfgAlias>$5: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(Base), <statTemp>$7: Symbol(:before_save), <statTemp>$8: Symbol(:normal))
    <cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$13: Symbol(:before_create) = :before_create
    <statTemp>$14: Symbol(:normal) = :normal
    <statTemp>$9: Symbol(:before_create) = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(Base), <statTemp>$13: Symbol(:before_create), <statTemp>$14: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::Concern#included {

bb0(rubyBlockId=0):
    blockargs=()
    @block$3: T.untyped = alias <C <undeclared-field-stub>> (@block)
    <self>: Concern = cast(<self>: NilClass, Concern);
    block: T.untyped = load_arg(block)
    @block$3: T.untyped = block
    <returnMethodTemp>$2: T.untyped = @block$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Concern>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Concern) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Concern>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Concern>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$4: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$6: Symbol(:included) = :included
    <statTemp>$7: Symbol(:normal) = :normal
    <returnMethodTemp>$2: Symbol(:included) = <cfgAlias>$4: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Concern), <statTemp>$6: Symbol(:included), <statTemp>$7: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:included)
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Readable>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Readable) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Readable>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Readable>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Readable) = <self>: T.class_of(Readable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Readable).included()
    <selfRestore>$10: T.class_of(Readable) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Readable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable))
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb3 -> bb1)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Readable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable))
    outerLoops: 1
    <self>: T.class_of(Readable) = loadSelf
    <statTemp>$15: Symbol(:do_this) = :do_this
    <blockReturnTemp>$13: T.untyped = <self>: T.class_of(Readable).before_create(<statTemp>$15: Symbol(:do_this))
    <blockReturnTemp>$16: T.noreturn = blockreturn<included> <blockReturnTemp>$13: T.untyped
    <unconditional>(bb5 -> bb2)

}

method ::<Class:Writable>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Writable) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Writable>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Writable>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Writable) = <self>: T.class_of(Writable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Writable).included()
    <selfRestore>$10: T.class_of(Writable) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Writable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable))
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb3 -> bb1)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Writable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable))
    outerLoops: 1
    <self>: T.class_of(Writable) = loadSelf
    <cfgAlias>$17: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$20: T.class_of(T) = alias <C T>
    <cfgAlias>$23: T.class_of(T) = alias <C T>
    <cfgAlias>$25: T.class_of(Article) = alias <C Article>
    <statTemp>$21: <Type: T.class_of(Article)> = <cfgAlias>$23: T.class_of(T).class_of(<cfgAlias>$25: T.class_of(Article))
    <cfgAlias>$28: T.class_of(T) = alias <C T>
    <cfgAlias>$30: T.class_of(Post) = alias <C Post>
    <statTemp>$26: <Type: T.class_of(Post)> = <cfgAlias>$28: T.class_of(T).class_of(<cfgAlias>$30: T.class_of(Post))
    <statTemp>$18: <Type: T.any(T.class_of(Article), T.class_of(Post))> = <cfgAlias>$20: T.class_of(T).any(<statTemp>$21: <Type: T.class_of(Article)>, <statTemp>$26: <Type: T.class_of(Post)>)
    <statTemp>$15: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<statTemp>$18: <Type: T.any(T.class_of(Article), T.class_of(Post))>)
    <castTemp>$31: T.class_of(Writable) = <self>
    <self>: T.any(T.class_of(Article), T.class_of(Post)) = cast(<castTemp>$31: T.class_of(Writable), AppliedType {
          klass = <S <C <U Article>> $1>
          targs = [
            <C <U <AttachedClass>>> = Article
          ]
        } | AppliedType {
          klass = <S <C <U Post>> $1>
          targs = [
            <C <U <AttachedClass>>> = Post
          ]
        });
    <statTemp>$33: Symbol(:name) = :name
    <blockReturnTemp>$13: T.untyped = <self>: T.any(T.class_of(Article), T.class_of(Post)).some_class_method(<statTemp>$33: Symbol(:name))
    <blockReturnTemp>$34: T.noreturn = blockreturn<included> <blockReturnTemp>$13: T.untyped
    <unconditional>(bb5 -> bb2)

}

method ::<Class:Shareable>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Shareable) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Shareable>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Shareable>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Shareable) = <self>: T.class_of(Shareable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Shareable).included()
    <selfRestore>$10: T.class_of(Shareable) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Shareable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable))
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb3 -> bb1)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Shareable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable))
    outerLoops: 1
    <self>: T.class_of(Shareable) = loadSelf
    <cfgAlias>$17: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$20: T.class_of(T) = alias <C T>
    <cfgAlias>$22: T.class_of(Article) = alias <C Article>
    <statTemp>$18: <Type: T.class_of(Article)> = <cfgAlias>$20: T.class_of(T).class_of(<cfgAlias>$22: T.class_of(Article))
    <statTemp>$15: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<statTemp>$18: <Type: T.class_of(Article)>)
    <castTemp>$23: T.class_of(Shareable) = <self>
    <self>: T.class_of(Article) = cast(<castTemp>$23: T.class_of(Shareable), AppliedType {
      klass = <S <C <U Article>> $1>
      targs = [
        <C <U <AttachedClass>>> = Article
      ]
    });
    <statTemp>$25: Symbol(:do_this) = :do_this
    <blockReturnTemp>$13: T.untyped = <self>: T.class_of(Article).before_save(<statTemp>$25: Symbol(:do_this))
    <blockReturnTemp>$26: T.noreturn = blockreturn<included> <blockReturnTemp>$13: T.untyped
    <unconditional>(bb5 -> bb2)

}

method ::<Class:Post>#some_class_method {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Post) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Post>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Post>> $1><C <U <AttachedClass>>>)
      ]
    });
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::Post#author {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Post = cast(<self>: NilClass, Post);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::Post#should_run_callback? {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Post = cast(<self>: NilClass, Post);
    <returnMethodTemp>$2: TrueClass = true
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: TrueClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::Post#score {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Post = cast(<self>: NilClass, Post);
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$7: T.class_of(Integer) = alias <C Integer>
    <statTemp>$3: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$7: T.class_of(Integer))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Post>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Post) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Post>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Post>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(Readable) = alias <C Readable>
    <statTemp>$3: T.class_of(Post) = <self>: T.class_of(Post).include(<cfgAlias>$6: T.class_of(Readable))
    <cfgAlias>$10: T.class_of(Writable) = alias <C Writable>
    <statTemp>$7: T.class_of(Post) = <self>: T.class_of(Post).include(<cfgAlias>$10: T.class_of(Writable))
    <statTemp>$12: T.class_of(Post) = <self>
    <statTemp>$13: Symbol(:run_callback) = :run_callback
    <hashTemp>$14: Symbol(:if) = :if
    <cfgAlias>$17: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$18: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(Kernel).lambda()
    <selfRestore>$19: T.class_of(Post) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Post), <statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post))
    <hashTemp>$15: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$18, lambda>
    <self>: T.class_of(Post) = <selfRestore>$19
    <statTemp>$11: T.untyped = <statTemp>$12: T.class_of(Post).before_create(<statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <hashTemp>$15: T.proc.returns(T.untyped))
    <cfgAlias>$27: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$29: Symbol(:some_class_method) = :some_class_method
    <statTemp>$30: Symbol(:normal) = :normal
    <statTemp>$25: Symbol(:some_class_method) = <cfgAlias>$27: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(Post), <statTemp>$29: Symbol(:some_class_method), <statTemp>$30: Symbol(:normal))
    <cfgAlias>$33: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$35: Symbol(:author) = :author
    <statTemp>$36: Symbol(:normal) = :normal
    <statTemp>$31: Symbol(:author) = <cfgAlias>$33: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Post), <statTemp>$35: Symbol(:author), <statTemp>$36: Symbol(:normal))
    <cfgAlias>$39: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$41: Symbol(:should_run_callback?) = :should_run_callback?
    <statTemp>$42: Symbol(:normal) = :normal
    <statTemp>$37: Symbol(:should_run_callback?) = <cfgAlias>$39: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Post), <statTemp>$41: Symbol(:should_run_callback?), <statTemp>$42: Symbol(:normal))
    <cfgAlias>$45: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$47: Symbol(:score) = :score
    <statTemp>$48: Symbol(:normal) = :normal
    <statTemp>$43: Symbol(:score) = <cfgAlias>$45: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Post), <statTemp>$47: Symbol(:score), <statTemp>$48: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb3 -> bb1)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Post), <statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post))
    outerLoops: 1
    <self>: T.class_of(Post) = loadSelf
    <blockReturnTemp>$22: T.untyped = <self>: T.class_of(Post).should_run_callback?()
    <blockReturnTemp>$24: T.noreturn = blockreturn<lambda> <blockReturnTemp>$22: T.untyped
    <unconditional>(bb5 -> bb2)

}

method ::Article#author {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Article = cast(<self>: NilClass, Article);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::Article#should_run_callback? {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: Article = cast(<self>: NilClass, Article);
    <returnMethodTemp>$2: TrueClass = true
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: TrueClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:Article>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(Article) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U Article>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U Article>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(Writable) = alias <C Writable>
    <statTemp>$3: T.class_of(Article) = <self>: T.class_of(Article).include(<cfgAlias>$6: T.class_of(Writable))
    <cfgAlias>$10: T.class_of(Shareable) = alias <C Shareable>
    <statTemp>$7: T.class_of(Article) = <self>: T.class_of(Article).include(<cfgAlias>$10: T.class_of(Shareable))
    <statTemp>$12: T.class_of(Article) = <self>
    <statTemp>$13: Symbol(:run_callback) = :run_callback
    <hashTemp>$14: Symbol(:if) = :if
    <cfgAlias>$17: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$18: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(Kernel).lambda()
    <selfRestore>$19: T.class_of(Article) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Article), <statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article))
    <hashTemp>$15: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$18, lambda>
    <self>: T.class_of(Article) = <selfRestore>$19
    <statTemp>$11: T.untyped = <statTemp>$12: T.class_of(Article).before_create(<statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <hashTemp>$15: T.proc.returns(T.untyped))
    <cfgAlias>$33: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$35: Symbol(:author) = :author
    <statTemp>$36: Symbol(:normal) = :normal
    <statTemp>$31: Symbol(:author) = <cfgAlias>$33: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Article), <statTemp>$35: Symbol(:author), <statTemp>$36: Symbol(:normal))
    <cfgAlias>$39: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$41: Symbol(:should_run_callback?) = :should_run_callback?
    <statTemp>$42: Symbol(:normal) = :normal
    <statTemp>$37: Symbol(:should_run_callback?) = <cfgAlias>$39: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(Article), <statTemp>$41: Symbol(:should_run_callback?), <statTemp>$42: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb3 -> bb1)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(Article), <statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article))
    outerLoops: 1
    <self>: T.class_of(Article) = loadSelf
    <cfgAlias>$26: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$28: T.class_of(Article) = alias <C Article>
    <statTemp>$24: Sorbet::Private::Static::Void = <cfgAlias>$26: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$28: T.class_of(Article))
    <castTemp>$29: T.class_of(Article) = <self>
    <self>: Article = cast(<castTemp>$29: T.class_of(Article), Article);
    <blockReturnTemp>$22: T.untyped = <self>: Article.should_run_callback?()
    <blockReturnTemp>$30: T.noreturn = blockreturn<lambda> <blockReturnTemp>$22: T.untyped
    <unconditional>(bb5 -> bb2)

}

method ::A#instance_helper {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: A = cast(<self>: NilClass, A);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:A>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(A) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U A>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U A>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$7: Symbol(:instance_helper) = :instance_helper
    <statTemp>$8: Symbol(:normal) = :normal
    <statTemp>$3: Symbol(:instance_helper) = <cfgAlias>$5: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(A), <statTemp>$7: Symbol(:instance_helper), <statTemp>$8: Symbol(:normal))
    <cfgAlias>$11: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$12: Sorbet::Private::Static::Void = <cfgAlias>$11: T.class_of(Kernel).lambda()
    <selfRestore>$13: T.class_of(A) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(A), <block-pre-call-temp>$12: Sorbet::Private::Static::Void, <selfRestore>$13: T.class_of(A))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$12: Sorbet::Private::Static::Void, <selfRestore>$13: T.class_of(A))
    f: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$12, lambda>
    <self>: T.class_of(A) = <selfRestore>$13
    <cfgAlias>$32: T.class_of(T) = alias <C T>
    <statTemp>$30: T.class_of(A) = <cfgAlias>$32: T.class_of(T).reveal_type(<self>: T.class_of(A))
    <statTemp>$34: NilClass = <self>: T.class_of(A).puts(f: T.proc.returns(T.untyped))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb3 -> bb1)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(A), <block-pre-call-temp>$12: Sorbet::Private::Static::Void, <selfRestore>$13: T.class_of(A))
    outerLoops: 1
    <self>: T.class_of(A) = loadSelf
    <cfgAlias>$20: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$22: T.class_of(A) = alias <C A>
    <statTemp>$18: Sorbet::Private::Static::Void = <cfgAlias>$20: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$22: T.class_of(A))
    <castTemp>$23: T.class_of(A) = <self>
    <self>: A = cast(<castTemp>$23: T.class_of(A), A);
    <cfgAlias>$26: T.class_of(T) = alias <C T>
    <statTemp>$24: A = <cfgAlias>$26: T.class_of(T).reveal_type(<self>: A)
    <blockReturnTemp>$16: T.untyped = <self>: A.instance_helper()
    <blockReturnTemp>$29: T.noreturn = blockreturn<lambda> <blockReturnTemp>$16: T.untyped
    <unconditional>(bb5 -> bb2)

}

method ::<Class:B>#class_helper {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(B) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U B>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U B>> $1><C <U <AttachedClass>>>)
      ]
    });
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::B#instance_helper {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: B = cast(<self>: NilClass, B);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:B>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(B) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U B>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U B>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$7: TrueClass = true
    <statTemp>$8: Symbol(:class_helper) = :class_helper
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(B), <statTemp>$7: TrueClass, <statTemp>$8: Symbol(:class_helper))
    <selfRestore>$10: T.class_of(B) = <self>
    <unconditional>(bb0 -> bb2)

# backedges
#  bb3(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
#  bb5(rubyBlockId=1)
bb2(rubyBlockId=1):
    blockargs=(<self>: T.class_of(B), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(B))
    outerLoops: 1
    <block-call>: NilClass(bb2 -> bb5)

# backedges
#  bb2(rubyBlockId=1)
bb3(rubyBlockId=0):
    blockargs=(<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(B))
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$9, sig>
    <self>: T.class_of(B) = <selfRestore>$10
    <cfgAlias>$25: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$27: T.class_of(T) = alias <C T>
    <statTemp>$22: T.class_of(B) = <self>: T.class_of(B).extend(<cfgAlias>$25: T.class_of(T::Sig))
    <cfgAlias>$30: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$32: Symbol(:class_helper) = :class_helper
    <statTemp>$33: Symbol(:normal) = :normal
    <statTemp>$28: Symbol(:class_helper) = <cfgAlias>$30: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(B), <statTemp>$32: Symbol(:class_helper), <statTemp>$33: Symbol(:normal))
    <cfgAlias>$36: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$38: Symbol(:instance_helper) = :instance_helper
    <statTemp>$39: Symbol(:normal) = :normal
    <statTemp>$34: Symbol(:instance_helper) = <cfgAlias>$36: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(B), <statTemp>$38: Symbol(:instance_helper), <statTemp>$39: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb3 -> bb1)

# backedges
#  bb2(rubyBlockId=1)
bb5(rubyBlockId=1):
    blockargs=(<self>: T.class_of(B), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(B))
    outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf
    <hashTemp>$16: Symbol(:blk) = :blk
    <cfgAlias>$20: T.class_of(T) = alias <C T>
    <statTemp>$18: T.class_of(T.proc) = <cfgAlias>$20: T.class_of(T).proc()
    <hashTemp>$17: T.class_of(T.proc) = <statTemp>$18: T.class_of(T.proc).void()
    <statTemp>$14: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$16: Symbol(:blk), <hashTemp>$17: T.class_of(T.proc))
    <blockReturnTemp>$13: T::Private::Methods::DeclBuilder = <statTemp>$14: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$21: T.noreturn = blockreturn<sig> <blockReturnTemp>$13: T::Private::Methods::DeclBuilder
    <unconditional>(bb5 -> bb2)

}

method ::N#helper_from_N {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: N = cast(<self>: NilClass, N);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:N>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(N) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U N>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U N>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$4: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$6: Symbol(:helper_from_N) = :helper_from_N
    <statTemp>$7: Symbol(:normal) = :normal
    <returnMethodTemp>$2: Symbol(:helper_from_N) = <cfgAlias>$4: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(N), <statTemp>$6: Symbol(:helper_from_N), <statTemp>$7: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:helper_from_N)
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::M#helper_from_M {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: M = cast(<self>: NilClass, M);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::M#main {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: M = cast(<self>: NilClass, M);
    <cfgAlias>$6: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$9: T.class_of(T) = alias <C T>
    <cfgAlias>$11: T.class_of(M) = alias <C M>
    <cfgAlias>$13: T.class_of(N) = alias <C N>
    <statTemp>$7: <Type: T.all(M, N)> = <cfgAlias>$9: T.class_of(T).all(<cfgAlias>$11: T.class_of(M), <cfgAlias>$13: T.class_of(N))
    <statTemp>$4: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<statTemp>$7: <Type: T.all(M, N)>)
    <castTemp>$14: M = <self>
    <self>: T.all(M, N) = cast(<castTemp>$14: M, M & N);
    <cfgAlias>$17: T.class_of(T) = alias <C T>
    <statTemp>$15: T.all(M, N) = <cfgAlias>$17: T.class_of(T).reveal_type(<self>: T.all(M, N))
    <statTemp>$19: T.untyped = <self>: T.all(M, N).helper_from_M()
    <returnMethodTemp>$2: T.untyped = <self>: T.all(M, N).helper_from_N()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:M>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(M) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U M>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U M>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$3: T.class_of(M) = <self>: T.class_of(M).extend(<cfgAlias>$6: T.class_of(T::Sig))
    <cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$13: Symbol(:helper_from_M) = :helper_from_M
    <statTemp>$14: Symbol(:normal) = :normal
    <statTemp>$9: Symbol(:helper_from_M) = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(M), <statTemp>$13: Symbol(:helper_from_M), <statTemp>$14: Symbol(:normal))
    <cfgAlias>$17: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$19: Symbol(:main) = :main
    <statTemp>$20: Symbol(:normal) = :normal
    <statTemp>$15: Symbol(:main) = <cfgAlias>$17: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(M), <statTemp>$19: Symbol(:main), <statTemp>$20: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::ThisSelf#main {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: ThisSelf = cast(<self>: NilClass, ThisSelf);
    <cfgAlias>$6: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$8: T.class_of(Kernel) = alias <C Kernel>
    <statTemp>$4: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$8: T.class_of(Kernel))
    <castTemp>$9: ThisSelf = <self>
    <self>: Kernel = cast(<castTemp>$9: ThisSelf, Kernel);
    this: Kernel = <self>
    <cfgAlias>$12: T.class_of(T) = alias <C T>
    <statTemp>$10: Kernel = <cfgAlias>$12: T.class_of(T).reveal_type(this: Kernel)
    <returnMethodTemp>$2: NilClass = this: Kernel.puts()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

method ::<Class:ThisSelf>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(ThisSelf) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U ThisSelf>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U ThisSelf>> $1><C <U <AttachedClass>>>)
      ]
    });
    <cfgAlias>$6: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$3: T.class_of(ThisSelf) = <self>: T.class_of(ThisSelf).extend(<cfgAlias>$6: T.class_of(T::Sig))
    <cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$13: Symbol(:main) = :main
    <statTemp>$14: Symbol(:normal) = :normal
    <statTemp>$9: Symbol(:main) = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(ThisSelf), <statTemp>$13: Symbol(:main), <statTemp>$14: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=()
    <unconditional>(bb1 -> bb1)

}

