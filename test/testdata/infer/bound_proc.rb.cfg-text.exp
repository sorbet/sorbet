method ::<Class:<root>>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(<root>) = cast(<self>: NilClass, T.class_of(<root>));
    <cfgAlias>$7: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$9: T.class_of(Base) = alias <C Base>
    <statTemp>$5: Sorbet::Private::Static::Void = <cfgAlias>$7: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$9: T.class_of(Base))
    <cfgAlias>$14: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$16: T.class_of(Concern) = alias <C Concern>
    <statTemp>$12: Sorbet::Private::Static::Void = <cfgAlias>$14: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$16: T.class_of(Concern))
    <cfgAlias>$21: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$23: T.class_of(Readable) = alias <C Readable>
    <statTemp>$19: Sorbet::Private::Static::Void = <cfgAlias>$21: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$23: T.class_of(Readable))
    <cfgAlias>$28: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$30: T.class_of(Writable) = alias <C Writable>
    <statTemp>$26: Sorbet::Private::Static::Void = <cfgAlias>$28: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$30: T.class_of(Writable))
    <cfgAlias>$35: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$37: T.class_of(Shareable) = alias <C Shareable>
    <statTemp>$33: Sorbet::Private::Static::Void = <cfgAlias>$35: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$37: T.class_of(Shareable))
    <cfgAlias>$42: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$44: T.class_of(Post) = alias <C Post>
    <statTemp>$40: Sorbet::Private::Static::Void = <cfgAlias>$42: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$44: T.class_of(Post))
    <cfgAlias>$47: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$49: T.class_of(Base) = alias <C Base>
    <statTemp>$45: Sorbet::Private::Static::Void = <cfgAlias>$47: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$49: T.class_of(Base))
    <cfgAlias>$54: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$56: T.class_of(Article) = alias <C Article>
    <statTemp>$52: Sorbet::Private::Static::Void = <cfgAlias>$54: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$56: T.class_of(Article))
    <cfgAlias>$59: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$61: T.class_of(Base) = alias <C Base>
    <statTemp>$57: Sorbet::Private::Static::Void = <cfgAlias>$59: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$61: T.class_of(Base))
    <cfgAlias>$66: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$68: T.class_of(A) = alias <C A>
    <statTemp>$64: Sorbet::Private::Static::Void = <cfgAlias>$66: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$68: T.class_of(A))
    <cfgAlias>$73: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$75: T.class_of(B) = alias <C B>
    <statTemp>$71: Sorbet::Private::Static::Void = <cfgAlias>$73: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$75: T.class_of(B))
    <cfgAlias>$78: T.class_of(B) = alias <C B>
    <block-pre-call-temp>$79: Sorbet::Private::Static::Void = <cfgAlias>$78: T.class_of(B).class_helper()
    <selfRestore>$80: T.class_of(<root>) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(<root>), <block-pre-call-temp>$79: Sorbet::Private::Static::Void, <selfRestore>$80: T.class_of(<root>)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=17](<block-pre-call-temp>$79: Sorbet::Private::Static::Void, <selfRestore>$80: T.class_of(<root>)):
    <statTemp>$76: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$79, class_helper>
    <self>: T.class_of(<root>) = <selfRestore>$80
    <cfgAlias>$98: T.class_of(T) = alias <C T>
    <statTemp>$96: T.class_of(<root>) = <cfgAlias>$98: T.class_of(T).reveal_type(<self>: T.class_of(<root>))
    <cfgAlias>$104: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$106: T.class_of(N) = alias <C N>
    <statTemp>$102: Sorbet::Private::Static::Void = <cfgAlias>$104: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$106: T.class_of(N))
    <cfgAlias>$111: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$113: T.class_of(M) = alias <C M>
    <statTemp>$109: Sorbet::Private::Static::Void = <cfgAlias>$111: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$113: T.class_of(M))
    <cfgAlias>$118: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$120: T.class_of(ThisSelf) = alias <C ThisSelf>
    <statTemp>$116: Sorbet::Private::Static::Void = <cfgAlias>$118: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$120: T.class_of(ThisSelf))
    <cfgAlias>$125: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$127: T.class_of(Rescues) = alias <C Rescues>
    <statTemp>$123: Sorbet::Private::Static::Void = <cfgAlias>$125: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$127: T.class_of(Rescues))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=10](<self>: T.class_of(<root>), <block-pre-call-temp>$79: Sorbet::Private::Static::Void, <selfRestore>$80: T.class_of(<root>)):
    # outerLoops: 1
    <self>: T.class_of(<root>) = loadSelf(class_helper)
    <cfgAlias>$86: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$88: T.class_of(B) = alias <C B>
    <statTemp>$84: Sorbet::Private::Static::Void = <cfgAlias>$86: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$88: T.class_of(B))
    <castTemp>$89: T.class_of(<root>) = <self>
    <self>: B = cast(<castTemp>$89: T.class_of(<root>), B);
    <cfgAlias>$92: T.class_of(T) = alias <C T>
    <statTemp>$90: B = <cfgAlias>$92: T.class_of(T).reveal_type(<self>: B)
    <blockReturnTemp>$82: T.untyped = <self>: B.instance_helper()
    <blockReturnTemp>$95: T.noreturn = blockreturn<class_helper> <blockReturnTemp>$82: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Base>#before_save {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(Base) = cast(<self>: NilClass, T.class_of(Base));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Base>#before_create {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(Base) = cast(<self>: NilClass, T.class_of(Base));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Base>#<static-init> {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(Base) = cast(<self>: NilClass, T.class_of(Base));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Concern#included {

bb0[rubyRegionId=0, firstDead=6]():
    @block$3: T.untyped = alias <C <undeclared-field-stub>> (@block)
    <self>: Concern = cast(<self>: NilClass, Concern);
    block: T.untyped = load_arg(block)
    @block$3: T.untyped = block
    <returnMethodTemp>$2: T.untyped = @block$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Concern>#<static-init> {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: T.class_of(Concern) = cast(<self>: NilClass, T.class_of(Concern));
    <returnMethodTemp>$2: Symbol(:included) = :included
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:included)
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Readable>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Readable) = cast(<self>: NilClass, T.class_of(Readable));
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Readable) = <self>: T.class_of(Readable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Readable).included()
    <selfRestore>$10: T.class_of(Readable) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Readable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=2](<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable)):
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=4](<self>: T.class_of(Readable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable)):
    # outerLoops: 1
    <self>: T.class_of(Readable) = loadSelf(included)
    <statTemp>$14: Symbol(:do_this) = :do_this
    <blockReturnTemp>$12: T.untyped = <self>: T.class_of(Readable).before_create(<statTemp>$14: Symbol(:do_this))
    <blockReturnTemp>$15: T.noreturn = blockreturn<included> <blockReturnTemp>$12: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Writable>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Writable) = cast(<self>: NilClass, T.class_of(Writable));
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Writable) = <self>: T.class_of(Writable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Writable).included()
    <selfRestore>$10: T.class_of(Writable) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Writable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=2](<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable)):
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=16](<self>: T.class_of(Writable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable)):
    # outerLoops: 1
    <self>: T.class_of(Writable) = loadSelf(included)
    <cfgAlias>$16: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$19: T.class_of(T) = alias <C T>
    <cfgAlias>$22: T.class_of(T) = alias <C T>
    <cfgAlias>$24: T.class_of(Article) = alias <C Article>
    <statTemp>$20: Runtime object representing type: T.class_of(Article) = <cfgAlias>$22: T.class_of(T).class_of(<cfgAlias>$24: T.class_of(Article))
    <cfgAlias>$27: T.class_of(T) = alias <C T>
    <cfgAlias>$29: T.class_of(Post) = alias <C Post>
    <statTemp>$25: Runtime object representing type: T.class_of(Post) = <cfgAlias>$27: T.class_of(T).class_of(<cfgAlias>$29: T.class_of(Post))
    <statTemp>$17: Runtime object representing type: T.any(T.class_of(Article), T.class_of(Post)) = <cfgAlias>$19: T.class_of(T).any(<statTemp>$20: Runtime object representing type: T.class_of(Article), <statTemp>$25: Runtime object representing type: T.class_of(Post))
    <statTemp>$14: Sorbet::Private::Static::Void = <cfgAlias>$16: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<statTemp>$17: Runtime object representing type: T.any(T.class_of(Article), T.class_of(Post)))
    <castTemp>$30: T.class_of(Writable) = <self>
    <self>: T.any(T.class_of(Article), T.class_of(Post)) = cast(<castTemp>$30: T.class_of(Writable), T.any(T.class_of(Article), T.class_of(Post)));
    <statTemp>$32: Symbol(:name) = :name
    <blockReturnTemp>$12: T.untyped = <self>: T.any(T.class_of(Article), T.class_of(Post)).some_class_method(<statTemp>$32: Symbol(:name))
    <blockReturnTemp>$33: T.noreturn = blockreturn<included> <blockReturnTemp>$12: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Shareable>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Shareable) = cast(<self>: NilClass, T.class_of(Shareable));
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Shareable) = <self>: T.class_of(Shareable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Shareable).included()
    <selfRestore>$10: T.class_of(Shareable) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Shareable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=2](<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable)):
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=11](<self>: T.class_of(Shareable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable)):
    # outerLoops: 1
    <self>: T.class_of(Shareable) = loadSelf(included)
    <cfgAlias>$16: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$19: T.class_of(T) = alias <C T>
    <cfgAlias>$21: T.class_of(Article) = alias <C Article>
    <statTemp>$17: Runtime object representing type: T.class_of(Article) = <cfgAlias>$19: T.class_of(T).class_of(<cfgAlias>$21: T.class_of(Article))
    <statTemp>$14: Sorbet::Private::Static::Void = <cfgAlias>$16: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<statTemp>$17: Runtime object representing type: T.class_of(Article))
    <castTemp>$22: T.class_of(Shareable) = <self>
    <self>: T.class_of(Article) = cast(<castTemp>$22: T.class_of(Shareable), T.class_of(Article));
    <statTemp>$24: Symbol(:do_this) = :do_this
    <blockReturnTemp>$12: T.untyped = <self>: T.class_of(Article).before_save(<statTemp>$24: Symbol(:do_this))
    <blockReturnTemp>$25: T.noreturn = blockreturn<included> <blockReturnTemp>$12: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Post>#some_class_method {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(Post) = cast(<self>: NilClass, T.class_of(Post));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Post#author {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: Post = cast(<self>: NilClass, Post);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Post#should_run_callback? {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: Post = cast(<self>: NilClass, Post);
    <returnMethodTemp>$2: TrueClass = true
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: TrueClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Post#score {

bb0[rubyRegionId=0, firstDead=5]():
    <self>: Post = cast(<self>: NilClass, Post);
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$7: T.class_of(Integer) = alias <C Integer>
    <statTemp>$3: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$7: T.class_of(Integer))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Post>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Post) = cast(<self>: NilClass, T.class_of(Post));
    <cfgAlias>$6: T.class_of(Readable) = alias <C Readable>
    <statTemp>$3: T.class_of(Post) = <self>: T.class_of(Post).include(<cfgAlias>$6: T.class_of(Readable))
    <cfgAlias>$10: T.class_of(Writable) = alias <C Writable>
    <statTemp>$7: T.class_of(Post) = <self>: T.class_of(Post).include(<cfgAlias>$10: T.class_of(Writable))
    <statTemp>$12: T.class_of(Post) = <self>
    <statTemp>$13: Symbol(:run_callback) = :run_callback
    <hashTemp>$14: Symbol(:if) = :if
    <cfgAlias>$17: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$18: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(Kernel).lambda()
    <selfRestore>$19: T.class_of(Post) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Post), <statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=3](<statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post)):
    <hashTemp>$15: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$18, lambda>
    <statTemp>$11: T.untyped = <statTemp>$12: T.class_of(Post).before_create(<statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <hashTemp>$15: T.proc.returns(T.untyped))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=3](<self>: T.class_of(Post), <statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post)):
    # outerLoops: 1
    <self>: T.class_of(Post) = loadSelf(lambda)
    <blockReturnTemp>$21: T.untyped = <self>: T.class_of(Post).should_run_callback?()
    <blockReturnTemp>$23: T.noreturn = blockreturn<lambda> <blockReturnTemp>$21: T.untyped
    <unconditional> -> bb2

}

method ::Article#author {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: Article = cast(<self>: NilClass, Article);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Article#should_run_callback? {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: Article = cast(<self>: NilClass, Article);
    <returnMethodTemp>$2: TrueClass = true
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: TrueClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Article>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Article) = cast(<self>: NilClass, T.class_of(Article));
    <cfgAlias>$6: T.class_of(Writable) = alias <C Writable>
    <statTemp>$3: T.class_of(Article) = <self>: T.class_of(Article).include(<cfgAlias>$6: T.class_of(Writable))
    <cfgAlias>$10: T.class_of(Shareable) = alias <C Shareable>
    <statTemp>$7: T.class_of(Article) = <self>: T.class_of(Article).include(<cfgAlias>$10: T.class_of(Shareable))
    <statTemp>$12: T.class_of(Article) = <self>
    <statTemp>$13: Symbol(:run_callback) = :run_callback
    <hashTemp>$14: Symbol(:if) = :if
    <cfgAlias>$17: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$18: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(Kernel).lambda()
    <selfRestore>$19: T.class_of(Article) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Article), <statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=3](<statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article)):
    <hashTemp>$15: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$18, lambda>
    <statTemp>$11: T.untyped = <statTemp>$12: T.class_of(Article).before_create(<statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <hashTemp>$15: T.proc.returns(T.untyped))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=8](<self>: T.class_of(Article), <statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article)):
    # outerLoops: 1
    <self>: T.class_of(Article) = loadSelf(lambda)
    <cfgAlias>$25: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$27: T.class_of(Article) = alias <C Article>
    <statTemp>$23: Sorbet::Private::Static::Void = <cfgAlias>$25: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$27: T.class_of(Article))
    <castTemp>$28: T.class_of(Article) = <self>
    <self>: Article = cast(<castTemp>$28: T.class_of(Article), Article);
    <blockReturnTemp>$21: T.untyped = <self>: Article.should_run_callback?()
    <blockReturnTemp>$29: T.noreturn = blockreturn<lambda> <blockReturnTemp>$21: T.untyped
    <unconditional> -> bb2

}

method ::A#instance_helper {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: A = cast(<self>: NilClass, A);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:A>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(A) = cast(<self>: NilClass, T.class_of(A));
    <cfgAlias>$6: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$7: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(Kernel).lambda()
    <selfRestore>$8: T.class_of(A) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(A), <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(A)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=6](<block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(A)):
    f: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$7, lambda>
    <self>: T.class_of(A) = <selfRestore>$8
    <cfgAlias>$26: T.class_of(T) = alias <C T>
    <statTemp>$24: T.class_of(A) = <cfgAlias>$26: T.class_of(T).reveal_type(<self>: T.class_of(A))
    <statTemp>$28: NilClass = <self>: T.class_of(A).puts(f: T.proc.returns(T.untyped))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=10](<self>: T.class_of(A), <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(A)):
    # outerLoops: 1
    <self>: T.class_of(A) = loadSelf(lambda)
    <cfgAlias>$14: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$16: T.class_of(A) = alias <C A>
    <statTemp>$12: Sorbet::Private::Static::Void = <cfgAlias>$14: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$16: T.class_of(A))
    <castTemp>$17: T.class_of(A) = <self>
    <self>: A = cast(<castTemp>$17: T.class_of(A), A);
    <cfgAlias>$20: T.class_of(T) = alias <C T>
    <statTemp>$18: A = <cfgAlias>$20: T.class_of(T).reveal_type(<self>: A)
    <blockReturnTemp>$10: T.untyped = <self>: A.instance_helper()
    <blockReturnTemp>$23: T.noreturn = blockreturn<lambda> <blockReturnTemp>$10: T.untyped
    <unconditional> -> bb2

}

method ::<Class:B>#class_helper {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(B) = cast(<self>: NilClass, T.class_of(B));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#instance_helper {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: B = cast(<self>: NilClass, B);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:B>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(B) = cast(<self>: NilClass, T.class_of(B));
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static::ResolvedSig) = alias <C ResolvedSig>
    <statTemp>$7: TrueClass = true
    <statTemp>$8: Symbol(:class_helper) = :class_helper
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(Sorbet::Private::Static::ResolvedSig).sig(<self>: T.class_of(B), <statTemp>$7: TrueClass, <statTemp>$8: Symbol(:class_helper))
    <selfRestore>$10: T.class_of(B) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(B), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(B)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=6](<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(B)):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$9, sig>
    <self>: T.class_of(B) = <selfRestore>$10
    <cfgAlias>$24: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$26: T.class_of(T) = alias <C T>
    <statTemp>$21: T.class_of(B) = <self>: T.class_of(B).extend(<cfgAlias>$24: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=8](<self>: T.class_of(B), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(B)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$15: Symbol(:blk) = :blk
    <cfgAlias>$19: T.class_of(T) = alias <C T>
    <statTemp>$17: T.class_of(T.proc) = <cfgAlias>$19: T.class_of(T).proc()
    <hashTemp>$16: T.class_of(T.proc) = <statTemp>$17: T.class_of(T.proc).void()
    <statTemp>$13: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$15: Symbol(:blk), <hashTemp>$16: T.class_of(T.proc))
    <blockReturnTemp>$12: T::Private::Methods::DeclBuilder = <statTemp>$13: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$20: T.noreturn = blockreturn<sig> <blockReturnTemp>$12: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

}

method ::N#helper_from_N {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: N = cast(<self>: NilClass, N);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:N>#<static-init> {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: T.class_of(N) = cast(<self>: NilClass, T.class_of(N));
    <returnMethodTemp>$2: Symbol(:helper_from_N) = :helper_from_N
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:helper_from_N)
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::M#helper_from_M {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: M = cast(<self>: NilClass, M);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::M#main {

bb0[rubyRegionId=0, firstDead=14]():
    <self>: M = cast(<self>: NilClass, M);
    <cfgAlias>$6: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$9: T.class_of(T) = alias <C T>
    <cfgAlias>$11: T.class_of(M) = alias <C M>
    <cfgAlias>$13: T.class_of(N) = alias <C N>
    <statTemp>$7: Runtime object representing type: T.all(M, N) = <cfgAlias>$9: T.class_of(T).all(<cfgAlias>$11: T.class_of(M), <cfgAlias>$13: T.class_of(N))
    <statTemp>$4: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<statTemp>$7: Runtime object representing type: T.all(M, N))
    <castTemp>$14: M = <self>
    <self>: T.all(M, N) = cast(<castTemp>$14: M, T.all(M, N));
    <cfgAlias>$17: T.class_of(T) = alias <C T>
    <statTemp>$15: T.all(M, N) = <cfgAlias>$17: T.class_of(T).reveal_type(<self>: T.all(M, N))
    <statTemp>$19: T.untyped = <self>: T.all(M, N).helper_from_M()
    <returnMethodTemp>$2: T.untyped = <self>: T.all(M, N).helper_from_N()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:M>#<static-init> {

bb0[rubyRegionId=0, firstDead=5]():
    <self>: T.class_of(M) = cast(<self>: NilClass, T.class_of(M));
    <cfgAlias>$6: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$3: T.class_of(M) = <self>: T.class_of(M).extend(<cfgAlias>$6: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::ThisSelf#main {

bb0[rubyRegionId=0, firstDead=11]():
    <self>: ThisSelf = cast(<self>: NilClass, ThisSelf);
    <cfgAlias>$6: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$8: T.class_of(Kernel) = alias <C Kernel>
    <statTemp>$4: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$8: T.class_of(Kernel))
    <castTemp>$9: ThisSelf = <self>
    <self>: Kernel = cast(<castTemp>$9: ThisSelf, Kernel);
    this: Kernel = <self>
    <cfgAlias>$12: T.class_of(T) = alias <C T>
    <statTemp>$10: Kernel = <cfgAlias>$12: T.class_of(T).reveal_type(this: Kernel)
    <returnMethodTemp>$2: NilClass = this: Kernel.puts()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:ThisSelf>#<static-init> {

bb0[rubyRegionId=0, firstDead=5]():
    <self>: T.class_of(ThisSelf) = cast(<self>: NilClass, T.class_of(ThisSelf));
    <cfgAlias>$6: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$3: T.class_of(ThisSelf) = <self>: T.class_of(ThisSelf).extend(<cfgAlias>$6: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Rescues>#takes_block {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(Rescues) = cast(<self>: NilClass, T.class_of(Rescues));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Rescues#foo {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: Rescues = cast(<self>: NilClass, Rescues);
    <magic>$14: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$3: T.untyped = <get-current-exception>
    <self>: String = cast(<castTemp>$10: NilClass, String);
    <exceptionValue>$3 -> (T.untyped ? bb3 : bb4)

# backedges
# - bb6(rubyRegionId=3)
# - bb9(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb4(rubyRegionId=1)
bb3[rubyRegionId=2, firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$3: T.untyped, <magic>$14: T.class_of(<Magic>)):
    <cfgAlias>$17: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$18: T.untyped = <exceptionValue>$3: T.untyped.is_a?(<cfgAlias>$17: T.class_of(StandardError))
    <isaCheckTemp>$18 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb0(rubyRegionId=0)
bb4[rubyRegionId=1, firstDead=-1](<self>: String, <magic>$14: T.class_of(<Magic>)):
    <cfgAlias>$7: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$9: T.class_of(String) = alias <C String>
    <statTemp>$5: Sorbet::Private::Static::Void = <cfgAlias>$7: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$9: T.class_of(String))
    <castTemp>$10: String = <self>
    <self>: String = cast(<castTemp>$10: String, String);
    <cfgAlias>$12: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$12: T.class_of(T).reveal_type(<self>: String)
    <exceptionValue>$3: T.untyped = <get-current-exception>
    <exceptionValue>$3 -> (T.untyped ? bb3 : bb5)

# backedges
# - bb4(rubyRegionId=1)
bb5[rubyRegionId=4, firstDead=-1](<self>: String, <returnMethodTemp>$2: String):
    <unconditional> -> bb6

# backedges
# - bb5(rubyRegionId=4)
# - bb7(rubyRegionId=2)
# - bb8(rubyRegionId=2)
bb6[rubyRegionId=3, firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String), <gotoDeadTemp>$22: T.nilable(TrueClass)):
    <cfgAlias>$25: T.class_of(T) = alias <C T>
    <throwAwayTemp>$23: String = <cfgAlias>$25: T.class_of(T).reveal_type(<self>: String)
    <gotoDeadTemp>$22 -> (T.nilable(TrueClass) ? bb1 : bb9)

# backedges
# - bb3(rubyRegionId=2)
bb7[rubyRegionId=2, firstDead=-1](<self>: String, <magic>$14: T.class_of(<Magic>)):
    <exceptionValue>$3: NilClass = nil
    <keepForCfgTemp>$15: Sorbet::Private::Static::Void = <magic>$14: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$3: NilClass)
    <cfgAlias>$20: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$20: T.class_of(T).reveal_type(<self>: String)
    <unconditional> -> bb6

# backedges
# - bb3(rubyRegionId=2)
bb8[rubyRegionId=2, firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String)):
    <gotoDeadTemp>$22: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6(rubyRegionId=3)
bb9[rubyRegionId=0, firstDead=1](<returnMethodTemp>$2: String):
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String
    <unconditional> -> bb1

}

method ::Rescues#bar {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: Rescues = cast(<self>: NilClass, Rescues);
    <magic>$14: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$3: T.untyped = <get-current-exception>
    <self>: String = cast(<castTemp>$10: NilClass, String);
    <self>: Integer = cast(<castTemp>$25: NilClass, Integer);
    <self>: Float = cast(<castTemp>$37: NilClass, Float);
    <exceptionValue>$3 -> (T.untyped ? bb3 : bb4)

# backedges
# - bb6(rubyRegionId=3)
# - bb9(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb4(rubyRegionId=1)
bb3[rubyRegionId=2, firstDead=-1](<self>: T.any(Float, String), <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$3: T.untyped, <magic>$14: T.class_of(<Magic>)):
    <cfgAlias>$17: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$18: T.untyped = <exceptionValue>$3: T.untyped.is_a?(<cfgAlias>$17: T.class_of(StandardError))
    <isaCheckTemp>$18 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb0(rubyRegionId=0)
bb4[rubyRegionId=1, firstDead=-1](<self>: Float, <magic>$14: T.class_of(<Magic>)):
    <cfgAlias>$7: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$9: T.class_of(String) = alias <C String>
    <statTemp>$5: Sorbet::Private::Static::Void = <cfgAlias>$7: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$9: T.class_of(String))
    <castTemp>$10: Float = <self>
    <self>: String = cast(<castTemp>$10: Float, String);
    <cfgAlias>$12: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$12: T.class_of(T).reveal_type(<self>: String)
    <exceptionValue>$3: T.untyped = <get-current-exception>
    <exceptionValue>$3 -> (T.untyped ? bb3 : bb5)

# backedges
# - bb4(rubyRegionId=1)
bb5[rubyRegionId=4, firstDead=-1](<self>: String, <returnMethodTemp>$2: String):
    <unconditional> -> bb6

# backedges
# - bb5(rubyRegionId=4)
# - bb7(rubyRegionId=2)
# - bb8(rubyRegionId=2)
bb6[rubyRegionId=3, firstDead=-1](<self>: T.any(Float, String, Integer), <returnMethodTemp>$2: T.nilable(T.any(String, Integer)), <gotoDeadTemp>$29: T.nilable(TrueClass)):
    <cfgAlias>$34: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$36: T.class_of(Float) = alias <C Float>
    <statTemp>$32: Sorbet::Private::Static::Void = <cfgAlias>$34: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$36: T.class_of(Float))
    <castTemp>$37: T.any(Float, String, Integer) = <self>
    <self>: Float = cast(<castTemp>$37: T.any(Float, String, Integer), Float);
    <cfgAlias>$39: T.class_of(T) = alias <C T>
    <throwAwayTemp>$30: Float = <cfgAlias>$39: T.class_of(T).reveal_type(<self>: Float)
    <gotoDeadTemp>$29 -> (T.nilable(TrueClass) ? bb1 : bb9)

# backedges
# - bb3(rubyRegionId=2)
bb7[rubyRegionId=2, firstDead=-1](<self>: T.any(Float, String), <magic>$14: T.class_of(<Magic>)):
    <exceptionValue>$3: NilClass = nil
    <keepForCfgTemp>$15: Sorbet::Private::Static::Void = <magic>$14: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$3: NilClass)
    <cfgAlias>$22: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$24: T.class_of(Integer) = alias <C Integer>
    <statTemp>$20: Sorbet::Private::Static::Void = <cfgAlias>$22: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$24: T.class_of(Integer))
    <castTemp>$25: T.any(Float, String) = <self>
    <self>: Integer = cast(<castTemp>$25: T.any(Float, String), Integer);
    <cfgAlias>$27: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: Integer = <cfgAlias>$27: T.class_of(T).reveal_type(<self>: Integer)
    <unconditional> -> bb6

# backedges
# - bb3(rubyRegionId=2)
bb8[rubyRegionId=2, firstDead=-1](<self>: T.any(Float, String), <returnMethodTemp>$2: T.nilable(String)):
    <gotoDeadTemp>$29: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6(rubyRegionId=3)
bb9[rubyRegionId=0, firstDead=1](<returnMethodTemp>$2: T.any(Integer, String)):
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.any(Integer, String)
    <unconditional> -> bb1

}

method ::Rescues#baz {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: Rescues = cast(<self>: NilClass, Rescues);
    <cfgAlias>$5: T.class_of(T) = alias <C T>
    <statTemp>$3: Rescues = <cfgAlias>$5: T.class_of(T).reveal_type(<self>: Rescues)
    <magic>$18: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$7: T.untyped = <get-current-exception>
    <self>: String = cast(<castTemp>$14: NilClass, String);
    <exceptionValue>$7 -> (T.untyped ? bb3 : bb4)

# backedges
# - bb6(rubyRegionId=3)
# - bb9(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb4(rubyRegionId=1)
bb3[rubyRegionId=2, firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$7: T.untyped, <magic>$18: T.class_of(<Magic>)):
    <cfgAlias>$21: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$22: T.untyped = <exceptionValue>$7: T.untyped.is_a?(<cfgAlias>$21: T.class_of(StandardError))
    <isaCheckTemp>$22 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb0(rubyRegionId=0)
bb4[rubyRegionId=1, firstDead=-1](<self>: String, <magic>$18: T.class_of(<Magic>)):
    <cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$13: T.class_of(String) = alias <C String>
    <statTemp>$9: Sorbet::Private::Static::Void = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$13: T.class_of(String))
    <castTemp>$14: String = <self>
    <self>: String = cast(<castTemp>$14: String, String);
    <cfgAlias>$16: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$16: T.class_of(T).reveal_type(<self>: String)
    <exceptionValue>$7: T.untyped = <get-current-exception>
    <exceptionValue>$7 -> (T.untyped ? bb3 : bb5)

# backedges
# - bb4(rubyRegionId=1)
bb5[rubyRegionId=4, firstDead=-1](<returnMethodTemp>$2: String):
    <unconditional> -> bb6

# backedges
# - bb5(rubyRegionId=4)
# - bb7(rubyRegionId=2)
# - bb8(rubyRegionId=2)
bb6[rubyRegionId=3, firstDead=-1](<returnMethodTemp>$2: T.nilable(String), <gotoDeadTemp>$26: T.nilable(TrueClass)):
    <gotoDeadTemp>$26 -> (T.nilable(TrueClass) ? bb1 : bb9)

# backedges
# - bb3(rubyRegionId=2)
bb7[rubyRegionId=2, firstDead=-1](<self>: String, <magic>$18: T.class_of(<Magic>)):
    <exceptionValue>$7: NilClass = nil
    <keepForCfgTemp>$19: Sorbet::Private::Static::Void = <magic>$18: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$7: NilClass)
    <cfgAlias>$24: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$24: T.class_of(T).reveal_type(<self>: String)
    <unconditional> -> bb6

# backedges
# - bb3(rubyRegionId=2)
bb8[rubyRegionId=2, firstDead=-1](<returnMethodTemp>$2: T.nilable(String)):
    <gotoDeadTemp>$26: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6(rubyRegionId=3)
bb9[rubyRegionId=0, firstDead=1](<returnMethodTemp>$2: String):
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String
    <unconditional> -> bb1

}

method ::<Class:Rescues>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Rescues) = cast(<self>: NilClass, T.class_of(Rescues));
    <block-pre-call-temp>$6: Sorbet::Private::Static::Void = <self>: T.class_of(Rescues).takes_block()
    <selfRestore>$7: T.class_of(Rescues) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
# - bb10(rubyRegionId=4)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb13(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Rescues), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: NilClass, <castTemp>$17: NilClass, <gotoDeadTemp>$29: NilClass):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=2](<block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues)):
    <statTemp>$4: T.untyped = Solve<<block-pre-call-temp>$6, takes_block>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Rescues), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: NilClass, <castTemp>$17: NilClass, <gotoDeadTemp>$29: NilClass):
    # outerLoops: 1
    <self>: T.class_of(Rescues) = loadSelf(takes_block)
    <magic>$21: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$10: T.untyped = <get-current-exception>
    <self>: Integer = cast(<castTemp>$17: NilClass, Integer);
    <exceptionValue>$10 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb5(rubyRegionId=1)
# - bb8(rubyRegionId=2)
bb7[rubyRegionId=3, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: T.nilable(Integer), <exceptionValue>$10: T.untyped, <castTemp>$17: T.nilable(Integer), <magic>$21: T.class_of(<Magic>), <gotoDeadTemp>$29: NilClass):
    # outerLoops: 1
    <cfgAlias>$24: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$25: T.untyped = <exceptionValue>$10: T.untyped.is_a?(<cfgAlias>$24: T.class_of(StandardError))
    <isaCheckTemp>$25 -> (T.untyped ? bb11 : bb12)

# backedges
# - bb5(rubyRegionId=1)
bb8[rubyRegionId=2, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <magic>$21: T.class_of(<Magic>), <gotoDeadTemp>$29: NilClass):
    # outerLoops: 1
    <cfgAlias>$14: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$16: T.class_of(Integer) = alias <C Integer>
    <statTemp>$12: Sorbet::Private::Static::Void = <cfgAlias>$14: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$16: T.class_of(Integer))
    <castTemp>$17: Integer = <self>
    <self>: Integer = cast(<castTemp>$17: Integer, Integer);
    <cfgAlias>$19: T.class_of(T) = alias <C T>
    <blockReturnTemp>$9: Integer = <cfgAlias>$19: T.class_of(T).reveal_type(<self>: Integer)
    <exceptionValue>$10: T.untyped = <get-current-exception>
    <exceptionValue>$10 -> (T.untyped ? bb7 : bb9)

# backedges
# - bb8(rubyRegionId=2)
bb9[rubyRegionId=5, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: Integer, <castTemp>$17: Integer, <gotoDeadTemp>$29: NilClass):
    # outerLoops: 1
    <unconditional> -> bb10

# backedges
# - bb9(rubyRegionId=5)
# - bb11(rubyRegionId=3)
# - bb12(rubyRegionId=3)
bb10[rubyRegionId=4, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: T.nilable(Integer), <castTemp>$17: T.nilable(Integer), <gotoDeadTemp>$29: T.nilable(TrueClass)):
    # outerLoops: 1
    <gotoDeadTemp>$29 -> (T.nilable(TrueClass) ? bb1 : bb13)

# backedges
# - bb7(rubyRegionId=3)
bb11[rubyRegionId=3, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <castTemp>$17: T.nilable(Integer), <magic>$21: T.class_of(<Magic>), <gotoDeadTemp>$29: NilClass):
    # outerLoops: 1
    <exceptionValue>$10: NilClass = nil
    <keepForCfgTemp>$22: Sorbet::Private::Static::Void = <magic>$21: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$10: NilClass)
    <cfgAlias>$27: T.class_of(T) = alias <C T>
    <blockReturnTemp>$9: Integer = <cfgAlias>$27: T.class_of(T).reveal_type(<self>: Integer)
    <unconditional> -> bb10

# backedges
# - bb7(rubyRegionId=3)
bb12[rubyRegionId=3, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: T.nilable(Integer), <castTemp>$17: T.nilable(Integer)):
    # outerLoops: 1
    <gotoDeadTemp>$29: TrueClass = true
    <unconditional> -> bb10

# backedges
# - bb10(rubyRegionId=4)
bb13[rubyRegionId=1, firstDead=1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: Integer, <castTemp>$17: T.nilable(Integer), <gotoDeadTemp>$29: NilClass):
    # outerLoops: 1
    <blockReturnTemp>$31: T.noreturn = blockreturn<takes_block> <blockReturnTemp>$9: Integer
    <unconditional> -> bb2

}

