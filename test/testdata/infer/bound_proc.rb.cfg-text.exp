method ::<Class:<root>>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(<root>) = cast(<self>: NilClass, T.class_of(<root>));
    <cfgAlias>$7: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$9: T.class_of(Base) = alias <C Base>
    <statTemp>$5: Sorbet::Private::Static::Void = <cfgAlias>$7: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$9: T.class_of(Base))
    <cfgAlias>$14: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$16: T.class_of(Concern) = alias <C Concern>
    <statTemp>$12: Sorbet::Private::Static::Void = <cfgAlias>$14: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$16: T.class_of(Concern))
    <cfgAlias>$21: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$23: T.class_of(Readable) = alias <C Readable>
    <statTemp>$19: Sorbet::Private::Static::Void = <cfgAlias>$21: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$23: T.class_of(Readable))
    <cfgAlias>$28: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$30: T.class_of(Writable) = alias <C Writable>
    <statTemp>$26: Sorbet::Private::Static::Void = <cfgAlias>$28: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$30: T.class_of(Writable))
    <cfgAlias>$35: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$37: T.class_of(Shareable) = alias <C Shareable>
    <statTemp>$33: Sorbet::Private::Static::Void = <cfgAlias>$35: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$37: T.class_of(Shareable))
    <cfgAlias>$42: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$44: T.class_of(Post) = alias <C Post>
    <statTemp>$40: Sorbet::Private::Static::Void = <cfgAlias>$42: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$44: T.class_of(Post))
    <cfgAlias>$47: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$49: T.class_of(Base) = alias <C Base>
    <statTemp>$45: Sorbet::Private::Static::Void = <cfgAlias>$47: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$49: T.class_of(Base))
    <cfgAlias>$54: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$56: T.class_of(Article) = alias <C Article>
    <statTemp>$52: Sorbet::Private::Static::Void = <cfgAlias>$54: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$56: T.class_of(Article))
    <cfgAlias>$59: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$61: T.class_of(Base) = alias <C Base>
    <statTemp>$57: Sorbet::Private::Static::Void = <cfgAlias>$59: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$61: T.class_of(Base))
    <cfgAlias>$66: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$68: T.class_of(A) = alias <C A>
    <statTemp>$64: Sorbet::Private::Static::Void = <cfgAlias>$66: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$68: T.class_of(A))
    <cfgAlias>$73: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$75: T.class_of(B) = alias <C B>
    <statTemp>$71: Sorbet::Private::Static::Void = <cfgAlias>$73: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$75: T.class_of(B))
    <cfgAlias>$78: T.class_of(B) = alias <C B>
    <block-pre-call-temp>$79: Sorbet::Private::Static::Void = <cfgAlias>$78: T.class_of(B).class_helper()
    <selfRestore>$80: T.class_of(<root>) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(<root>), <block-pre-call-temp>$79: Sorbet::Private::Static::Void, <selfRestore>$80: T.class_of(<root>)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=17](<block-pre-call-temp>$79: Sorbet::Private::Static::Void, <selfRestore>$80: T.class_of(<root>)):
    <statTemp>$76: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$79, class_helper>
    <self>: T.class_of(<root>) = <selfRestore>$80
    <cfgAlias>$95: T.class_of(T) = alias <C T>
    <statTemp>$93: T.class_of(<root>) = <cfgAlias>$95: T.class_of(T).reveal_type(<self>: T.class_of(<root>))
    <cfgAlias>$101: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$103: T.class_of(N) = alias <C N>
    <statTemp>$99: Sorbet::Private::Static::Void = <cfgAlias>$101: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$103: T.class_of(N))
    <cfgAlias>$108: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$110: T.class_of(M) = alias <C M>
    <statTemp>$106: Sorbet::Private::Static::Void = <cfgAlias>$108: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$110: T.class_of(M))
    <cfgAlias>$115: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$117: T.class_of(ThisSelf) = alias <C ThisSelf>
    <statTemp>$113: Sorbet::Private::Static::Void = <cfgAlias>$115: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$117: T.class_of(ThisSelf))
    <cfgAlias>$122: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$124: T.class_of(Rescues) = alias <C Rescues>
    <statTemp>$120: Sorbet::Private::Static::Void = <cfgAlias>$122: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$124: T.class_of(Rescues))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=10](<self>: T.class_of(<root>), <block-pre-call-temp>$79: Sorbet::Private::Static::Void, <selfRestore>$80: T.class_of(<root>)):
    # outerLoops: 1
    <self>: T.class_of(<root>) = loadSelf(class_helper)
    <cfgAlias>$85: T.class_of(B) = alias <C B>
    keep_for_ide$84: T.class_of(B) = <cfgAlias>$85
    keep_for_ide$84: T.untyped = <keep-alive> keep_for_ide$84
    <castTemp>$86: T.class_of(<root>) = <self>
    <self>: B = cast(<castTemp>$86: T.class_of(<root>), B);
    <cfgAlias>$89: T.class_of(T) = alias <C T>
    <statTemp>$87: B = <cfgAlias>$89: T.class_of(T).reveal_type(<self>: B)
    <blockReturnTemp>$82: T.untyped = <self>: B.instance_helper()
    <blockReturnTemp>$92: T.noreturn = blockreturn<class_helper> <blockReturnTemp>$82: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Base>#before_save {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(Base) = cast(<self>: NilClass, T.class_of(Base));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Base>#before_create {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(Base) = cast(<self>: NilClass, T.class_of(Base));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Base>#<static-init> {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(Base) = cast(<self>: NilClass, T.class_of(Base));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Concern#included {

bb0[rubyRegionId=0, firstDead=6]():
    @block$3: T.untyped = alias <C <undeclared-field-stub>> (@block)
    <self>: Concern = cast(<self>: NilClass, Concern);
    block: T.untyped = load_arg(block)
    @block$3: T.untyped = block
    <returnMethodTemp>$2: T.untyped = @block$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Concern>#<static-init> {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: T.class_of(Concern) = cast(<self>: NilClass, T.class_of(Concern));
    <returnMethodTemp>$2: Symbol(:included) = :included
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:included)
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Readable>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Readable) = cast(<self>: NilClass, T.class_of(Readable));
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Readable) = <self>: T.class_of(Readable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Readable).included()
    <selfRestore>$10: T.class_of(Readable) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Readable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=2](<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable)):
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=4](<self>: T.class_of(Readable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable)):
    # outerLoops: 1
    <self>: T.class_of(Readable) = loadSelf(included)
    <statTemp>$14: Symbol(:do_this) = :do_this
    <blockReturnTemp>$12: T.untyped = <self>: T.class_of(Readable).before_create(<statTemp>$14: Symbol(:do_this))
    <blockReturnTemp>$15: T.noreturn = blockreturn<included> <blockReturnTemp>$12: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Writable>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Writable) = cast(<self>: NilClass, T.class_of(Writable));
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Writable) = <self>: T.class_of(Writable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Writable).included()
    <selfRestore>$10: T.class_of(Writable) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Writable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=2](<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable)):
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=15](<self>: T.class_of(Writable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable)):
    # outerLoops: 1
    <self>: T.class_of(Writable) = loadSelf(included)
    <cfgAlias>$16: T.class_of(T) = alias <C T>
    <cfgAlias>$19: T.class_of(T) = alias <C T>
    <cfgAlias>$21: T.class_of(Article) = alias <C Article>
    <statTemp>$17: Runtime object representing type: T.class_of(Article) = <cfgAlias>$19: T.class_of(T).class_of(<cfgAlias>$21: T.class_of(Article))
    <cfgAlias>$24: T.class_of(T) = alias <C T>
    <cfgAlias>$26: T.class_of(Post) = alias <C Post>
    <statTemp>$22: Runtime object representing type: T.class_of(Post) = <cfgAlias>$24: T.class_of(T).class_of(<cfgAlias>$26: T.class_of(Post))
    keep_for_ide$14: Runtime object representing type: T.any(T.class_of(Article), T.class_of(Post)) = <cfgAlias>$16: T.class_of(T).any(<statTemp>$17: Runtime object representing type: T.class_of(Article), <statTemp>$22: Runtime object representing type: T.class_of(Post))
    keep_for_ide$14: T.untyped = <keep-alive> keep_for_ide$14
    <castTemp>$27: T.class_of(Writable) = <self>
    <self>: T.any(T.class_of(Article), T.class_of(Post)) = cast(<castTemp>$27: T.class_of(Writable), T.any(T.class_of(Article), T.class_of(Post)));
    <statTemp>$29: Symbol(:name) = :name
    <blockReturnTemp>$12: T.untyped = <self>: T.any(T.class_of(Article), T.class_of(Post)).some_class_method(<statTemp>$29: Symbol(:name))
    <blockReturnTemp>$30: T.noreturn = blockreturn<included> <blockReturnTemp>$12: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Shareable>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Shareable) = cast(<self>: NilClass, T.class_of(Shareable));
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Shareable) = <self>: T.class_of(Shareable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Shareable).included()
    <selfRestore>$10: T.class_of(Shareable) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Shareable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=2](<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable)):
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=10](<self>: T.class_of(Shareable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable)):
    # outerLoops: 1
    <self>: T.class_of(Shareable) = loadSelf(included)
    <cfgAlias>$16: T.class_of(T) = alias <C T>
    <cfgAlias>$18: T.class_of(Article) = alias <C Article>
    keep_for_ide$14: Runtime object representing type: T.class_of(Article) = <cfgAlias>$16: T.class_of(T).class_of(<cfgAlias>$18: T.class_of(Article))
    keep_for_ide$14: T.untyped = <keep-alive> keep_for_ide$14
    <castTemp>$19: T.class_of(Shareable) = <self>
    <self>: T.class_of(Article) = cast(<castTemp>$19: T.class_of(Shareable), T.class_of(Article));
    <statTemp>$21: Symbol(:do_this) = :do_this
    <blockReturnTemp>$12: T.untyped = <self>: T.class_of(Article).before_save(<statTemp>$21: Symbol(:do_this))
    <blockReturnTemp>$22: T.noreturn = blockreturn<included> <blockReturnTemp>$12: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Post>#some_class_method {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(Post) = cast(<self>: NilClass, T.class_of(Post));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Post#author {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: Post = cast(<self>: NilClass, Post);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Post#should_run_callback? {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: Post = cast(<self>: NilClass, Post);
    <returnMethodTemp>$2: TrueClass = true
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: TrueClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Post#score {

bb0[rubyRegionId=0, firstDead=5]():
    <self>: Post = cast(<self>: NilClass, Post);
    <cfgAlias>$4: T.class_of(Integer) = alias <C Integer>
    keep_for_ide$3: T.class_of(Integer) = <cfgAlias>$4
    keep_for_ide$3: T.untyped = <keep-alive> keep_for_ide$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Post>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Post) = cast(<self>: NilClass, T.class_of(Post));
    <cfgAlias>$6: T.class_of(Readable) = alias <C Readable>
    <statTemp>$3: T.class_of(Post) = <self>: T.class_of(Post).include(<cfgAlias>$6: T.class_of(Readable))
    <cfgAlias>$10: T.class_of(Writable) = alias <C Writable>
    <statTemp>$7: T.class_of(Post) = <self>: T.class_of(Post).include(<cfgAlias>$10: T.class_of(Writable))
    <statTemp>$12: T.class_of(Post) = <self>
    <statTemp>$13: Symbol(:run_callback) = :run_callback
    <hashTemp>$14: Symbol(:if) = :if
    <cfgAlias>$17: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$18: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(Kernel).lambda()
    <selfRestore>$19: T.class_of(Post) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Post), <statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=3](<statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post)):
    <hashTemp>$15: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$18, lambda>
    <statTemp>$11: T.untyped = <statTemp>$12: T.class_of(Post).before_create(<statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <hashTemp>$15: T.proc.returns(T.untyped))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=3](<self>: T.class_of(Post), <statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post)):
    # outerLoops: 1
    <self>: T.class_of(Post) = loadSelf(lambda)
    <blockReturnTemp>$21: T.untyped = <self>: T.class_of(Post).should_run_callback?()
    <blockReturnTemp>$23: T.noreturn = blockreturn<lambda> <blockReturnTemp>$21: T.untyped
    <unconditional> -> bb2

}

method ::Article#author {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: Article = cast(<self>: NilClass, Article);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Article#should_run_callback? {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: Article = cast(<self>: NilClass, Article);
    <returnMethodTemp>$2: TrueClass = true
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: TrueClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Article>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Article) = cast(<self>: NilClass, T.class_of(Article));
    <cfgAlias>$6: T.class_of(Writable) = alias <C Writable>
    <statTemp>$3: T.class_of(Article) = <self>: T.class_of(Article).include(<cfgAlias>$6: T.class_of(Writable))
    <cfgAlias>$10: T.class_of(Shareable) = alias <C Shareable>
    <statTemp>$7: T.class_of(Article) = <self>: T.class_of(Article).include(<cfgAlias>$10: T.class_of(Shareable))
    <statTemp>$12: T.class_of(Article) = <self>
    <statTemp>$13: Symbol(:run_callback) = :run_callback
    <hashTemp>$14: Symbol(:if) = :if
    <cfgAlias>$17: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$18: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(Kernel).lambda()
    <selfRestore>$19: T.class_of(Article) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Article), <statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=3](<statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article)):
    <hashTemp>$15: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$18, lambda>
    <statTemp>$11: T.untyped = <statTemp>$12: T.class_of(Article).before_create(<statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <hashTemp>$15: T.proc.returns(T.untyped))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=8](<self>: T.class_of(Article), <statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article)):
    # outerLoops: 1
    <self>: T.class_of(Article) = loadSelf(lambda)
    <cfgAlias>$24: T.class_of(Article) = alias <C Article>
    keep_for_ide$23: T.class_of(Article) = <cfgAlias>$24
    keep_for_ide$23: T.untyped = <keep-alive> keep_for_ide$23
    <castTemp>$25: T.class_of(Article) = <self>
    <self>: Article = cast(<castTemp>$25: T.class_of(Article), Article);
    <blockReturnTemp>$21: T.untyped = <self>: Article.should_run_callback?()
    <blockReturnTemp>$26: T.noreturn = blockreturn<lambda> <blockReturnTemp>$21: T.untyped
    <unconditional> -> bb2

}

method ::A#instance_helper {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: A = cast(<self>: NilClass, A);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:A>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(A) = cast(<self>: NilClass, T.class_of(A));
    <cfgAlias>$6: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$7: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(Kernel).lambda()
    <selfRestore>$8: T.class_of(A) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(A), <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(A)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=6](<block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(A)):
    f: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$7, lambda>
    <self>: T.class_of(A) = <selfRestore>$8
    <cfgAlias>$23: T.class_of(T) = alias <C T>
    <statTemp>$21: T.class_of(A) = <cfgAlias>$23: T.class_of(T).reveal_type(<self>: T.class_of(A))
    <statTemp>$25: NilClass = <self>: T.class_of(A).puts(f: T.proc.returns(T.untyped))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=10](<self>: T.class_of(A), <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(A)):
    # outerLoops: 1
    <self>: T.class_of(A) = loadSelf(lambda)
    <cfgAlias>$13: T.class_of(A) = alias <C A>
    keep_for_ide$12: T.class_of(A) = <cfgAlias>$13
    keep_for_ide$12: T.untyped = <keep-alive> keep_for_ide$12
    <castTemp>$14: T.class_of(A) = <self>
    <self>: A = cast(<castTemp>$14: T.class_of(A), A);
    <cfgAlias>$17: T.class_of(T) = alias <C T>
    <statTemp>$15: A = <cfgAlias>$17: T.class_of(T).reveal_type(<self>: A)
    <blockReturnTemp>$10: T.untyped = <self>: A.instance_helper()
    <blockReturnTemp>$20: T.noreturn = blockreturn<lambda> <blockReturnTemp>$10: T.untyped
    <unconditional> -> bb2

}

method ::<Class:B>#class_helper {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(B) = cast(<self>: NilClass, T.class_of(B));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#instance_helper {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: B = cast(<self>: NilClass, B);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:B>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(B) = cast(<self>: NilClass, T.class_of(B));
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <block-pre-call-temp>$7: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(Sorbet::Private::Static).sig(<self>: T.class_of(B))
    <selfRestore>$8: T.class_of(B) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(B), <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(B)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=6](<block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(B)):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$7, sig>
    <self>: T.class_of(B) = <selfRestore>$8
    <cfgAlias>$22: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$24: T.class_of(T) = alias <C T>
    <statTemp>$19: T.class_of(B) = <self>: T.class_of(B).extend(<cfgAlias>$22: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=8](<self>: T.class_of(B), <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(B)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$13: Symbol(:blk) = :blk
    <cfgAlias>$17: T.class_of(T) = alias <C T>
    <statTemp>$15: T.class_of(T.proc) = <cfgAlias>$17: T.class_of(T).proc()
    <hashTemp>$14: Runtime object representing type: T.proc.void = <statTemp>$15: T.class_of(T.proc).void()
    <statTemp>$11: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$13: Symbol(:blk), <hashTemp>$14: Runtime object representing type: T.proc.void)
    <blockReturnTemp>$10: T::Private::Methods::DeclBuilder = <statTemp>$11: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$18: T.noreturn = blockreturn<sig> <blockReturnTemp>$10: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

}

method ::N#helper_from_N {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: N = cast(<self>: NilClass, N);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:N>#<static-init> {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: T.class_of(N) = cast(<self>: NilClass, T.class_of(N));
    <returnMethodTemp>$2: Symbol(:helper_from_N) = :helper_from_N
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:helper_from_N)
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::M#helper_from_M {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: M = cast(<self>: NilClass, M);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::M#main {

bb0[rubyRegionId=0, firstDead=13]():
    <self>: M = cast(<self>: NilClass, M);
    <cfgAlias>$6: T.class_of(T) = alias <C T>
    <cfgAlias>$8: T.class_of(M) = alias <C M>
    <cfgAlias>$10: T.class_of(N) = alias <C N>
    keep_for_ide$4: Runtime object representing type: T.all(M, N) = <cfgAlias>$6: T.class_of(T).all(<cfgAlias>$8: T.class_of(M), <cfgAlias>$10: T.class_of(N))
    keep_for_ide$4: T.untyped = <keep-alive> keep_for_ide$4
    <castTemp>$11: M = <self>
    <self>: T.all(M, N) = cast(<castTemp>$11: M, T.all(M, N));
    <cfgAlias>$14: T.class_of(T) = alias <C T>
    <statTemp>$12: T.all(M, N) = <cfgAlias>$14: T.class_of(T).reveal_type(<self>: T.all(M, N))
    <statTemp>$16: T.untyped = <self>: T.all(M, N).helper_from_M()
    <returnMethodTemp>$2: T.untyped = <self>: T.all(M, N).helper_from_N()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:M>#<static-init> {

bb0[rubyRegionId=0, firstDead=5]():
    <self>: T.class_of(M) = cast(<self>: NilClass, T.class_of(M));
    <cfgAlias>$6: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$3: T.class_of(M) = <self>: T.class_of(M).extend(<cfgAlias>$6: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::ThisSelf#main {

bb0[rubyRegionId=0, firstDead=11]():
    <self>: ThisSelf = cast(<self>: NilClass, ThisSelf);
    <cfgAlias>$5: T.class_of(Kernel) = alias <C Kernel>
    keep_for_ide$4: T.class_of(Kernel) = <cfgAlias>$5
    keep_for_ide$4: T.untyped = <keep-alive> keep_for_ide$4
    <castTemp>$6: ThisSelf = <self>
    <self>: Kernel = cast(<castTemp>$6: ThisSelf, Kernel);
    this: Kernel = <self>
    <cfgAlias>$9: T.class_of(T) = alias <C T>
    <statTemp>$7: Kernel = <cfgAlias>$9: T.class_of(T).reveal_type(this: Kernel)
    <returnMethodTemp>$2: NilClass = this: Kernel.puts()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:ThisSelf>#<static-init> {

bb0[rubyRegionId=0, firstDead=5]():
    <self>: T.class_of(ThisSelf) = cast(<self>: NilClass, T.class_of(ThisSelf));
    <cfgAlias>$6: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$3: T.class_of(ThisSelf) = <self>: T.class_of(ThisSelf).extend(<cfgAlias>$6: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Rescues>#takes_block {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(Rescues) = cast(<self>: NilClass, T.class_of(Rescues));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::Rescues#foo {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: Rescues = cast(<self>: NilClass, Rescues);
    <magic>$11: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$3: T.untyped = <get-current-exception>
    <self>: String = cast(<castTemp>$7: NilClass, String);
    <exceptionValue>$3 -> (T.untyped ? bb3 : bb4)

# backedges
# - bb6(rubyRegionId=3)
# - bb9(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb4(rubyRegionId=1)
bb3[rubyRegionId=2, firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$3: T.untyped, <magic>$11: T.class_of(<Magic>)):
    <cfgAlias>$14: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$15: T.untyped = <exceptionValue>$3: T.untyped.is_a?(<cfgAlias>$14: T.class_of(StandardError))
    <isaCheckTemp>$15 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb0(rubyRegionId=0)
bb4[rubyRegionId=1, firstDead=-1](<self>: String, <magic>$11: T.class_of(<Magic>)):
    <cfgAlias>$6: T.class_of(String) = alias <C String>
    keep_for_ide$5: T.class_of(String) = <cfgAlias>$6
    keep_for_ide$5: T.untyped = <keep-alive> keep_for_ide$5
    <castTemp>$7: String = <self>
    <self>: String = cast(<castTemp>$7: String, String);
    <cfgAlias>$9: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$9: T.class_of(T).reveal_type(<self>: String)
    <exceptionValue>$3: T.untyped = <get-current-exception>
    <exceptionValue>$3 -> (T.untyped ? bb3 : bb5)

# backedges
# - bb4(rubyRegionId=1)
bb5[rubyRegionId=4, firstDead=-1](<self>: String, <returnMethodTemp>$2: String):
    <unconditional> -> bb6

# backedges
# - bb5(rubyRegionId=4)
# - bb7(rubyRegionId=2)
# - bb8(rubyRegionId=2)
bb6[rubyRegionId=3, firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String), <gotoDeadTemp>$19: T.nilable(TrueClass)):
    <cfgAlias>$22: T.class_of(T) = alias <C T>
    <throwAwayTemp>$20: String = <cfgAlias>$22: T.class_of(T).reveal_type(<self>: String)
    <gotoDeadTemp>$19 -> (T.nilable(TrueClass) ? bb1 : bb9)

# backedges
# - bb3(rubyRegionId=2)
bb7[rubyRegionId=2, firstDead=-1](<self>: String, <magic>$11: T.class_of(<Magic>)):
    <exceptionValue>$3: NilClass = nil
    <keepForCfgTemp>$12: Sorbet::Private::Static::Void = <magic>$11: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$3: NilClass)
    <cfgAlias>$17: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$17: T.class_of(T).reveal_type(<self>: String)
    <unconditional> -> bb6

# backedges
# - bb3(rubyRegionId=2)
bb8[rubyRegionId=2, firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String)):
    <gotoDeadTemp>$19: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6(rubyRegionId=3)
bb9[rubyRegionId=0, firstDead=1](<returnMethodTemp>$2: String):
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String
    <unconditional> -> bb1

}

method ::Rescues#bar {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: Rescues = cast(<self>: NilClass, Rescues);
    <magic>$11: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$3: T.untyped = <get-current-exception>
    <self>: String = cast(<castTemp>$7: NilClass, String);
    <self>: Integer = cast(<castTemp>$19: NilClass, Integer);
    <self>: Float = cast(<castTemp>$28: NilClass, Float);
    <exceptionValue>$3 -> (T.untyped ? bb3 : bb4)

# backedges
# - bb6(rubyRegionId=3)
# - bb9(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb4(rubyRegionId=1)
bb3[rubyRegionId=2, firstDead=-1](<self>: T.any(Float, String), <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$3: T.untyped, <magic>$11: T.class_of(<Magic>)):
    <cfgAlias>$14: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$15: T.untyped = <exceptionValue>$3: T.untyped.is_a?(<cfgAlias>$14: T.class_of(StandardError))
    <isaCheckTemp>$15 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb0(rubyRegionId=0)
bb4[rubyRegionId=1, firstDead=-1](<self>: Float, <magic>$11: T.class_of(<Magic>)):
    <cfgAlias>$6: T.class_of(String) = alias <C String>
    keep_for_ide$5: T.class_of(String) = <cfgAlias>$6
    keep_for_ide$5: T.untyped = <keep-alive> keep_for_ide$5
    <castTemp>$7: Float = <self>
    <self>: String = cast(<castTemp>$7: Float, String);
    <cfgAlias>$9: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$9: T.class_of(T).reveal_type(<self>: String)
    <exceptionValue>$3: T.untyped = <get-current-exception>
    <exceptionValue>$3 -> (T.untyped ? bb3 : bb5)

# backedges
# - bb4(rubyRegionId=1)
bb5[rubyRegionId=4, firstDead=-1](<self>: String, <returnMethodTemp>$2: String):
    <unconditional> -> bb6

# backedges
# - bb5(rubyRegionId=4)
# - bb7(rubyRegionId=2)
# - bb8(rubyRegionId=2)
bb6[rubyRegionId=3, firstDead=-1](<self>: T.any(Float, String, Integer), <returnMethodTemp>$2: T.nilable(T.any(String, Integer)), <gotoDeadTemp>$23: T.nilable(TrueClass)):
    <cfgAlias>$27: T.class_of(Float) = alias <C Float>
    keep_for_ide$26: T.class_of(Float) = <cfgAlias>$27
    keep_for_ide$26: T.untyped = <keep-alive> keep_for_ide$26
    <castTemp>$28: T.any(Float, String, Integer) = <self>
    <self>: Float = cast(<castTemp>$28: T.any(Float, String, Integer), Float);
    <cfgAlias>$30: T.class_of(T) = alias <C T>
    <throwAwayTemp>$24: Float = <cfgAlias>$30: T.class_of(T).reveal_type(<self>: Float)
    <gotoDeadTemp>$23 -> (T.nilable(TrueClass) ? bb1 : bb9)

# backedges
# - bb3(rubyRegionId=2)
bb7[rubyRegionId=2, firstDead=-1](<self>: T.any(Float, String), <magic>$11: T.class_of(<Magic>)):
    <exceptionValue>$3: NilClass = nil
    <keepForCfgTemp>$12: Sorbet::Private::Static::Void = <magic>$11: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$3: NilClass)
    <cfgAlias>$18: T.class_of(Integer) = alias <C Integer>
    keep_for_ide$17: T.class_of(Integer) = <cfgAlias>$18
    keep_for_ide$17: T.untyped = <keep-alive> keep_for_ide$17
    <castTemp>$19: T.any(Float, String) = <self>
    <self>: Integer = cast(<castTemp>$19: T.any(Float, String), Integer);
    <cfgAlias>$21: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: Integer = <cfgAlias>$21: T.class_of(T).reveal_type(<self>: Integer)
    <unconditional> -> bb6

# backedges
# - bb3(rubyRegionId=2)
bb8[rubyRegionId=2, firstDead=-1](<self>: T.any(Float, String), <returnMethodTemp>$2: T.nilable(String)):
    <gotoDeadTemp>$23: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6(rubyRegionId=3)
bb9[rubyRegionId=0, firstDead=1](<returnMethodTemp>$2: T.any(Integer, String)):
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.any(Integer, String)
    <unconditional> -> bb1

}

method ::Rescues#baz {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: Rescues = cast(<self>: NilClass, Rescues);
    <cfgAlias>$5: T.class_of(T) = alias <C T>
    <statTemp>$3: Rescues = <cfgAlias>$5: T.class_of(T).reveal_type(<self>: Rescues)
    <magic>$15: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$7: T.untyped = <get-current-exception>
    <self>: String = cast(<castTemp>$11: NilClass, String);
    <exceptionValue>$7 -> (T.untyped ? bb3 : bb4)

# backedges
# - bb6(rubyRegionId=3)
# - bb9(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb4(rubyRegionId=1)
bb3[rubyRegionId=2, firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$7: T.untyped, <magic>$15: T.class_of(<Magic>)):
    <cfgAlias>$18: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$19: T.untyped = <exceptionValue>$7: T.untyped.is_a?(<cfgAlias>$18: T.class_of(StandardError))
    <isaCheckTemp>$19 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb0(rubyRegionId=0)
bb4[rubyRegionId=1, firstDead=-1](<self>: String, <magic>$15: T.class_of(<Magic>)):
    <cfgAlias>$10: T.class_of(String) = alias <C String>
    keep_for_ide$9: T.class_of(String) = <cfgAlias>$10
    keep_for_ide$9: T.untyped = <keep-alive> keep_for_ide$9
    <castTemp>$11: String = <self>
    <self>: String = cast(<castTemp>$11: String, String);
    <cfgAlias>$13: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$13: T.class_of(T).reveal_type(<self>: String)
    <exceptionValue>$7: T.untyped = <get-current-exception>
    <exceptionValue>$7 -> (T.untyped ? bb3 : bb5)

# backedges
# - bb4(rubyRegionId=1)
bb5[rubyRegionId=4, firstDead=-1](<returnMethodTemp>$2: String):
    <unconditional> -> bb6

# backedges
# - bb5(rubyRegionId=4)
# - bb7(rubyRegionId=2)
# - bb8(rubyRegionId=2)
bb6[rubyRegionId=3, firstDead=-1](<returnMethodTemp>$2: T.nilable(String), <gotoDeadTemp>$23: T.nilable(TrueClass)):
    <gotoDeadTemp>$23 -> (T.nilable(TrueClass) ? bb1 : bb9)

# backedges
# - bb3(rubyRegionId=2)
bb7[rubyRegionId=2, firstDead=-1](<self>: String, <magic>$15: T.class_of(<Magic>)):
    <exceptionValue>$7: NilClass = nil
    <keepForCfgTemp>$16: Sorbet::Private::Static::Void = <magic>$15: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$7: NilClass)
    <cfgAlias>$21: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$21: T.class_of(T).reveal_type(<self>: String)
    <unconditional> -> bb6

# backedges
# - bb3(rubyRegionId=2)
bb8[rubyRegionId=2, firstDead=-1](<returnMethodTemp>$2: T.nilable(String)):
    <gotoDeadTemp>$23: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6(rubyRegionId=3)
bb9[rubyRegionId=0, firstDead=1](<returnMethodTemp>$2: String):
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String
    <unconditional> -> bb1

}

method ::<Class:Rescues>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(Rescues) = cast(<self>: NilClass, T.class_of(Rescues));
    <block-pre-call-temp>$6: Sorbet::Private::Static::Void = <self>: T.class_of(Rescues).takes_block()
    <selfRestore>$7: T.class_of(Rescues) = <self>
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
# - bb10(rubyRegionId=4)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb13(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Rescues), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: NilClass, <castTemp>$14: NilClass, <gotoDeadTemp>$26: NilClass):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=2](<block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues)):
    <statTemp>$4: T.untyped = Solve<<block-pre-call-temp>$6, takes_block>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Rescues), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: NilClass, <castTemp>$14: NilClass, <gotoDeadTemp>$26: NilClass):
    # outerLoops: 1
    <self>: T.class_of(Rescues) = loadSelf(takes_block)
    <magic>$18: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$10: T.untyped = <get-current-exception>
    <self>: Integer = cast(<castTemp>$14: NilClass, Integer);
    <exceptionValue>$10 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb5(rubyRegionId=1)
# - bb8(rubyRegionId=2)
bb7[rubyRegionId=3, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: T.nilable(Integer), <exceptionValue>$10: T.untyped, <castTemp>$14: T.nilable(Integer), <magic>$18: T.class_of(<Magic>), <gotoDeadTemp>$26: NilClass):
    # outerLoops: 1
    <cfgAlias>$21: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$22: T.untyped = <exceptionValue>$10: T.untyped.is_a?(<cfgAlias>$21: T.class_of(StandardError))
    <isaCheckTemp>$22 -> (T.untyped ? bb11 : bb12)

# backedges
# - bb5(rubyRegionId=1)
bb8[rubyRegionId=2, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <magic>$18: T.class_of(<Magic>), <gotoDeadTemp>$26: NilClass):
    # outerLoops: 1
    <cfgAlias>$13: T.class_of(Integer) = alias <C Integer>
    keep_for_ide$12: T.class_of(Integer) = <cfgAlias>$13
    keep_for_ide$12: T.untyped = <keep-alive> keep_for_ide$12
    <castTemp>$14: Integer = <self>
    <self>: Integer = cast(<castTemp>$14: Integer, Integer);
    <cfgAlias>$16: T.class_of(T) = alias <C T>
    <blockReturnTemp>$9: Integer = <cfgAlias>$16: T.class_of(T).reveal_type(<self>: Integer)
    <exceptionValue>$10: T.untyped = <get-current-exception>
    <exceptionValue>$10 -> (T.untyped ? bb7 : bb9)

# backedges
# - bb8(rubyRegionId=2)
bb9[rubyRegionId=5, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: Integer, <castTemp>$14: Integer, <gotoDeadTemp>$26: NilClass):
    # outerLoops: 1
    <unconditional> -> bb10

# backedges
# - bb9(rubyRegionId=5)
# - bb11(rubyRegionId=3)
# - bb12(rubyRegionId=3)
bb10[rubyRegionId=4, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: T.nilable(Integer), <castTemp>$14: T.nilable(Integer), <gotoDeadTemp>$26: T.nilable(TrueClass)):
    # outerLoops: 1
    <gotoDeadTemp>$26 -> (T.nilable(TrueClass) ? bb1 : bb13)

# backedges
# - bb7(rubyRegionId=3)
bb11[rubyRegionId=3, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <castTemp>$14: T.nilable(Integer), <magic>$18: T.class_of(<Magic>), <gotoDeadTemp>$26: NilClass):
    # outerLoops: 1
    <exceptionValue>$10: NilClass = nil
    <keepForCfgTemp>$19: Sorbet::Private::Static::Void = <magic>$18: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$10: NilClass)
    <cfgAlias>$24: T.class_of(T) = alias <C T>
    <blockReturnTemp>$9: Integer = <cfgAlias>$24: T.class_of(T).reveal_type(<self>: Integer)
    <unconditional> -> bb10

# backedges
# - bb7(rubyRegionId=3)
bb12[rubyRegionId=3, firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: T.nilable(Integer), <castTemp>$14: T.nilable(Integer)):
    # outerLoops: 1
    <gotoDeadTemp>$26: TrueClass = true
    <unconditional> -> bb10

# backedges
# - bb10(rubyRegionId=4)
bb13[rubyRegionId=1, firstDead=1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$9: Integer, <castTemp>$14: T.nilable(Integer), <gotoDeadTemp>$26: NilClass):
    # outerLoops: 1
    <blockReturnTemp>$28: T.noreturn = blockreturn<takes_block> <blockReturnTemp>$9: Integer
    <unconditional> -> bb2

}

