method ::<Class:<root>>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(<root>) = cast(<self>: NilClass, T.class_of(<root>));
    <cfgAlias>$5: T.class_of(B) = alias <C B>
    <block-pre-call-temp>$6: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(B).class_helper()
    <selfRestore>$7: T.class_of(<root>) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(<root>), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(<root>)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=5](<block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(<root>)):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$6, class_helper>
    <self>: T.class_of(<root>) = <selfRestore>$7
    <cfgAlias>$21: T.class_of(T) = alias <C T>
    <statTemp>$19: T.class_of(<root>) = <cfgAlias>$21: T.class_of(T).reveal_type(<self>: T.class_of(<root>))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=10](<self>: T.class_of(<root>), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(<root>)):
    # outerLoops: 1
    <self>: T.class_of(<root>) = loadSelf(class_helper)
    <cfgAlias>$11: T.class_of(B) = alias <C B>
    keep_for_ide$10: T.class_of(B) = <cfgAlias>$11
    keep_for_ide$10: T.untyped = <keep-alive> keep_for_ide$10
    <castTemp>$12: T.class_of(<root>) = <self>
    <self>: B = cast(<castTemp>$12: T.class_of(<root>), B);
    <cfgAlias>$15: T.class_of(T) = alias <C T>
    <statTemp>$13: B = <cfgAlias>$15: T.class_of(T).reveal_type(<self>: B)
    <blockReturnTemp>$8: T.untyped = <self>: B.instance_helper()
    <blockReturnTemp>$18: T.noreturn = blockreturn<class_helper> <blockReturnTemp>$8: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Base>#before_save {

bb0[firstDead=2]():
    <self>: T.class_of(Base) = cast(<self>: NilClass, T.class_of(Base));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Base>#before_create {

bb0[firstDead=2]():
    <self>: T.class_of(Base) = cast(<self>: NilClass, T.class_of(Base));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Base>#<static-init> {

bb0[firstDead=2]():
    <self>: T.class_of(Base) = cast(<self>: NilClass, T.class_of(Base));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Concern#included {

bb0[firstDead=6]():
    @block$3: T.untyped = alias <C <undeclared-field-stub>> (@block)
    <self>: Concern = cast(<self>: NilClass, Concern);
    block: T.untyped = load_arg(block)
    @block$3: T.untyped = block
    <returnMethodTemp>$2: T.untyped = @block$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Concern>#<static-init> {

bb0[firstDead=3]():
    <self>: T.class_of(Concern) = cast(<self>: NilClass, T.class_of(Concern));
    <returnMethodTemp>$2: Symbol(:included) = :included
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:included)
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Readable>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(Readable) = cast(<self>: NilClass, T.class_of(Readable));
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Readable) = <self>: T.class_of(Readable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Readable).included()
    <selfRestore>$10: T.class_of(Readable) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(Readable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=2](<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable)):
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=4](<self>: T.class_of(Readable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Readable)):
    # outerLoops: 1
    <self>: T.class_of(Readable) = loadSelf(included)
    <statTemp>$13: Symbol(:do_this) = :do_this
    <blockReturnTemp>$11: T.untyped = <self>: T.class_of(Readable).before_create(<statTemp>$13: Symbol(:do_this))
    <blockReturnTemp>$14: T.noreturn = blockreturn<included> <blockReturnTemp>$11: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Writable>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(Writable) = cast(<self>: NilClass, T.class_of(Writable));
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Writable) = <self>: T.class_of(Writable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Writable).included()
    <selfRestore>$10: T.class_of(Writable) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(Writable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=2](<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable)):
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=15](<self>: T.class_of(Writable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Writable)):
    # outerLoops: 1
    <self>: T.class_of(Writable) = loadSelf(included)
    <cfgAlias>$15: T.class_of(T) = alias <C T>
    <cfgAlias>$18: T.class_of(T) = alias <C T>
    <cfgAlias>$20: T.class_of(Article) = alias <C Article>
    <statTemp>$16: Runtime object representing type: T.class_of(Article) = <cfgAlias>$18: T.class_of(T).class_of(<cfgAlias>$20: T.class_of(Article))
    <cfgAlias>$23: T.class_of(T) = alias <C T>
    <cfgAlias>$25: T.class_of(Post) = alias <C Post>
    <statTemp>$21: Runtime object representing type: T.class_of(Post) = <cfgAlias>$23: T.class_of(T).class_of(<cfgAlias>$25: T.class_of(Post))
    keep_for_ide$13: Runtime object representing type: T.any(T.class_of(Article), T.class_of(Post)) = <cfgAlias>$15: T.class_of(T).any(<statTemp>$16: Runtime object representing type: T.class_of(Article), <statTemp>$21: Runtime object representing type: T.class_of(Post))
    keep_for_ide$13: T.untyped = <keep-alive> keep_for_ide$13
    <castTemp>$26: T.class_of(Writable) = <self>
    <self>: T.any(T.class_of(Article), T.class_of(Post)) = cast(<castTemp>$26: T.class_of(Writable), T.any(T.class_of(Article), T.class_of(Post)));
    <statTemp>$28: Symbol(:name) = :name
    <blockReturnTemp>$11: T.untyped = <self>: T.any(T.class_of(Article), T.class_of(Post)).some_class_method(<statTemp>$28: Symbol(:name))
    <blockReturnTemp>$29: T.noreturn = blockreturn<included> <blockReturnTemp>$11: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Shareable>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(Shareable) = cast(<self>: NilClass, T.class_of(Shareable));
    <cfgAlias>$6: T.class_of(Concern) = alias <C Concern>
    <statTemp>$3: T.class_of(Shareable) = <self>: T.class_of(Shareable).extend(<cfgAlias>$6: T.class_of(Concern))
    <block-pre-call-temp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(Shareable).included()
    <selfRestore>$10: T.class_of(Shareable) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(Shareable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=2](<block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable)):
    <statTemp>$7: T.untyped = Solve<<block-pre-call-temp>$9, included>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=10](<self>: T.class_of(Shareable), <block-pre-call-temp>$9: Sorbet::Private::Static::Void, <selfRestore>$10: T.class_of(Shareable)):
    # outerLoops: 1
    <self>: T.class_of(Shareable) = loadSelf(included)
    <cfgAlias>$15: T.class_of(T) = alias <C T>
    <cfgAlias>$17: T.class_of(Article) = alias <C Article>
    keep_for_ide$13: Runtime object representing type: T.class_of(Article) = <cfgAlias>$15: T.class_of(T).class_of(<cfgAlias>$17: T.class_of(Article))
    keep_for_ide$13: T.untyped = <keep-alive> keep_for_ide$13
    <castTemp>$18: T.class_of(Shareable) = <self>
    <self>: T.class_of(Article) = cast(<castTemp>$18: T.class_of(Shareable), T.class_of(Article));
    <statTemp>$20: Symbol(:do_this) = :do_this
    <blockReturnTemp>$11: T.untyped = <self>: T.class_of(Article).before_save(<statTemp>$20: Symbol(:do_this))
    <blockReturnTemp>$21: T.noreturn = blockreturn<included> <blockReturnTemp>$11: T.untyped
    <unconditional> -> bb2

}

method ::<Class:Post>#some_class_method {

bb0[firstDead=2]():
    <self>: T.class_of(Post) = cast(<self>: NilClass, T.class_of(Post));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Post#author {

bb0[firstDead=2]():
    <self>: Post = cast(<self>: NilClass, Post);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Post#should_run_callback? {

bb0[firstDead=3]():
    <self>: Post = cast(<self>: NilClass, Post);
    <returnMethodTemp>$2: TrueClass = true
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: TrueClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Post#score {

bb0[firstDead=5]():
    <self>: Post = cast(<self>: NilClass, Post);
    <cfgAlias>$4: T.class_of(Integer) = alias <C Integer>
    keep_for_ide$3: T.class_of(Integer) = <cfgAlias>$4
    keep_for_ide$3: T.untyped = <keep-alive> keep_for_ide$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Post>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(Post) = cast(<self>: NilClass, T.class_of(Post));
    <cfgAlias>$6: T.class_of(Readable) = alias <C Readable>
    <statTemp>$3: T.class_of(Post) = <self>: T.class_of(Post).include(<cfgAlias>$6: T.class_of(Readable))
    <cfgAlias>$10: T.class_of(Writable) = alias <C Writable>
    <statTemp>$7: T.class_of(Post) = <self>: T.class_of(Post).include(<cfgAlias>$10: T.class_of(Writable))
    <statTemp>$12: T.class_of(Post) = <self>
    <statTemp>$13: Symbol(:run_callback) = :run_callback
    <hashTemp>$14: Symbol(:if) = :if
    <cfgAlias>$17: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$18: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(Kernel).lambda()
    <selfRestore>$19: T.class_of(Post) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(Post), <statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=3](<statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post)):
    <hashTemp>$15: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$18, lambda>
    <statTemp>$11: T.untyped = <statTemp>$12: T.class_of(Post).before_create(<statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <hashTemp>$15: T.proc.returns(T.untyped))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=3](<self>: T.class_of(Post), <statTemp>$12: T.class_of(Post), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Post)):
    # outerLoops: 1
    <self>: T.class_of(Post) = loadSelf(lambda)
    <blockReturnTemp>$20: T.untyped = <self>: T.class_of(Post).should_run_callback?()
    <blockReturnTemp>$22: T.noreturn = blockreturn<lambda> <blockReturnTemp>$20: T.untyped
    <unconditional> -> bb2

}

method ::Article#author {

bb0[firstDead=2]():
    <self>: Article = cast(<self>: NilClass, Article);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Article#should_run_callback? {

bb0[firstDead=3]():
    <self>: Article = cast(<self>: NilClass, Article);
    <returnMethodTemp>$2: TrueClass = true
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: TrueClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Article>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(Article) = cast(<self>: NilClass, T.class_of(Article));
    <cfgAlias>$6: T.class_of(Writable) = alias <C Writable>
    <statTemp>$3: T.class_of(Article) = <self>: T.class_of(Article).include(<cfgAlias>$6: T.class_of(Writable))
    <cfgAlias>$10: T.class_of(Shareable) = alias <C Shareable>
    <statTemp>$7: T.class_of(Article) = <self>: T.class_of(Article).include(<cfgAlias>$10: T.class_of(Shareable))
    <statTemp>$12: T.class_of(Article) = <self>
    <statTemp>$13: Symbol(:run_callback) = :run_callback
    <hashTemp>$14: Symbol(:if) = :if
    <cfgAlias>$17: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$18: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(Kernel).lambda()
    <selfRestore>$19: T.class_of(Article) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(Article), <statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=3](<statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article)):
    <hashTemp>$15: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$18, lambda>
    <statTemp>$11: T.untyped = <statTemp>$12: T.class_of(Article).before_create(<statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <hashTemp>$15: T.proc.returns(T.untyped))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=8](<self>: T.class_of(Article), <statTemp>$12: T.class_of(Article), <statTemp>$13: Symbol(:run_callback), <hashTemp>$14: Symbol(:if), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Article)):
    # outerLoops: 1
    <self>: T.class_of(Article) = loadSelf(lambda)
    <cfgAlias>$23: T.class_of(Article) = alias <C Article>
    keep_for_ide$22: T.class_of(Article) = <cfgAlias>$23
    keep_for_ide$22: T.untyped = <keep-alive> keep_for_ide$22
    <castTemp>$24: T.class_of(Article) = <self>
    <self>: Article = cast(<castTemp>$24: T.class_of(Article), Article);
    <blockReturnTemp>$20: T.untyped = <self>: Article.should_run_callback?()
    <blockReturnTemp>$25: T.noreturn = blockreturn<lambda> <blockReturnTemp>$20: T.untyped
    <unconditional> -> bb2

}

method ::A#instance_helper {

bb0[firstDead=2]():
    <self>: A = cast(<self>: NilClass, A);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:A>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(A) = cast(<self>: NilClass, T.class_of(A));
    <cfgAlias>$6: T.class_of(Kernel) = alias <C Kernel>
    <block-pre-call-temp>$7: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(Kernel).lambda()
    <selfRestore>$8: T.class_of(A) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(A), <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(A)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=6](<block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(A)):
    f: T.proc.returns(T.untyped) = Solve<<block-pre-call-temp>$7, lambda>
    <self>: T.class_of(A) = <selfRestore>$8
    <cfgAlias>$22: T.class_of(T) = alias <C T>
    <statTemp>$20: T.class_of(A) = <cfgAlias>$22: T.class_of(T).reveal_type(<self>: T.class_of(A))
    <statTemp>$24: NilClass = <self>: T.class_of(A).puts(f: T.proc.returns(T.untyped))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=10](<self>: T.class_of(A), <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(A)):
    # outerLoops: 1
    <self>: T.class_of(A) = loadSelf(lambda)
    <cfgAlias>$12: T.class_of(A) = alias <C A>
    keep_for_ide$11: T.class_of(A) = <cfgAlias>$12
    keep_for_ide$11: T.untyped = <keep-alive> keep_for_ide$11
    <castTemp>$13: T.class_of(A) = <self>
    <self>: A = cast(<castTemp>$13: T.class_of(A), A);
    <cfgAlias>$16: T.class_of(T) = alias <C T>
    <statTemp>$14: A = <cfgAlias>$16: T.class_of(T).reveal_type(<self>: A)
    <blockReturnTemp>$9: T.untyped = <self>: A.instance_helper()
    <blockReturnTemp>$19: T.noreturn = blockreturn<lambda> <blockReturnTemp>$9: T.untyped
    <unconditional> -> bb2

}

method ::<Class:B>#class_helper {

bb0[firstDead=2]():
    <self>: T.class_of(B) = cast(<self>: NilClass, T.class_of(B));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::B#instance_helper {

bb0[firstDead=2]():
    <self>: B = cast(<self>: NilClass, B);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:B>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(B) = cast(<self>: NilClass, T.class_of(B));
    <cfgAlias>$5: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <block-pre-call-temp>$7: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(Sorbet::Private::Static).sig(<self>: T.class_of(B))
    <selfRestore>$8: T.class_of(B) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(B), <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(B)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=6](<block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(B)):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$7, sig>
    <self>: T.class_of(B) = <selfRestore>$8
    <cfgAlias>$21: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$23: T.class_of(T) = alias <C T>
    <statTemp>$18: T.class_of(B) = <self>: T.class_of(B).extend(<cfgAlias>$21: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=8](<self>: T.class_of(B), <block-pre-call-temp>$7: Sorbet::Private::Static::Void, <selfRestore>$8: T.class_of(B)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$12: Symbol(:blk) = :blk
    <cfgAlias>$16: T.class_of(T) = alias <C T>
    <statTemp>$14: T.class_of(T.proc) = <cfgAlias>$16: T.class_of(T).proc()
    <hashTemp>$13: Runtime object representing type: T.proc.void = <statTemp>$14: T.class_of(T.proc).void()
    <statTemp>$10: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$12: Symbol(:blk), <hashTemp>$13: Runtime object representing type: T.proc.void)
    <blockReturnTemp>$9: T::Private::Methods::DeclBuilder = <statTemp>$10: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$17: T.noreturn = blockreturn<sig> <blockReturnTemp>$9: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

}

method ::N#helper_from_N {

bb0[firstDead=2]():
    <self>: N = cast(<self>: NilClass, N);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:N>#<static-init> {

bb0[firstDead=3]():
    <self>: T.class_of(N) = cast(<self>: NilClass, T.class_of(N));
    <returnMethodTemp>$2: Symbol(:helper_from_N) = :helper_from_N
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:helper_from_N)
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::M#helper_from_M {

bb0[firstDead=2]():
    <self>: M = cast(<self>: NilClass, M);
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::M#main {

bb0[firstDead=13]():
    <self>: M = cast(<self>: NilClass, M);
    <cfgAlias>$6: T.class_of(T) = alias <C T>
    <cfgAlias>$8: T.class_of(M) = alias <C M>
    <cfgAlias>$10: T.class_of(N) = alias <C N>
    keep_for_ide$4: Runtime object representing type: T.all(M, N) = <cfgAlias>$6: T.class_of(T).all(<cfgAlias>$8: T.class_of(M), <cfgAlias>$10: T.class_of(N))
    keep_for_ide$4: T.untyped = <keep-alive> keep_for_ide$4
    <castTemp>$11: M = <self>
    <self>: T.all(M, N) = cast(<castTemp>$11: M, T.all(M, N));
    <cfgAlias>$14: T.class_of(T) = alias <C T>
    <statTemp>$12: T.all(M, N) = <cfgAlias>$14: T.class_of(T).reveal_type(<self>: T.all(M, N))
    <statTemp>$16: T.untyped = <self>: T.all(M, N).helper_from_M()
    <returnMethodTemp>$2: T.untyped = <self>: T.all(M, N).helper_from_N()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:M>#<static-init> {

bb0[firstDead=5]():
    <self>: T.class_of(M) = cast(<self>: NilClass, T.class_of(M));
    <cfgAlias>$6: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$3: T.class_of(M) = <self>: T.class_of(M).extend(<cfgAlias>$6: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::ThisSelf#main {

bb0[firstDead=11]():
    <self>: ThisSelf = cast(<self>: NilClass, ThisSelf);
    <cfgAlias>$5: T.class_of(Kernel) = alias <C Kernel>
    keep_for_ide$4: T.class_of(Kernel) = <cfgAlias>$5
    keep_for_ide$4: T.untyped = <keep-alive> keep_for_ide$4
    <castTemp>$6: ThisSelf = <self>
    <self>: Kernel = cast(<castTemp>$6: ThisSelf, Kernel);
    this: Kernel = <self>
    <cfgAlias>$9: T.class_of(T) = alias <C T>
    <statTemp>$7: Kernel = <cfgAlias>$9: T.class_of(T).reveal_type(this: Kernel)
    <returnMethodTemp>$2: NilClass = this: Kernel.puts()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:ThisSelf>#<static-init> {

bb0[firstDead=5]():
    <self>: T.class_of(ThisSelf) = cast(<self>: NilClass, T.class_of(ThisSelf));
    <cfgAlias>$6: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$3: T.class_of(ThisSelf) = <self>: T.class_of(ThisSelf).extend(<cfgAlias>$6: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Rescues>#takes_block {

bb0[firstDead=2]():
    <self>: T.class_of(Rescues) = cast(<self>: NilClass, T.class_of(Rescues));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Rescues#foo {

bb0[firstDead=-1]():
    <self>: Rescues = cast(<self>: NilClass, Rescues);
    <exceptionValue>$3: T.nilable(Exception) = <get-current-exception>
    <self>: String = cast(<castTemp>$7: NilClass, String);
    <exceptionValue>$3 -> (T.nilable(Exception) ? bb3 : bb4)

# backedges
# - bb6
# - bb9
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb4
bb3[firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$3: Exception):
    <cfgAlias>$16: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$17: T::Boolean = <cfgAlias>$16: T.class_of(StandardError).===(<exceptionValue>$3: Exception)
    <isaCheckTemp>$17 -> (T::Boolean ? bb7 : bb8)

# backedges
# - bb0
bb4[firstDead=-1](<self>: String):
    <cfgAlias>$6: T.class_of(String) = alias <C String>
    keep_for_ide$5: T.class_of(String) = <cfgAlias>$6
    keep_for_ide$5: T.untyped = <keep-alive> keep_for_ide$5
    <castTemp>$7: String = <self>
    <self>: String = cast(<castTemp>$7: String, String);
    <cfgAlias>$9: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$9: T.class_of(T).reveal_type(<self>: String)
    <exceptionValue>$3: T.nilable(Exception) = <get-current-exception>
    <exceptionValue>$3 -> (T.nilable(Exception) ? bb3 : bb6)

# backedges
# - bb4
# - bb7
# - bb8
bb6[firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$3: T.nilable(Exception), <gotoDeadTemp>$21: T.nilable(TrueClass)):
    <cfgAlias>$12: T.class_of(T) = alias <C T>
    <rescueTemp>$2: T.untyped = <cfgAlias>$12: T.class_of(T).unsafe(<exceptionValue>$3: T.nilable(Exception))
    <cfgAlias>$24: T.class_of(T) = alias <C T>
    <throwAwayTemp>$22: String = <cfgAlias>$24: T.class_of(T).reveal_type(<self>: String)
    <gotoDeadTemp>$21 -> (T.nilable(TrueClass) ? bb1 : bb9)

# backedges
# - bb3
bb7[firstDead=-1](<self>: String, <exceptionValue>$3: StandardError):
    <exceptionValue>$3: NilClass = nil
    <keepForCfgTemp>$14: T.untyped = <keep-alive> <exceptionValue>$3
    <cfgAlias>$19: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$19: T.class_of(T).reveal_type(<self>: String)
    <unconditional> -> bb6

# backedges
# - bb3
bb8[firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$3: Exception):
    <gotoDeadTemp>$21: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6
bb9[firstDead=1](<returnMethodTemp>$2: String):
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String
    <unconditional> -> bb1

}

method ::Rescues#bar {

bb0[firstDead=-1]():
    <self>: Rescues = cast(<self>: NilClass, Rescues);
    <exceptionValue>$3: T.nilable(Exception) = <get-current-exception>
    <self>: String = cast(<castTemp>$7: NilClass, String);
    <self>: Integer = cast(<castTemp>$21: NilClass, Integer);
    <self>: Float = cast(<castTemp>$30: NilClass, Float);
    <exceptionValue>$3 -> (T.nilable(Exception) ? bb3 : bb4)

# backedges
# - bb6
# - bb9
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb4
bb3[firstDead=-1](<self>: T.any(Float, String), <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$3: Exception):
    <cfgAlias>$16: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$17: T::Boolean = <cfgAlias>$16: T.class_of(StandardError).===(<exceptionValue>$3: Exception)
    <isaCheckTemp>$17 -> (T::Boolean ? bb7 : bb8)

# backedges
# - bb0
bb4[firstDead=-1](<self>: Float):
    <cfgAlias>$6: T.class_of(String) = alias <C String>
    keep_for_ide$5: T.class_of(String) = <cfgAlias>$6
    keep_for_ide$5: T.untyped = <keep-alive> keep_for_ide$5
    <castTemp>$7: Float = <self>
    <self>: String = cast(<castTemp>$7: Float, String);
    <cfgAlias>$9: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$9: T.class_of(T).reveal_type(<self>: String)
    <exceptionValue>$3: T.nilable(Exception) = <get-current-exception>
    <exceptionValue>$3 -> (T.nilable(Exception) ? bb3 : bb6)

# backedges
# - bb4
# - bb7
# - bb8
bb6[firstDead=-1](<self>: T.any(Float, String, Integer), <returnMethodTemp>$2: T.nilable(T.any(String, Integer)), <exceptionValue>$3: T.nilable(Exception), <gotoDeadTemp>$25: T.nilable(TrueClass)):
    <cfgAlias>$12: T.class_of(T) = alias <C T>
    <rescueTemp>$2: T.untyped = <cfgAlias>$12: T.class_of(T).unsafe(<exceptionValue>$3: T.nilable(Exception))
    <cfgAlias>$29: T.class_of(Float) = alias <C Float>
    keep_for_ide$28: T.class_of(Float) = <cfgAlias>$29
    keep_for_ide$28: T.untyped = <keep-alive> keep_for_ide$28
    <castTemp>$30: T.any(Float, String, Integer) = <self>
    <self>: Float = cast(<castTemp>$30: T.any(Float, String, Integer), Float);
    <cfgAlias>$32: T.class_of(T) = alias <C T>
    <throwAwayTemp>$26: Float = <cfgAlias>$32: T.class_of(T).reveal_type(<self>: Float)
    <gotoDeadTemp>$25 -> (T.nilable(TrueClass) ? bb1 : bb9)

# backedges
# - bb3
bb7[firstDead=-1](<self>: T.any(Float, String), <exceptionValue>$3: StandardError):
    <exceptionValue>$3: NilClass = nil
    <keepForCfgTemp>$14: T.untyped = <keep-alive> <exceptionValue>$3
    <cfgAlias>$20: T.class_of(Integer) = alias <C Integer>
    keep_for_ide$19: T.class_of(Integer) = <cfgAlias>$20
    keep_for_ide$19: T.untyped = <keep-alive> keep_for_ide$19
    <castTemp>$21: T.any(Float, String) = <self>
    <self>: Integer = cast(<castTemp>$21: T.any(Float, String), Integer);
    <cfgAlias>$23: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: Integer = <cfgAlias>$23: T.class_of(T).reveal_type(<self>: Integer)
    <unconditional> -> bb6

# backedges
# - bb3
bb8[firstDead=-1](<self>: T.any(Float, String), <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$3: Exception):
    <gotoDeadTemp>$25: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6
bb9[firstDead=1](<returnMethodTemp>$2: T.any(Integer, String)):
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.any(Integer, String)
    <unconditional> -> bb1

}

method ::Rescues#baz {

bb0[firstDead=-1]():
    <self>: Rescues = cast(<self>: NilClass, Rescues);
    <cfgAlias>$5: T.class_of(T) = alias <C T>
    <statTemp>$3: Rescues = <cfgAlias>$5: T.class_of(T).reveal_type(<self>: Rescues)
    <exceptionValue>$7: T.nilable(Exception) = <get-current-exception>
    <self>: String = cast(<castTemp>$11: NilClass, String);
    <exceptionValue>$7 -> (T.nilable(Exception) ? bb3 : bb4)

# backedges
# - bb6
# - bb7
# - bb8
# - bb9
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb4
bb3[firstDead=-1](<self>: String, <returnMethodTemp>$2: T.nilable(String), <exceptionValue>$7: Exception):
    <cfgAlias>$17: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$18: T::Boolean = <cfgAlias>$17: T.class_of(StandardError).===(<exceptionValue>$7: Exception)
    <isaCheckTemp>$18 -> (T::Boolean ? bb7 : bb8)

# backedges
# - bb0
bb4[firstDead=-1](<self>: String):
    <cfgAlias>$10: T.class_of(String) = alias <C String>
    keep_for_ide$9: T.class_of(String) = <cfgAlias>$10
    keep_for_ide$9: T.untyped = <keep-alive> keep_for_ide$9
    <castTemp>$11: String = <self>
    <self>: String = cast(<castTemp>$11: String, String);
    <cfgAlias>$13: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$13: T.class_of(T).reveal_type(<self>: String)
    <exceptionValue>$7: T.nilable(Exception) = <get-current-exception>
    <exceptionValue>$7 -> (T.nilable(Exception) ? bb3 : bb6)

# backedges
# - bb4
bb6[firstDead=-1](<returnMethodTemp>$2: String, <gotoDeadTemp>$22: NilClass):
    <gotoDeadTemp>$22 -> (NilClass ? bb1 : bb9)

# backedges
# - bb3
bb7[firstDead=-1](<self>: String, <exceptionValue>$7: StandardError):
    <exceptionValue>$7: NilClass = nil
    <keepForCfgTemp>$15: T.untyped = <keep-alive> <exceptionValue>$7
    <cfgAlias>$20: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: String = <cfgAlias>$20: T.class_of(T).reveal_type(<self>: String)
    <gotoDeadTemp>$22 -> (NilClass ? bb1 : bb9)

# backedges
# - bb3
bb8[firstDead=-1](<returnMethodTemp>$2: T.nilable(String)):
    <gotoDeadTemp>$22: TrueClass = true
    <gotoDeadTemp>$22 -> (TrueClass ? bb1 : bb9)

# backedges
# - bb6
# - bb7
# - bb8
bb9[firstDead=1](<returnMethodTemp>$2: String):
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String
    <unconditional> -> bb1

}

method ::<Class:Rescues>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(Rescues) = cast(<self>: NilClass, T.class_of(Rescues));
    <block-pre-call-temp>$6: Sorbet::Private::Static::Void = <self>: T.class_of(Rescues).takes_block()
    <selfRestore>$7: T.class_of(Rescues) = <self>
    <unconditional> -> bb2

# backedges
# - bb3
# - bb10
# - bb11
# - bb12
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb13
bb2[firstDead=-1](<self>: T.class_of(Rescues), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$8: NilClass, <castTemp>$13: NilClass, <gotoDeadTemp>$24: NilClass):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=2](<block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues)):
    <statTemp>$4: T.untyped = Solve<<block-pre-call-temp>$6, takes_block>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb2
bb5[firstDead=-1](<self>: T.class_of(Rescues), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$8: NilClass, <castTemp>$13: NilClass, <gotoDeadTemp>$24: NilClass):
    # outerLoops: 1
    <self>: T.class_of(Rescues) = loadSelf(takes_block)
    <exceptionValue>$9: T.nilable(Exception) = <get-current-exception>
    <self>: Integer = cast(<castTemp>$13: NilClass, Integer);
    <exceptionValue>$9 -> (T.nilable(Exception) ? bb7 : bb8)

# backedges
# - bb5
# - bb8
bb7[firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$8: T.nilable(Integer), <exceptionValue>$9: Exception, <castTemp>$13: T.nilable(Integer), <gotoDeadTemp>$24: NilClass):
    # outerLoops: 1
    <cfgAlias>$19: T.class_of(StandardError) = alias <C StandardError>
    <isaCheckTemp>$20: T::Boolean = <cfgAlias>$19: T.class_of(StandardError).===(<exceptionValue>$9: Exception)
    <isaCheckTemp>$20 -> (T::Boolean ? bb11 : bb12)

# backedges
# - bb5
bb8[firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <gotoDeadTemp>$24: NilClass):
    # outerLoops: 1
    <cfgAlias>$12: T.class_of(Integer) = alias <C Integer>
    keep_for_ide$11: T.class_of(Integer) = <cfgAlias>$12
    keep_for_ide$11: T.untyped = <keep-alive> keep_for_ide$11
    <castTemp>$13: Integer = <self>
    <self>: Integer = cast(<castTemp>$13: Integer, Integer);
    <cfgAlias>$15: T.class_of(T) = alias <C T>
    <blockReturnTemp>$8: Integer = <cfgAlias>$15: T.class_of(T).reveal_type(<self>: Integer)
    <exceptionValue>$9: T.nilable(Exception) = <get-current-exception>
    <exceptionValue>$9 -> (T.nilable(Exception) ? bb7 : bb10)

# backedges
# - bb8
bb10[firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$8: Integer, <castTemp>$13: Integer, <gotoDeadTemp>$24: NilClass):
    # outerLoops: 1
    <gotoDeadTemp>$24 -> (NilClass ? bb1 : bb13)

# backedges
# - bb7
bb11[firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <exceptionValue>$9: StandardError, <castTemp>$13: T.nilable(Integer), <gotoDeadTemp>$24: NilClass):
    # outerLoops: 1
    <exceptionValue>$9: NilClass = nil
    <keepForCfgTemp>$17: T.untyped = <keep-alive> <exceptionValue>$9
    <cfgAlias>$22: T.class_of(T) = alias <C T>
    <blockReturnTemp>$8: Integer = <cfgAlias>$22: T.class_of(T).reveal_type(<self>: Integer)
    <gotoDeadTemp>$24 -> (NilClass ? bb1 : bb13)

# backedges
# - bb7
bb12[firstDead=-1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$8: T.nilable(Integer), <castTemp>$13: T.nilable(Integer)):
    # outerLoops: 1
    <gotoDeadTemp>$24: TrueClass = true
    <gotoDeadTemp>$24 -> (TrueClass ? bb1 : bb13)

# backedges
# - bb10
# - bb11
# - bb12
bb13[firstDead=1](<self>: Integer, <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Rescues), <blockReturnTemp>$8: Integer, <castTemp>$13: T.nilable(Integer), <gotoDeadTemp>$24: NilClass):
    # outerLoops: 1
    <blockReturnTemp>$26: T.noreturn = blockreturn<takes_block> <blockReturnTemp>$8: Integer
    <unconditional> -> bb2

}

method ::UntypedBind#foo {

bb0[firstDead=18]():
    <self>: UntypedBind = cast(<self>: NilClass, UntypedBind);
    <cfgAlias>$5: T.class_of(T) = alias <C T>
    <statTemp>$3: UntypedBind = <cfgAlias>$5: T.class_of(T).reveal_type(<self>: UntypedBind)
    <cfgAlias>$10: T.class_of(T) = alias <C T>
    keep_for_ide$8: Runtime object representing type: T.untyped = <cfgAlias>$10: T.class_of(T).untyped()
    keep_for_ide$8: T.untyped = <keep-alive> keep_for_ide$8
    <castTemp>$11: UntypedBind = <self>
    <self>: T.untyped = cast(<castTemp>$11: UntypedBind, T.untyped);
    <cfgAlias>$14: T.class_of(T) = alias <C T>
    <statTemp>$12: T.untyped = <cfgAlias>$14: T.class_of(T).reveal_type(<self>: T.untyped)
    <cfgAlias>$18: T.class_of(UntypedBind) = alias <C UntypedBind>
    keep_for_ide$17: T.class_of(UntypedBind) = <cfgAlias>$18
    keep_for_ide$17: T.untyped = <keep-alive> keep_for_ide$17
    <castTemp>$19: T.untyped = <self>
    <self>: UntypedBind = cast(<castTemp>$19: T.untyped, UntypedBind);
    <cfgAlias>$21: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: UntypedBind = <cfgAlias>$21: T.class_of(T).reveal_type(<self>: UntypedBind)
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: UntypedBind
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:UntypedBind>#<static-init> {

bb0[firstDead=3]():
    <self>: T.class_of(UntypedBind) = cast(<self>: NilClass, T.class_of(UntypedBind));
    <returnMethodTemp>$2: Symbol(:foo) = :foo
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:foo)
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

