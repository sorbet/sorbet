method ::<Class:<root>>#<static-init> {

bb0[rubyBlockId=0, firstDead=164]():
    <self>: T.class_of(<root>) = cast(<self>: NilClass, T.class_of(<root>));
    <cfgAlias>$6: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$8: T.class_of(C1) = alias <C C1>
    <statTemp>$4: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$8: T.class_of(C1))
    <cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$13: T.class_of(C1) = alias <C C1>
    <statTemp>$9: Sorbet::Private::Static::Void = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$13: T.class_of(C1))
    <cfgAlias>$17: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$19: T.class_of(C2) = alias <C C2>
    <statTemp>$15: Sorbet::Private::Static::Void = <cfgAlias>$17: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$19: T.class_of(C2))
    <cfgAlias>$22: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$24: T.class_of(C2) = alias <C C2>
    <statTemp>$20: Sorbet::Private::Static::Void = <cfgAlias>$22: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$24: T.class_of(C2))
    <cfgAlias>$28: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$30: T.class_of(C3) = alias <C C3>
    <statTemp>$26: Sorbet::Private::Static::Void = <cfgAlias>$28: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$30: T.class_of(C3))
    <cfgAlias>$33: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$35: T.class_of(C3) = alias <C C3>
    <statTemp>$31: Sorbet::Private::Static::Void = <cfgAlias>$33: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$35: T.class_of(C3))
    <cfgAlias>$39: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$41: T.class_of(C4) = alias <C C4>
    <statTemp>$37: Sorbet::Private::Static::Void = <cfgAlias>$39: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$41: T.class_of(C4))
    <cfgAlias>$44: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$46: T.class_of(C4) = alias <C C4>
    <statTemp>$42: Sorbet::Private::Static::Void = <cfgAlias>$44: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$46: T.class_of(C4))
    <cfgAlias>$50: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$52: T.class_of(C5) = alias <C C5>
    <statTemp>$48: Sorbet::Private::Static::Void = <cfgAlias>$50: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$52: T.class_of(C5))
    <cfgAlias>$55: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$57: T.class_of(C5) = alias <C C5>
    <statTemp>$53: Sorbet::Private::Static::Void = <cfgAlias>$55: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$57: T.class_of(C5))
    <cfgAlias>$61: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$63: T.class_of(C6) = alias <C C6>
    <statTemp>$59: Sorbet::Private::Static::Void = <cfgAlias>$61: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$63: T.class_of(C6))
    <cfgAlias>$66: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$68: T.class_of(C6) = alias <C C6>
    <statTemp>$64: Sorbet::Private::Static::Void = <cfgAlias>$66: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$68: T.class_of(C6))
    <cfgAlias>$72: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$74: T.class_of(C7) = alias <C C7>
    <statTemp>$70: Sorbet::Private::Static::Void = <cfgAlias>$72: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$74: T.class_of(C7))
    <cfgAlias>$77: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$79: T.class_of(C7) = alias <C C7>
    <statTemp>$75: Sorbet::Private::Static::Void = <cfgAlias>$77: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$79: T.class_of(C7))
    <cfgAlias>$83: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$85: T.class_of(C8) = alias <C C8>
    <statTemp>$81: Sorbet::Private::Static::Void = <cfgAlias>$83: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$85: T.class_of(C8))
    <cfgAlias>$88: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$90: T.class_of(C8) = alias <C C8>
    <statTemp>$86: Sorbet::Private::Static::Void = <cfgAlias>$88: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$90: T.class_of(C8))
    <cfgAlias>$94: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$96: T.class_of(C9) = alias <C C9>
    <statTemp>$92: Sorbet::Private::Static::Void = <cfgAlias>$94: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$96: T.class_of(C9))
    <cfgAlias>$99: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$101: T.class_of(C9) = alias <C C9>
    <statTemp>$97: Sorbet::Private::Static::Void = <cfgAlias>$99: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$101: T.class_of(C9))
    <cfgAlias>$105: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$107: T.class_of(C10) = alias <C C10>
    <statTemp>$103: Sorbet::Private::Static::Void = <cfgAlias>$105: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$107: T.class_of(C10))
    <cfgAlias>$110: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$112: T.class_of(C10) = alias <C C10>
    <statTemp>$108: Sorbet::Private::Static::Void = <cfgAlias>$110: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$112: T.class_of(C10))
    <cfgAlias>$116: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$118: T.class_of(C11) = alias <C C11>
    <statTemp>$114: Sorbet::Private::Static::Void = <cfgAlias>$116: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$118: T.class_of(C11))
    <cfgAlias>$121: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$123: T.class_of(C11) = alias <C C11>
    <statTemp>$119: Sorbet::Private::Static::Void = <cfgAlias>$121: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$123: T.class_of(C11))
    <cfgAlias>$127: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$129: T.class_of(C12) = alias <C C12>
    <statTemp>$125: Sorbet::Private::Static::Void = <cfgAlias>$127: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$129: T.class_of(C12))
    <cfgAlias>$132: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$134: T.class_of(C12) = alias <C C12>
    <statTemp>$130: Sorbet::Private::Static::Void = <cfgAlias>$132: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$134: T.class_of(C12))
    <cfgAlias>$138: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$140: T.class_of(C13) = alias <C C13>
    <statTemp>$136: Sorbet::Private::Static::Void = <cfgAlias>$138: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$140: T.class_of(C13))
    <cfgAlias>$143: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$145: T.class_of(C13) = alias <C C13>
    <statTemp>$141: Sorbet::Private::Static::Void = <cfgAlias>$143: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$145: T.class_of(C13))
    <cfgAlias>$149: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$151: T.class_of(C13) = alias <C C13>
    <statTemp>$147: Sorbet::Private::Static::Void = <cfgAlias>$149: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$151: T.class_of(C13))
    <cfgAlias>$154: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$156: T.class_of(C13) = alias <C C13>
    <statTemp>$152: Sorbet::Private::Static::Void = <cfgAlias>$154: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$156: T.class_of(C13))
    <cfgAlias>$160: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$162: T.class_of(C13) = alias <C C13>
    <statTemp>$158: Sorbet::Private::Static::Void = <cfgAlias>$160: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$162: T.class_of(C13))
    <cfgAlias>$165: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$167: T.class_of(C13) = alias <C C13>
    <statTemp>$163: Sorbet::Private::Static::Void = <cfgAlias>$165: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$167: T.class_of(C13))
    <cfgAlias>$171: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$173: T.class_of(C13) = alias <C C13>
    <statTemp>$169: Sorbet::Private::Static::Void = <cfgAlias>$171: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$173: T.class_of(C13))
    <cfgAlias>$176: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$178: T.class_of(C13) = alias <C C13>
    <statTemp>$174: Sorbet::Private::Static::Void = <cfgAlias>$176: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$178: T.class_of(C13))
    <cfgAlias>$182: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$184: T.class_of(C13) = alias <C C13>
    <statTemp>$180: Sorbet::Private::Static::Void = <cfgAlias>$182: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$184: T.class_of(C13))
    <cfgAlias>$187: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$189: T.class_of(C13) = alias <C C13>
    <statTemp>$185: Sorbet::Private::Static::Void = <cfgAlias>$187: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$189: T.class_of(C13))
    <cfgAlias>$193: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$195: T.class_of(C13) = alias <C C13>
    <statTemp>$191: Sorbet::Private::Static::Void = <cfgAlias>$193: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$195: T.class_of(C13))
    <cfgAlias>$198: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$200: T.class_of(C13) = alias <C C13>
    <statTemp>$196: Sorbet::Private::Static::Void = <cfgAlias>$198: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$200: T.class_of(C13))
    <cfgAlias>$204: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$206: T.class_of(C13) = alias <C C13>
    <statTemp>$202: Sorbet::Private::Static::Void = <cfgAlias>$204: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$206: T.class_of(C13))
    <cfgAlias>$209: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$211: T.class_of(C13) = alias <C C13>
    <statTemp>$207: Sorbet::Private::Static::Void = <cfgAlias>$209: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$211: T.class_of(C13))
    <cfgAlias>$215: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$217: T.class_of(C14) = alias <C C14>
    <statTemp>$213: Sorbet::Private::Static::Void = <cfgAlias>$215: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$217: T.class_of(C14))
    <cfgAlias>$220: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$222: T.class_of(C14) = alias <C C14>
    <statTemp>$218: Sorbet::Private::Static::Void = <cfgAlias>$220: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$222: T.class_of(C14))
    <cfgAlias>$226: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$228: T.class_of(C15) = alias <C C15>
    <statTemp>$224: Sorbet::Private::Static::Void = <cfgAlias>$226: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$228: T.class_of(C15))
    <cfgAlias>$231: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$233: T.class_of(C15) = alias <C C15>
    <statTemp>$229: Sorbet::Private::Static::Void = <cfgAlias>$231: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$233: T.class_of(C15))
    <cfgAlias>$237: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$239: T.class_of(C16) = alias <C C16>
    <statTemp>$235: Sorbet::Private::Static::Void = <cfgAlias>$237: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$239: T.class_of(C16))
    <cfgAlias>$242: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$244: T.class_of(C16) = alias <C C16>
    <statTemp>$240: Sorbet::Private::Static::Void = <cfgAlias>$242: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$244: T.class_of(C16))
    <cfgAlias>$248: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$250: T.class_of(C17) = alias <C C17>
    <statTemp>$246: Sorbet::Private::Static::Void = <cfgAlias>$248: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$250: T.class_of(C17))
    <cfgAlias>$253: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$255: T.class_of(C17) = alias <C C17>
    <statTemp>$251: Sorbet::Private::Static::Void = <cfgAlias>$253: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$255: T.class_of(C17))
    <cfgAlias>$259: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$261: T.class_of(C18) = alias <C C18>
    <statTemp>$257: Sorbet::Private::Static::Void = <cfgAlias>$259: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$261: T.class_of(C18))
    <cfgAlias>$264: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$266: T.class_of(C18) = alias <C C18>
    <statTemp>$262: Sorbet::Private::Static::Void = <cfgAlias>$264: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$266: T.class_of(C18))
    <cfgAlias>$270: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$272: T.class_of(C19) = alias <C C19>
    <statTemp>$268: Sorbet::Private::Static::Void = <cfgAlias>$270: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$272: T.class_of(C19))
    <cfgAlias>$275: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$277: T.class_of(C19) = alias <C C19>
    <statTemp>$273: Sorbet::Private::Static::Void = <cfgAlias>$275: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$277: T.class_of(C19))
    <cfgAlias>$281: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$283: T.class_of(C20) = alias <C C20>
    <statTemp>$279: Sorbet::Private::Static::Void = <cfgAlias>$281: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$283: T.class_of(C20))
    <cfgAlias>$286: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$288: T.class_of(C20) = alias <C C20>
    <statTemp>$284: Sorbet::Private::Static::Void = <cfgAlias>$286: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$288: T.class_of(C20))
    <cfgAlias>$292: T.class_of(<Magic>) = alias <C <Magic>>
    <cfgAlias>$294: T.class_of(A) = alias <C A>
    <statTemp>$290: Sorbet::Private::Static::Void = <cfgAlias>$292: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$294: T.class_of(A))
    <cfgAlias>$297: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$299: T.class_of(A) = alias <C A>
    <statTemp>$295: Sorbet::Private::Static::Void = <cfgAlias>$297: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$299: T.class_of(A))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C1>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C1) = cast(<self>: NilClass, T.class_of(C1));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C2>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C2) = cast(<self>: NilClass, T.class_of(C2));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C3>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C3) = cast(<self>: NilClass, T.class_of(C3));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C4>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C4) = cast(<self>: NilClass, T.class_of(C4));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C5>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C5) = cast(<self>: NilClass, T.class_of(C5));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C6>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C6) = cast(<self>: NilClass, T.class_of(C6));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C7>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C7) = cast(<self>: NilClass, T.class_of(C7));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C8>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C8) = cast(<self>: NilClass, T.class_of(C8));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C9>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C9) = cast(<self>: NilClass, T.class_of(C9));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C10>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C10) = cast(<self>: NilClass, T.class_of(C10));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C11>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C11) = cast(<self>: NilClass, T.class_of(C11));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C12>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C12) = cast(<self>: NilClass, T.class_of(C12));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C13>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C13) = cast(<self>: NilClass, T.class_of(C13));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C13>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C13) = cast(<self>: NilClass, T.class_of(C13));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C13>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C13) = cast(<self>: NilClass, T.class_of(C13));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C13>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C13) = cast(<self>: NilClass, T.class_of(C13));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C13>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C13) = cast(<self>: NilClass, T.class_of(C13));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C13>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C13) = cast(<self>: NilClass, T.class_of(C13));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C13>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C13) = cast(<self>: NilClass, T.class_of(C13));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C14>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C14) = cast(<self>: NilClass, T.class_of(C14));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C15>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C15) = cast(<self>: NilClass, T.class_of(C15));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C16>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C16) = cast(<self>: NilClass, T.class_of(C16));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C17>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C17) = cast(<self>: NilClass, T.class_of(C17));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C18>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C18) = cast(<self>: NilClass, T.class_of(C18));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C19>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C19) = cast(<self>: NilClass, T.class_of(C19));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C20>#<static-init> {

bb0[rubyBlockId=0, firstDead=2]():
    <self>: T.class_of(C20) = cast(<self>: NilClass, T.class_of(C20));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:A>#send_beta_invitation {

bb0[rubyBlockId=0, firstDead=-1]():
    <self>: T.class_of(A) = cast(<self>: NilClass, T.class_of(A));
    invite: T.untyped = load_arg(invite)
    <statTemp>$6: Integer(1) = 1
    <ifTemp>$5: T::Boolean = <statTemp>$6: Integer(1).===(invite: T.untyped)
    <ifTemp>$5 -> (T::Boolean ? bb2 : bb3)

# backedges
# - bb61(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1](<returnMethodTemp>$2):
    <finalReturn> = return <returnMethodTemp>$2
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb2[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$8: T.class_of(C1) = alias <C C1>
    r: T.class_of(C1) = <cfgAlias>$8
    <unconditional> -> bb61

# backedges
# - bb0(rubyBlockId=0)
bb3[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$10: Integer(2) = 2
    <ifTemp>$9: T::Boolean = <statTemp>$10: Integer(2).===(invite: T.untyped)
    <ifTemp>$9 -> (T::Boolean ? bb4 : bb5)

# backedges
# - bb3(rubyBlockId=0)
bb4[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$12: T.class_of(C2) = alias <C C2>
    r: T.class_of(C2) = <cfgAlias>$12
    <unconditional> -> bb61

# backedges
# - bb3(rubyBlockId=0)
bb5[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$14: Integer(3) = 3
    <ifTemp>$13: T::Boolean = <statTemp>$14: Integer(3).===(invite: T.untyped)
    <ifTemp>$13 -> (T::Boolean ? bb6 : bb7)

# backedges
# - bb5(rubyBlockId=0)
bb6[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$16: T.class_of(C3) = alias <C C3>
    r: T.class_of(C3) = <cfgAlias>$16
    <unconditional> -> bb61

# backedges
# - bb5(rubyBlockId=0)
bb7[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$18: Integer(4) = 4
    <ifTemp>$17: T::Boolean = <statTemp>$18: Integer(4).===(invite: T.untyped)
    <ifTemp>$17 -> (T::Boolean ? bb8 : bb9)

# backedges
# - bb7(rubyBlockId=0)
bb8[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$20: T.class_of(C4) = alias <C C4>
    r: T.class_of(C4) = <cfgAlias>$20
    <unconditional> -> bb61

# backedges
# - bb7(rubyBlockId=0)
bb9[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$22: Integer(5) = 5
    <ifTemp>$21: T::Boolean = <statTemp>$22: Integer(5).===(invite: T.untyped)
    <ifTemp>$21 -> (T::Boolean ? bb10 : bb11)

# backedges
# - bb9(rubyBlockId=0)
bb10[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$24: T.class_of(C5) = alias <C C5>
    r: T.class_of(C5) = <cfgAlias>$24
    <unconditional> -> bb61

# backedges
# - bb9(rubyBlockId=0)
bb11[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$26: Integer(6) = 6
    <ifTemp>$25: T::Boolean = <statTemp>$26: Integer(6).===(invite: T.untyped)
    <ifTemp>$25 -> (T::Boolean ? bb12 : bb13)

# backedges
# - bb11(rubyBlockId=0)
bb12[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$28: T.class_of(C6) = alias <C C6>
    r: T.class_of(C6) = <cfgAlias>$28
    <unconditional> -> bb61

# backedges
# - bb11(rubyBlockId=0)
bb13[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$30: Integer(7) = 7
    <ifTemp>$29: T::Boolean = <statTemp>$30: Integer(7).===(invite: T.untyped)
    <ifTemp>$29 -> (T::Boolean ? bb14 : bb15)

# backedges
# - bb13(rubyBlockId=0)
bb14[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$32: T.class_of(C7) = alias <C C7>
    r: T.class_of(C7) = <cfgAlias>$32
    <unconditional> -> bb61

# backedges
# - bb13(rubyBlockId=0)
bb15[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$34: Integer(8) = 8
    <ifTemp>$33: T::Boolean = <statTemp>$34: Integer(8).===(invite: T.untyped)
    <ifTemp>$33 -> (T::Boolean ? bb16 : bb17)

# backedges
# - bb15(rubyBlockId=0)
bb16[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$36: T.class_of(C8) = alias <C C8>
    r: T.class_of(C8) = <cfgAlias>$36
    <unconditional> -> bb61

# backedges
# - bb15(rubyBlockId=0)
bb17[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$38: Integer(9) = 9
    <ifTemp>$37: T::Boolean = <statTemp>$38: Integer(9).===(invite: T.untyped)
    <ifTemp>$37 -> (T::Boolean ? bb18 : bb19)

# backedges
# - bb17(rubyBlockId=0)
bb18[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$40: T.class_of(C9) = alias <C C9>
    r: T.class_of(C9) = <cfgAlias>$40
    <unconditional> -> bb61

# backedges
# - bb17(rubyBlockId=0)
bb19[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$42: Integer(10) = 10
    <ifTemp>$41: T::Boolean = <statTemp>$42: Integer(10).===(invite: T.untyped)
    <ifTemp>$41 -> (T::Boolean ? bb20 : bb21)

# backedges
# - bb19(rubyBlockId=0)
bb20[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$44: T.class_of(C10) = alias <C C10>
    r: T.class_of(C10) = <cfgAlias>$44
    <unconditional> -> bb61

# backedges
# - bb19(rubyBlockId=0)
bb21[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$46: Integer(11) = 11
    <ifTemp>$45: T::Boolean = <statTemp>$46: Integer(11).===(invite: T.untyped)
    <ifTemp>$45 -> (T::Boolean ? bb22 : bb23)

# backedges
# - bb21(rubyBlockId=0)
bb22[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$48: T.class_of(C11) = alias <C C11>
    r: T.class_of(C11) = <cfgAlias>$48
    <unconditional> -> bb61

# backedges
# - bb21(rubyBlockId=0)
bb23[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$50: Integer(12) = 12
    <ifTemp>$49: T::Boolean = <statTemp>$50: Integer(12).===(invite: T.untyped)
    <ifTemp>$49 -> (T::Boolean ? bb24 : bb25)

# backedges
# - bb23(rubyBlockId=0)
bb24[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$52: T.class_of(C12) = alias <C C12>
    r: T.class_of(C12) = <cfgAlias>$52
    <unconditional> -> bb61

# backedges
# - bb23(rubyBlockId=0)
bb25[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$54: Integer(13) = 13
    <ifTemp>$53: T::Boolean = <statTemp>$54: Integer(13).===(invite: T.untyped)
    <ifTemp>$53 -> (T::Boolean ? bb26 : bb27)

# backedges
# - bb25(rubyBlockId=0)
bb26[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$56: T.class_of(C13) = alias <C C13>
    r: T.class_of(C13) = <cfgAlias>$56
    <unconditional> -> bb61

# backedges
# - bb25(rubyBlockId=0)
bb27[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$58: Integer(14) = 14
    <ifTemp>$57: T::Boolean = <statTemp>$58: Integer(14).===(invite: T.untyped)
    <ifTemp>$57 -> (T::Boolean ? bb28 : bb29)

# backedges
# - bb27(rubyBlockId=0)
bb28[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$60: T.class_of(C14) = alias <C C14>
    r: T.class_of(C14) = <cfgAlias>$60
    <unconditional> -> bb61

# backedges
# - bb27(rubyBlockId=0)
bb29[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$62: Integer(15) = 15
    <ifTemp>$61: T::Boolean = <statTemp>$62: Integer(15).===(invite: T.untyped)
    <ifTemp>$61 -> (T::Boolean ? bb30 : bb31)

# backedges
# - bb29(rubyBlockId=0)
bb30[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$64: T.class_of(C15) = alias <C C15>
    r: T.class_of(C15) = <cfgAlias>$64
    <unconditional> -> bb61

# backedges
# - bb29(rubyBlockId=0)
bb31[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$66: Integer(16) = 16
    <ifTemp>$65: T::Boolean = <statTemp>$66: Integer(16).===(invite: T.untyped)
    <ifTemp>$65 -> (T::Boolean ? bb32 : bb33)

# backedges
# - bb31(rubyBlockId=0)
bb32[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$68: T.class_of(C16) = alias <C C16>
    r: T.class_of(C16) = <cfgAlias>$68
    <unconditional> -> bb61

# backedges
# - bb31(rubyBlockId=0)
bb33[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$70: Integer(17) = 17
    <ifTemp>$69: T::Boolean = <statTemp>$70: Integer(17).===(invite: T.untyped)
    <ifTemp>$69 -> (T::Boolean ? bb34 : bb35)

# backedges
# - bb33(rubyBlockId=0)
bb34[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$72: T.class_of(C17) = alias <C C17>
    r: T.class_of(C17) = <cfgAlias>$72
    <unconditional> -> bb61

# backedges
# - bb33(rubyBlockId=0)
bb35[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$74: Integer(18) = 18
    <ifTemp>$73: T::Boolean = <statTemp>$74: Integer(18).===(invite: T.untyped)
    <ifTemp>$73 -> (T::Boolean ? bb36 : bb37)

# backedges
# - bb35(rubyBlockId=0)
bb36[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$76: T.class_of(C18) = alias <C C18>
    r: T.class_of(C18) = <cfgAlias>$76
    <unconditional> -> bb61

# backedges
# - bb35(rubyBlockId=0)
bb37[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$78: Integer(19) = 19
    <ifTemp>$77: T::Boolean = <statTemp>$78: Integer(19).===(invite: T.untyped)
    <ifTemp>$77 -> (T::Boolean ? bb38 : bb39)

# backedges
# - bb37(rubyBlockId=0)
bb38[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$80: T.class_of(C19) = alias <C C19>
    r: T.class_of(C19) = <cfgAlias>$80
    <unconditional> -> bb61

# backedges
# - bb37(rubyBlockId=0)
bb39[rubyBlockId=0, firstDead=-1](<self>: T.class_of(A), invite: T.untyped):
    <statTemp>$82: Integer(20) = 20
    <ifTemp>$81: T::Boolean = <statTemp>$82: Integer(20).===(invite: T.untyped)
    <ifTemp>$81 -> (T::Boolean ? bb40 : bb41)

# backedges
# - bb39(rubyBlockId=0)
bb40[rubyBlockId=0, firstDead=-1]():
    <cfgAlias>$84: T.class_of(C20) = alias <C C20>
    r: T.class_of(C20) = <cfgAlias>$84
    <unconditional> -> bb61

# backedges
# - bb39(rubyBlockId=0)
bb41[rubyBlockId=0, firstDead=2](<self>: T.class_of(A)):
    <statTemp>$86: String("Bla bla bla") = "Bla bla bla"
    <statTemp>$3: T.noreturn = <self>: T.class_of(A).raise(<statTemp>$86: String("Bla bla bla"))
    <unconditional> -> bb61

# backedges
# - bb2(rubyBlockId=0)
# - bb4(rubyBlockId=0)
# - bb6(rubyBlockId=0)
# - bb8(rubyBlockId=0)
# - bb10(rubyBlockId=0)
# - bb12(rubyBlockId=0)
# - bb14(rubyBlockId=0)
# - bb16(rubyBlockId=0)
# - bb18(rubyBlockId=0)
# - bb20(rubyBlockId=0)
# - bb22(rubyBlockId=0)
# - bb24(rubyBlockId=0)
# - bb26(rubyBlockId=0)
# - bb28(rubyBlockId=0)
# - bb30(rubyBlockId=0)
# - bb32(rubyBlockId=0)
# - bb34(rubyBlockId=0)
# - bb36(rubyBlockId=0)
# - bb38(rubyBlockId=0)
# - bb40(rubyBlockId=0)
# - bb41(rubyBlockId=0)
bb61[rubyBlockId=0, firstDead=2](r: T.any(T.class_of(C1), T.class_of(C2), T.class_of(C3), T.class_of(C4), T.class_of(C5), T.class_of(C6), T.class_of(C7), T.class_of(C8), T.class_of(C9), T.class_of(C10), T.class_of(C11), T.class_of(C12), T.class_of(C13), T.class_of(C14), T.class_of(C15), T.class_of(C16), T.class_of(C17), T.class_of(C18), T.class_of(C19), T.class_of(C20))):
    s: T.any(T.class_of(C1), T.class_of(C2), T.class_of(C3), T.class_of(C4), T.class_of(C5), T.class_of(C6), T.class_of(C7), T.class_of(C8), T.class_of(C9), T.class_of(C10), T.class_of(C11), T.class_of(C12), T.class_of(C13), T.class_of(C14), T.class_of(C15), T.class_of(C16), T.class_of(C17), T.class_of(C18), T.class_of(C19), T.class_of(C20)) = r
    <returnMethodTemp>$2: T.noreturn = return s: T.any(T.class_of(C1), T.class_of(C2), T.class_of(C3), T.class_of(C4), T.class_of(C5), T.class_of(C6), T.class_of(C7), T.class_of(C8), T.class_of(C9), T.class_of(C10), T.class_of(C11), T.class_of(C12), T.class_of(C13), T.class_of(C14), T.class_of(C15), T.class_of(C16), T.class_of(C17), T.class_of(C18), T.class_of(C19), T.class_of(C20))
    <unconditional> -> bb1

}

method ::<Class:A>#<static-init> {

bb0[rubyBlockId=0, firstDead=6]():
    <self>: T.class_of(A) = cast(<self>: NilClass, T.class_of(A));
    <cfgAlias>$4: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <statTemp>$6: Symbol(:send_beta_invitation) = :send_beta_invitation
    <statTemp>$7: Symbol(:normal) = :normal
    <returnMethodTemp>$2: Symbol(:send_beta_invitation) = <cfgAlias>$4: T.class_of(Sorbet::Private::Static).keep_self_def(<self>: T.class_of(A), <statTemp>$6: Symbol(:send_beta_invitation), <statTemp>$7: Symbol(:normal))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:send_beta_invitation)
    <unconditional> -> bb1

# backedges
# - bb0(rubyBlockId=0)
bb1[rubyBlockId=0, firstDead=-1]():
    <unconditional> -> bb1

}

