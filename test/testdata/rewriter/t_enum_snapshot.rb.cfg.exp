digraph "t_enum_snapshot.rb" {
subgraph "cluster_::<Class:<root>>#<static-init>" {
    label = "::<Class:<root>>#<static-init>";
    color = blue;

    "bb::<Class:<root>>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U <root>>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<cfgAlias>$6: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$8: T.class_of(MyEnum) = alias <C MyEnum>\l<statTemp>$4: Sorbet::Private::Static::Void = <cfgAlias>$6: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$8: T.class_of(MyEnum))\l<cfgAlias>$11: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$13: T.class_of(MyEnum) = alias <C MyEnum>\l<statTemp>$9: Sorbet::Private::Static::Void = <cfgAlias>$11: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$13: T.class_of(MyEnum))\l<cfgAlias>$16: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$18: T.class_of(T::Enum) = alias <C Enum>\l<cfgAlias>$20: T.class_of(T) = alias <C T>\l<statTemp>$14: Sorbet::Private::Static::Void = <cfgAlias>$16: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$18: T.class_of(T::Enum))\l<cfgAlias>$24: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$26: T.class_of(NotAnEnum) = alias <C NotAnEnum>\l<statTemp>$22: Sorbet::Private::Static::Void = <cfgAlias>$24: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$26: T.class_of(NotAnEnum))\l<cfgAlias>$29: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$31: T.class_of(NotAnEnum) = alias <C NotAnEnum>\l<statTemp>$27: Sorbet::Private::Static::Void = <cfgAlias>$29: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$31: T.class_of(NotAnEnum))\l<cfgAlias>$35: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$37: T.class_of(EnumsDoEnum) = alias <C EnumsDoEnum>\l<statTemp>$33: Sorbet::Private::Static::Void = <cfgAlias>$35: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$37: T.class_of(EnumsDoEnum))\l<cfgAlias>$40: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$42: T.class_of(EnumsDoEnum) = alias <C EnumsDoEnum>\l<statTemp>$38: Sorbet::Private::Static::Void = <cfgAlias>$40: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$42: T.class_of(EnumsDoEnum))\l<cfgAlias>$45: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$47: T.class_of(T::Enum) = alias <C Enum>\l<cfgAlias>$49: T.class_of(T) = alias <C T>\l<statTemp>$43: Sorbet::Private::Static::Void = <cfgAlias>$45: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$47: T.class_of(T::Enum))\l<cfgAlias>$53: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$55: T.class_of(BadConsts) = alias <C BadConsts>\l<statTemp>$51: Sorbet::Private::Static::Void = <cfgAlias>$53: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$55: T.class_of(BadConsts))\l<cfgAlias>$58: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$60: T.class_of(BadConsts) = alias <C BadConsts>\l<statTemp>$56: Sorbet::Private::Static::Void = <cfgAlias>$58: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$60: T.class_of(BadConsts))\l<cfgAlias>$63: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$65: T.class_of(T::Enum) = alias <C Enum>\l<cfgAlias>$67: T.class_of(T) = alias <C T>\l<statTemp>$61: Sorbet::Private::Static::Void = <cfgAlias>$63: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$65: T.class_of(T::Enum))\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_0" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
    "bb::<Class:<root>>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_1" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::<Class:MyEnum>#<static-init>" {
    label = "::<Class:MyEnum>#<static-init>";
    color = blue;

    "bb::<Class:MyEnum>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<C X>$34: MyEnum::X = alias <C X>\l<C Y>$60: MyEnum::Y = alias <C Y>\l<C Z>$87: MyEnum::Z = alias <C Z>\l<self>: T.class_of(MyEnum) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U MyEnum>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U MyEnum>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<cfgAlias>$6: T.class_of(T::Helpers) = alias <C Helpers>\l<statTemp>$3: T.class_of(MyEnum) = <self>: T.class_of(MyEnum).extend(<cfgAlias>$6: T.class_of(T::Helpers))\l<statTemp>$7: Sorbet::Private::Static::Void = <self>: T.class_of(MyEnum).abstract!()\l<statTemp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(MyEnum).sealed!()\l<block-pre-call-temp>$13: Sorbet::Private::Static::Void = <self>: T.class_of(MyEnum).enums()\l<selfRestore>$14: T.class_of(MyEnum) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:MyEnum>#<static-init>_0" -> "bb::<Class:MyEnum>#<static-init>_2" [style="bold"];
    "bb::<Class:MyEnum>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::<Class:MyEnum>#<static-init>_1" -> "bb::<Class:MyEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:MyEnum>#<static-init>_2" [
        shape = rectangle;
        color = black;
        label = "block[id=2, rubyBlockId=1](<self>: T.class_of(MyEnum), <block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(MyEnum), <C X>$34: MyEnum::X, <C Y>$60: MyEnum::Y, <C Z>$87: MyEnum::Z)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:MyEnum>#<static-init>_2" -> "bb::<Class:MyEnum>#<static-init>_5" [style="bold"];
    "bb::<Class:MyEnum>#<static-init>_2" -> "bb::<Class:MyEnum>#<static-init>_3" [style="tapered"];

    "bb::<Class:MyEnum>#<static-init>_3" [
        shape = rectangle;
        color = black;
        label = "block[id=3, rubyBlockId=0](<block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(MyEnum))\l<statTemp>$11: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$13, enums>\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:MyEnum>#<static-init>_3" -> "bb::<Class:MyEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:MyEnum>#<static-init>_5" [
        shape = rectangle;
        color = black;
        label = "block[id=5, rubyBlockId=1](<self>: T.class_of(MyEnum), <block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(MyEnum), <C X>$34: MyEnum::X, <C Y>$60: MyEnum::Y, <C Z>$87: MyEnum::Z)\louterLoops: 1\l<self>: T.class_of(MyEnum) = loadSelf\l<cfgAlias>$20: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$22: T.class_of(MyEnum::X) = alias <C X$1>\l<statTemp>$18: Sorbet::Private::Static::Void = <cfgAlias>$20: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$22: T.class_of(MyEnum::X))\l<cfgAlias>$25: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$27: T.class_of(MyEnum::X) = alias <C X$1>\l<statTemp>$23: Sorbet::Private::Static::Void = <cfgAlias>$25: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$27: T.class_of(MyEnum::X))\l<cfgAlias>$30: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$32: T.class_of(MyEnum) = alias <C MyEnum>\l<statTemp>$28: Sorbet::Private::Static::Void = <cfgAlias>$30: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$32: T.class_of(MyEnum))\l<cfgAlias>$37: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$39: T.class_of(MyEnum::X) = alias <C X$1>\l<statTemp>$35: Sorbet::Private::Static::Void = <cfgAlias>$37: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$39: T.class_of(MyEnum::X))\l<cfgAlias>$42: T.class_of(MyEnum::X) = alias <C X$1>\l<castTemp>$40: MyEnum::X = <cfgAlias>$42: T.class_of(MyEnum::X).new()\l<C X>$34: MyEnum::X = <castTemp>$40\l<cfgAlias>$46: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$48: T.class_of(MyEnum::Y) = alias <C Y$1>\l<statTemp>$44: Sorbet::Private::Static::Void = <cfgAlias>$46: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$48: T.class_of(MyEnum::Y))\l<cfgAlias>$51: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$53: T.class_of(MyEnum::Y) = alias <C Y$1>\l<statTemp>$49: Sorbet::Private::Static::Void = <cfgAlias>$51: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$53: T.class_of(MyEnum::Y))\l<cfgAlias>$56: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$58: T.class_of(MyEnum) = alias <C MyEnum>\l<statTemp>$54: Sorbet::Private::Static::Void = <cfgAlias>$56: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$58: T.class_of(MyEnum))\l<cfgAlias>$63: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$65: T.class_of(MyEnum::Y) = alias <C Y$1>\l<statTemp>$61: Sorbet::Private::Static::Void = <cfgAlias>$63: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$65: T.class_of(MyEnum::Y))\l<cfgAlias>$68: T.class_of(MyEnum::Y) = alias <C Y$1>\l<statTemp>$69: String(\"y\") = \"y\"\l<castTemp>$66: MyEnum::Y = <cfgAlias>$68: T.class_of(MyEnum::Y).new(<statTemp>$69: String(\"y\"))\l<C Y>$60: MyEnum::Y = <castTemp>$66\l<cfgAlias>$73: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$75: T.class_of(MyEnum::Z) = alias <C Z$1>\l<statTemp>$71: Sorbet::Private::Static::Void = <cfgAlias>$73: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$75: T.class_of(MyEnum::Z))\l<cfgAlias>$78: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$80: T.class_of(MyEnum::Z) = alias <C Z$1>\l<statTemp>$76: Sorbet::Private::Static::Void = <cfgAlias>$78: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$80: T.class_of(MyEnum::Z))\l<cfgAlias>$83: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$85: T.class_of(MyEnum) = alias <C MyEnum>\l<statTemp>$81: Sorbet::Private::Static::Void = <cfgAlias>$83: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$85: T.class_of(MyEnum))\l<cfgAlias>$90: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$92: T.class_of(MyEnum::Z) = alias <C Z$1>\l<statTemp>$88: Sorbet::Private::Static::Void = <cfgAlias>$90: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$92: T.class_of(MyEnum::Z))\l<cfgAlias>$95: T.class_of(MyEnum::Z) = alias <C Z$1>\l<castTemp>$93: MyEnum::Z = <cfgAlias>$95: T.class_of(MyEnum::Z).new(<self>: T.class_of(MyEnum))\l<C Z>$87: MyEnum::Z = <castTemp>$93\l<blockReturnTemp>$16: NilClass = nil\l<blockReturnTemp>$97: T.noreturn = blockreturn<enums> <blockReturnTemp>$16: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:MyEnum>#<static-init>_5" -> "bb::<Class:MyEnum>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::MyEnum::<Class:X>#<static-init>" {
    label = "::MyEnum::<Class:X>#<static-init>";
    color = blue;

    "bb::MyEnum::<Class:X>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(MyEnum::X) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U MyEnum>><S <C <E <C <U X>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U MyEnum>><S <C <E <C <U X>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:X>#<static-init>_0" -> "bb::MyEnum::<Class:X>#<static-init>_1" [style="bold"];
    "bb::MyEnum::<Class:X>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:X>#<static-init>_1" -> "bb::MyEnum::<Class:X>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::MyEnum::<Class:Y>#<static-init>" {
    label = "::MyEnum::<Class:Y>#<static-init>";
    color = blue;

    "bb::MyEnum::<Class:Y>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(MyEnum::Y) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U MyEnum>><S <C <E <C <U Y>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U MyEnum>><S <C <E <C <U Y>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:Y>#<static-init>_0" -> "bb::MyEnum::<Class:Y>#<static-init>_1" [style="bold"];
    "bb::MyEnum::<Class:Y>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:Y>#<static-init>_1" -> "bb::MyEnum::<Class:Y>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::MyEnum::<Class:Z>#<static-init>" {
    label = "::MyEnum::<Class:Z>#<static-init>";
    color = blue;

    "bb::MyEnum::<Class:Z>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(MyEnum::Z) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U MyEnum>><S <C <E <C <U Z>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U MyEnum>><S <C <E <C <U Z>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:Z>#<static-init>_0" -> "bb::MyEnum::<Class:Z>#<static-init>_1" [style="bold"];
    "bb::MyEnum::<Class:Z>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::MyEnum::<Class:Z>#<static-init>_1" -> "bb::MyEnum::<Class:Z>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::<Class:NotAnEnum>#<static-init>" {
    label = "::<Class:NotAnEnum>#<static-init>";
    color = blue;

    "bb::<Class:NotAnEnum>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<C X>$9: T.untyped = alias <C X>\l<C Y>$16: NotAnEnum = alias <C Y>\l<self>: T.class_of(NotAnEnum) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U NotAnEnum>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U NotAnEnum>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<block-pre-call-temp>$4: Sorbet::Private::Static::Void = <self>: T.class_of(NotAnEnum).enums()\l<selfRestore>$5: T.class_of(NotAnEnum) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:NotAnEnum>#<static-init>_0" -> "bb::<Class:NotAnEnum>#<static-init>_2" [style="bold"];
    "bb::<Class:NotAnEnum>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::<Class:NotAnEnum>#<static-init>_1" -> "bb::<Class:NotAnEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:NotAnEnum>#<static-init>_2" [
        shape = rectangle;
        color = black;
        label = "block[id=2, rubyBlockId=1](<self>: T.class_of(NotAnEnum), <block-pre-call-temp>$4: Sorbet::Private::Static::Void, <selfRestore>$5: T.class_of(NotAnEnum), <C X>$9: T.untyped, <C Y>$16: NotAnEnum)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:NotAnEnum>#<static-init>_2" -> "bb::<Class:NotAnEnum>#<static-init>_5" [style="bold"];
    "bb::<Class:NotAnEnum>#<static-init>_2" -> "bb::<Class:NotAnEnum>#<static-init>_3" [style="tapered"];

    "bb::<Class:NotAnEnum>#<static-init>_3" [
        shape = rectangle;
        color = black;
        label = "block[id=3, rubyBlockId=0](<block-pre-call-temp>$4: Sorbet::Private::Static::Void, <selfRestore>$5: T.class_of(NotAnEnum))\l<returnMethodTemp>$2: T.untyped = Solve<<block-pre-call-temp>$4, enums>\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:NotAnEnum>#<static-init>_3" -> "bb::<Class:NotAnEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:NotAnEnum>#<static-init>_5" [
        shape = rectangle;
        color = black;
        label = "block[id=5, rubyBlockId=1](<self>: T.class_of(NotAnEnum), <block-pre-call-temp>$4: Sorbet::Private::Static::Void, <selfRestore>$5: T.class_of(NotAnEnum), <C X>$9: T.untyped, <C Y>$16: NotAnEnum)\louterLoops: 1\l<self>: T.class_of(NotAnEnum) = loadSelf\l<cfgAlias>$11: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$14: T.class_of(<Magic>) = alias <C <Magic>>\l<statTemp>$12: T.attached_class (of NotAnEnum) = <cfgAlias>$14: T.class_of(<Magic>).<self-new>(<self>: T.class_of(NotAnEnum))\l<C X>$9: T.attached_class (of NotAnEnum) = <cfgAlias>$11: T.class_of(<Magic>).<suggest-type>(<statTemp>$12: T.attached_class (of NotAnEnum))\l<cfgAlias>$19: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<statTemp>$17: Sorbet::Private::Static::Void = <cfgAlias>$19: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<self>: T.class_of(NotAnEnum))\l<cfgAlias>$23: T.class_of(<Magic>) = alias <C <Magic>>\l<castTemp>$21: T.attached_class (of NotAnEnum) = <cfgAlias>$23: T.class_of(<Magic>).<self-new>(<self>: T.class_of(NotAnEnum))\l<C Y>$16: NotAnEnum = cast(<castTemp>$21: T.attached_class (of NotAnEnum), NotAnEnum);\l<blockReturnTemp>$7: NotAnEnum = <C Y>$16\l<blockReturnTemp>$25: T.noreturn = blockreturn<enums> <blockReturnTemp>$7: NotAnEnum\l<unconditional>\l"
    ];

    "bb::<Class:NotAnEnum>#<static-init>_5" -> "bb::<Class:NotAnEnum>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::EnumsDoEnum#something_outside" {
    label = "::EnumsDoEnum#something_outside";
    color = blue;

    "bb::EnumsDoEnum#something_outside_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: EnumsDoEnum = cast(<self>: NilClass, EnumsDoEnum);\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum#something_outside_0" -> "bb::EnumsDoEnum#something_outside_1" [style="bold"];
    "bb::EnumsDoEnum#something_outside_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum#something_outside_1" -> "bb::EnumsDoEnum#something_outside_1" [style="bold"];
}

subgraph "cluster_::<Class:EnumsDoEnum>#<static-init>" {
    label = "::<Class:EnumsDoEnum>#<static-init>";
    color = blue;

    "bb::<Class:EnumsDoEnum>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<C X>$34: EnumsDoEnum::X = alias <C X>\l<C Y>$60: EnumsDoEnum::Y = alias <C Y>\l<C Z>$87: EnumsDoEnum::Z = alias <C Z>\l<self>: T.class_of(EnumsDoEnum) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U EnumsDoEnum>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U EnumsDoEnum>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<cfgAlias>$6: T.class_of(T::Helpers) = alias <C Helpers>\l<statTemp>$3: T.class_of(EnumsDoEnum) = <self>: T.class_of(EnumsDoEnum).extend(<cfgAlias>$6: T.class_of(T::Helpers))\l<statTemp>$7: Sorbet::Private::Static::Void = <self>: T.class_of(EnumsDoEnum).abstract!()\l<statTemp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(EnumsDoEnum).sealed!()\l<block-pre-call-temp>$13: Sorbet::Private::Static::Void = <self>: T.class_of(EnumsDoEnum).enums()\l<selfRestore>$14: T.class_of(EnumsDoEnum) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:EnumsDoEnum>#<static-init>_0" -> "bb::<Class:EnumsDoEnum>#<static-init>_2" [style="bold"];
    "bb::<Class:EnumsDoEnum>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::<Class:EnumsDoEnum>#<static-init>_1" -> "bb::<Class:EnumsDoEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:EnumsDoEnum>#<static-init>_2" [
        shape = rectangle;
        color = black;
        label = "block[id=2, rubyBlockId=1](<self>: T.class_of(EnumsDoEnum), <block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(EnumsDoEnum), <C X>$34: EnumsDoEnum::X, <C Y>$60: EnumsDoEnum::Y, <C Z>$87: EnumsDoEnum::Z)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:EnumsDoEnum>#<static-init>_2" -> "bb::<Class:EnumsDoEnum>#<static-init>_5" [style="bold"];
    "bb::<Class:EnumsDoEnum>#<static-init>_2" -> "bb::<Class:EnumsDoEnum>#<static-init>_3" [style="tapered"];

    "bb::<Class:EnumsDoEnum>#<static-init>_3" [
        shape = rectangle;
        color = black;
        label = "block[id=3, rubyBlockId=0](<block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(EnumsDoEnum))\l<statTemp>$11: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$13, enums>\l<self>: T.class_of(EnumsDoEnum) = <selfRestore>$14\l<cfgAlias>$100: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<statTemp>$102: Symbol(:something_outside) = :something_outside\l<statTemp>$103: Symbol(:normal) = :normal\l<statTemp>$98: Symbol(:something_outside) = <cfgAlias>$100: T.class_of(Sorbet::Private::Static).keep_def(<self>: T.class_of(EnumsDoEnum), <statTemp>$102: Symbol(:something_outside), <statTemp>$103: Symbol(:normal))\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:EnumsDoEnum>#<static-init>_3" -> "bb::<Class:EnumsDoEnum>#<static-init>_1" [style="bold"];
    "bb::<Class:EnumsDoEnum>#<static-init>_5" [
        shape = rectangle;
        color = black;
        label = "block[id=5, rubyBlockId=1](<self>: T.class_of(EnumsDoEnum), <block-pre-call-temp>$13: Sorbet::Private::Static::Void, <selfRestore>$14: T.class_of(EnumsDoEnum), <C X>$34: EnumsDoEnum::X, <C Y>$60: EnumsDoEnum::Y, <C Z>$87: EnumsDoEnum::Z)\louterLoops: 1\l<self>: T.class_of(EnumsDoEnum) = loadSelf\l<cfgAlias>$20: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$22: T.class_of(EnumsDoEnum::X) = alias <C X$1>\l<statTemp>$18: Sorbet::Private::Static::Void = <cfgAlias>$20: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$22: T.class_of(EnumsDoEnum::X))\l<cfgAlias>$25: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$27: T.class_of(EnumsDoEnum::X) = alias <C X$1>\l<statTemp>$23: Sorbet::Private::Static::Void = <cfgAlias>$25: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$27: T.class_of(EnumsDoEnum::X))\l<cfgAlias>$30: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$32: T.class_of(EnumsDoEnum) = alias <C EnumsDoEnum>\l<statTemp>$28: Sorbet::Private::Static::Void = <cfgAlias>$30: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$32: T.class_of(EnumsDoEnum))\l<cfgAlias>$37: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$39: T.class_of(EnumsDoEnum::X) = alias <C X$1>\l<statTemp>$35: Sorbet::Private::Static::Void = <cfgAlias>$37: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$39: T.class_of(EnumsDoEnum::X))\l<cfgAlias>$42: T.class_of(EnumsDoEnum::X) = alias <C X$1>\l<castTemp>$40: EnumsDoEnum::X = <cfgAlias>$42: T.class_of(EnumsDoEnum::X).new()\l<C X>$34: EnumsDoEnum::X = <castTemp>$40\l<cfgAlias>$46: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$48: T.class_of(EnumsDoEnum::Y) = alias <C Y$1>\l<statTemp>$44: Sorbet::Private::Static::Void = <cfgAlias>$46: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$48: T.class_of(EnumsDoEnum::Y))\l<cfgAlias>$51: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$53: T.class_of(EnumsDoEnum::Y) = alias <C Y$1>\l<statTemp>$49: Sorbet::Private::Static::Void = <cfgAlias>$51: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$53: T.class_of(EnumsDoEnum::Y))\l<cfgAlias>$56: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$58: T.class_of(EnumsDoEnum) = alias <C EnumsDoEnum>\l<statTemp>$54: Sorbet::Private::Static::Void = <cfgAlias>$56: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$58: T.class_of(EnumsDoEnum))\l<cfgAlias>$63: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$65: T.class_of(EnumsDoEnum::Y) = alias <C Y$1>\l<statTemp>$61: Sorbet::Private::Static::Void = <cfgAlias>$63: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$65: T.class_of(EnumsDoEnum::Y))\l<cfgAlias>$68: T.class_of(EnumsDoEnum::Y) = alias <C Y$1>\l<statTemp>$69: String(\"y\") = \"y\"\l<castTemp>$66: EnumsDoEnum::Y = <cfgAlias>$68: T.class_of(EnumsDoEnum::Y).new(<statTemp>$69: String(\"y\"))\l<C Y>$60: EnumsDoEnum::Y = <castTemp>$66\l<cfgAlias>$73: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$75: T.class_of(EnumsDoEnum::Z) = alias <C Z$1>\l<statTemp>$71: Sorbet::Private::Static::Void = <cfgAlias>$73: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$75: T.class_of(EnumsDoEnum::Z))\l<cfgAlias>$78: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$80: T.class_of(EnumsDoEnum::Z) = alias <C Z$1>\l<statTemp>$76: Sorbet::Private::Static::Void = <cfgAlias>$78: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$80: T.class_of(EnumsDoEnum::Z))\l<cfgAlias>$83: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$85: T.class_of(EnumsDoEnum) = alias <C EnumsDoEnum>\l<statTemp>$81: Sorbet::Private::Static::Void = <cfgAlias>$83: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$85: T.class_of(EnumsDoEnum))\l<cfgAlias>$90: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$92: T.class_of(EnumsDoEnum::Z) = alias <C Z$1>\l<statTemp>$88: Sorbet::Private::Static::Void = <cfgAlias>$90: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$92: T.class_of(EnumsDoEnum::Z))\l<cfgAlias>$95: T.class_of(EnumsDoEnum::Z) = alias <C Z$1>\l<castTemp>$93: EnumsDoEnum::Z = <cfgAlias>$95: T.class_of(EnumsDoEnum::Z).new(<self>: T.class_of(EnumsDoEnum))\l<C Z>$87: EnumsDoEnum::Z = <castTemp>$93\l<blockReturnTemp>$16: NilClass = nil\l<blockReturnTemp>$97: T.noreturn = blockreturn<enums> <blockReturnTemp>$16: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:EnumsDoEnum>#<static-init>_5" -> "bb::<Class:EnumsDoEnum>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::EnumsDoEnum::<Class:X>#<static-init>" {
    label = "::EnumsDoEnum::<Class:X>#<static-init>";
    color = blue;

    "bb::EnumsDoEnum::<Class:X>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(EnumsDoEnum::X) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U EnumsDoEnum>><S <C <E <C <U X>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U EnumsDoEnum>><S <C <E <C <U X>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:X>#<static-init>_0" -> "bb::EnumsDoEnum::<Class:X>#<static-init>_1" [style="bold"];
    "bb::EnumsDoEnum::<Class:X>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:X>#<static-init>_1" -> "bb::EnumsDoEnum::<Class:X>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::EnumsDoEnum::<Class:Y>#<static-init>" {
    label = "::EnumsDoEnum::<Class:Y>#<static-init>";
    color = blue;

    "bb::EnumsDoEnum::<Class:Y>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(EnumsDoEnum::Y) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U EnumsDoEnum>><S <C <E <C <U Y>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U EnumsDoEnum>><S <C <E <C <U Y>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:Y>#<static-init>_0" -> "bb::EnumsDoEnum::<Class:Y>#<static-init>_1" [style="bold"];
    "bb::EnumsDoEnum::<Class:Y>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:Y>#<static-init>_1" -> "bb::EnumsDoEnum::<Class:Y>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::EnumsDoEnum::<Class:Z>#<static-init>" {
    label = "::EnumsDoEnum::<Class:Z>#<static-init>";
    color = blue;

    "bb::EnumsDoEnum::<Class:Z>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(EnumsDoEnum::Z) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U EnumsDoEnum>><S <C <E <C <U Z>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U EnumsDoEnum>><S <C <E <C <U Z>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:Z>#<static-init>_0" -> "bb::EnumsDoEnum::<Class:Z>#<static-init>_1" [style="bold"];
    "bb::EnumsDoEnum::<Class:Z>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::EnumsDoEnum::<Class:Z>#<static-init>_1" -> "bb::EnumsDoEnum::<Class:Z>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::<Class:BadConsts>#<static-init>" {
    label = "::<Class:BadConsts>#<static-init>";
    color = blue;

    "bb::<Class:BadConsts>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<C Before>$28: BadConsts::Before = alias <C Before>\l<C StaticField1>$38: Integer(1) = alias <C StaticField1>\l<C Inside>$62: BadConsts::Inside = alias <C Inside>\l<C StaticField2>$72: Integer(2) = alias <C StaticField2>\l<C After>$91: BadConsts::After = alias <C After>\l<C StaticField3>$101: Integer(3) = alias <C StaticField3>\l<C StaticField4>$103: Integer = alias <C StaticField4>\l<self>: T.class_of(BadConsts) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U BadConsts>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U BadConsts>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<cfgAlias>$6: T.class_of(T::Helpers) = alias <C Helpers>\l<statTemp>$3: T.class_of(BadConsts) = <self>: T.class_of(BadConsts).extend(<cfgAlias>$6: T.class_of(T::Helpers))\l<statTemp>$7: Sorbet::Private::Static::Void = <self>: T.class_of(BadConsts).abstract!()\l<statTemp>$9: Sorbet::Private::Static::Void = <self>: T.class_of(BadConsts).sealed!()\l<cfgAlias>$14: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$16: T.class_of(BadConsts::Before) = alias <C Before$1>\l<statTemp>$12: Sorbet::Private::Static::Void = <cfgAlias>$14: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$16: T.class_of(BadConsts::Before))\l<cfgAlias>$19: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$21: T.class_of(BadConsts::Before) = alias <C Before$1>\l<statTemp>$17: Sorbet::Private::Static::Void = <cfgAlias>$19: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$21: T.class_of(BadConsts::Before))\l<cfgAlias>$24: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$26: T.class_of(BadConsts) = alias <C BadConsts>\l<statTemp>$22: Sorbet::Private::Static::Void = <cfgAlias>$24: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$26: T.class_of(BadConsts))\l<cfgAlias>$31: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$33: T.class_of(BadConsts::Before) = alias <C Before$1>\l<statTemp>$29: Sorbet::Private::Static::Void = <cfgAlias>$31: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$33: T.class_of(BadConsts::Before))\l<cfgAlias>$36: T.class_of(BadConsts::Before) = alias <C Before$1>\l<castTemp>$34: BadConsts::Before = <cfgAlias>$36: T.class_of(BadConsts::Before).new()\l<C Before>$28: BadConsts::Before = <castTemp>$34\l<C StaticField1>$38: Integer(1) = 1\l<block-pre-call-temp>$41: Sorbet::Private::Static::Void = <self>: T.class_of(BadConsts).enums()\l<selfRestore>$42: T.class_of(BadConsts) = <self>\l<unconditional>\l"
    ];

    "bb::<Class:BadConsts>#<static-init>_0" -> "bb::<Class:BadConsts>#<static-init>_2" [style="bold"];
    "bb::<Class:BadConsts>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::<Class:BadConsts>#<static-init>_1" -> "bb::<Class:BadConsts>#<static-init>_1" [style="bold"];
    "bb::<Class:BadConsts>#<static-init>_2" [
        shape = rectangle;
        color = black;
        label = "block[id=2, rubyBlockId=1](<self>: T.class_of(BadConsts), <block-pre-call-temp>$41: Sorbet::Private::Static::Void, <selfRestore>$42: T.class_of(BadConsts), <C Inside>$62: BadConsts::Inside, <C StaticField2>$72: Integer(2), <C After>$91: BadConsts::After, <C StaticField3>$101: Integer(3), <C StaticField4>$103: Integer)\louterLoops: 1\l<block-call>: NilClass\l"
    ];

    "bb::<Class:BadConsts>#<static-init>_2" -> "bb::<Class:BadConsts>#<static-init>_5" [style="bold"];
    "bb::<Class:BadConsts>#<static-init>_2" -> "bb::<Class:BadConsts>#<static-init>_3" [style="tapered"];

    "bb::<Class:BadConsts>#<static-init>_3" [
        shape = rectangle;
        color = black;
        label = "block[id=3, rubyBlockId=0](<block-pre-call-temp>$41: Sorbet::Private::Static::Void, <selfRestore>$42: T.class_of(BadConsts), <C After>$91: BadConsts::After, <C StaticField3>$101: Integer(3), <C StaticField4>$103: Integer)\l<statTemp>$39: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$41, enums>\l<cfgAlias>$77: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$79: T.class_of(BadConsts::After) = alias <C After$1>\l<statTemp>$75: Sorbet::Private::Static::Void = <cfgAlias>$77: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$79: T.class_of(BadConsts::After))\l<cfgAlias>$82: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$84: T.class_of(BadConsts::After) = alias <C After$1>\l<statTemp>$80: Sorbet::Private::Static::Void = <cfgAlias>$82: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$84: T.class_of(BadConsts::After))\l<cfgAlias>$87: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$89: T.class_of(BadConsts) = alias <C BadConsts>\l<statTemp>$85: Sorbet::Private::Static::Void = <cfgAlias>$87: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$89: T.class_of(BadConsts))\l<cfgAlias>$94: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$96: T.class_of(BadConsts::After) = alias <C After$1>\l<statTemp>$92: Sorbet::Private::Static::Void = <cfgAlias>$94: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$96: T.class_of(BadConsts::After))\l<cfgAlias>$99: T.class_of(BadConsts::After) = alias <C After$1>\l<castTemp>$97: BadConsts::After = <cfgAlias>$99: T.class_of(BadConsts::After).new()\l<C After>$91: BadConsts::After = <castTemp>$97\l<C StaticField3>$101: Integer(3) = 3\l<cfgAlias>$106: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$108: T.class_of(Integer) = alias <C Integer>\l<statTemp>$104: Sorbet::Private::Static::Void = <cfgAlias>$106: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$108: T.class_of(Integer))\l<castTemp>$109: Integer(1) = 1\l<C StaticField4>$103: Integer = cast(<castTemp>$109: Integer(1), Integer);\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:BadConsts>#<static-init>_3" -> "bb::<Class:BadConsts>#<static-init>_1" [style="bold"];
    "bb::<Class:BadConsts>#<static-init>_5" [
        shape = rectangle;
        color = black;
        label = "block[id=5, rubyBlockId=1](<self>: T.class_of(BadConsts), <block-pre-call-temp>$41: Sorbet::Private::Static::Void, <selfRestore>$42: T.class_of(BadConsts), <C Inside>$62: BadConsts::Inside, <C StaticField2>$72: Integer(2), <C After>$91: BadConsts::After, <C StaticField3>$101: Integer(3), <C StaticField4>$103: Integer)\louterLoops: 1\l<self>: T.class_of(BadConsts) = loadSelf\l<cfgAlias>$48: T.class_of(<Magic>) = alias <C <Magic>>\l<cfgAlias>$50: T.class_of(BadConsts::Inside) = alias <C Inside$1>\l<statTemp>$46: Sorbet::Private::Static::Void = <cfgAlias>$48: T.class_of(<Magic>).<define-top-class-or-module>(<cfgAlias>$50: T.class_of(BadConsts::Inside))\l<cfgAlias>$53: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$55: T.class_of(BadConsts::Inside) = alias <C Inside$1>\l<statTemp>$51: Sorbet::Private::Static::Void = <cfgAlias>$53: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$55: T.class_of(BadConsts::Inside))\l<cfgAlias>$58: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$60: T.class_of(BadConsts) = alias <C BadConsts>\l<statTemp>$56: Sorbet::Private::Static::Void = <cfgAlias>$58: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$60: T.class_of(BadConsts))\l<cfgAlias>$65: T.class_of(Sorbet::Private::Static) = alias <C Static>\l<cfgAlias>$67: T.class_of(BadConsts::Inside) = alias <C Inside$1>\l<statTemp>$63: Sorbet::Private::Static::Void = <cfgAlias>$65: T.class_of(Sorbet::Private::Static).keep_for_typechecking(<cfgAlias>$67: T.class_of(BadConsts::Inside))\l<cfgAlias>$70: T.class_of(BadConsts::Inside) = alias <C Inside$1>\l<castTemp>$68: BadConsts::Inside = <cfgAlias>$70: T.class_of(BadConsts::Inside).new()\l<C Inside>$62: BadConsts::Inside = <castTemp>$68\l<C StaticField2>$72: Integer(2) = 2\l<blockReturnTemp>$44: NilClass = nil\l<blockReturnTemp>$73: T.noreturn = blockreturn<enums> <blockReturnTemp>$44: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:BadConsts>#<static-init>_5" -> "bb::<Class:BadConsts>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::BadConsts::<Class:Before>#<static-init>" {
    label = "::BadConsts::<Class:Before>#<static-init>";
    color = blue;

    "bb::BadConsts::<Class:Before>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(BadConsts::Before) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U BadConsts>><S <C <E <C <U Before>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U BadConsts>><S <C <E <C <U Before>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:Before>#<static-init>_0" -> "bb::BadConsts::<Class:Before>#<static-init>_1" [style="bold"];
    "bb::BadConsts::<Class:Before>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:Before>#<static-init>_1" -> "bb::BadConsts::<Class:Before>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::BadConsts::<Class:Inside>#<static-init>" {
    label = "::BadConsts::<Class:Inside>#<static-init>";
    color = blue;

    "bb::BadConsts::<Class:Inside>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(BadConsts::Inside) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U BadConsts>><S <C <E <C <U Inside>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U BadConsts>><S <C <E <C <U Inside>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:Inside>#<static-init>_0" -> "bb::BadConsts::<Class:Inside>#<static-init>_1" [style="bold"];
    "bb::BadConsts::<Class:Inside>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:Inside>#<static-init>_1" -> "bb::BadConsts::<Class:Inside>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::BadConsts::<Class:After>#<static-init>" {
    label = "::BadConsts::<Class:After>#<static-init>";
    color = blue;

    "bb::BadConsts::<Class:After>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(BadConsts::After) = cast(<self>: NilClass, AppliedType {\l  klass = <C <U BadConsts>><S <C <E <C <U After>> $1>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<C <U BadConsts>><S <C <E <C <U After>> $1>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:After>#<static-init>_0" -> "bb::BadConsts::<Class:After>#<static-init>_1" [style="bold"];
    "bb::BadConsts::<Class:After>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0]()\l<unconditional>\l"
    ];

    "bb::BadConsts::<Class:After>#<static-init>_1" -> "bb::BadConsts::<Class:After>#<static-init>_1" [style="bold"];
}

}

