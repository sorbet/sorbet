class <emptyTree><<C <root>>> < (::<todo sym>)
  class <emptyTree>::<C ActiveSupport>::<C TestCase><<C <todo sym>>> < (::<todo sym>)
    ::Sorbet::Private::Static.sig(<self>) do ||
      <self>.params(:args, <emptyTree>::<C T>.untyped(), :block, <emptyTree>::<C T>.nilable(<emptyTree>::<C T>.proc().bind(<emptyTree>::<C T>.attached_class()).void())).void()
    end

    def self.test<<todo method>>(*args, &block)
      <emptyTree>
    end

    ::Sorbet::Private::Static.sig(<self>) do ||
      <self>.params(:test, <emptyTree>::<C T>.untyped()).returns(<emptyTree>::<C T>::<C Boolean>)
    end

    def assert<<todo method>>(test, &<blk>)
      if test
        true
      else
        false
      end
    end

    <self>.extend(<emptyTree>::<C T>::<C Sig>)

    ::Sorbet::Private::Static.keep_self_def(<self>, :test, :normal)

    ::Sorbet::Private::Static.keep_def(<self>, :assert, :normal)
  end

  class <emptyTree>::<C MyTest><<C <todo sym>>> < (<emptyTree>::<C ActiveSupport>::<C TestCase>)
    ::Sorbet::Private::Static.sig(::T::Sig::WithoutRuntime) do ||
      <self>.void()
    end

    def initialize<<todo method>>(&<blk>)
      begin
        @a = <emptyTree>::<C T>.let(1, <emptyTree>::<C Integer>)
        <self>.foo()
      end
    end

    ::Sorbet::Private::Static.sig(::T::Sig::WithoutRuntime) do ||
      <self>.void()
    end

    def initialize<<todo method>>(&<blk>)
      <self>.bar()
    end

    <self>.extend(<emptyTree>::<C T>::<C Sig>)

    ::Sorbet::Private::Static.keep_def(<self>, :initialize, :normal)

    ::Sorbet::Private::Static.keep_def(<self>, :initialize, :normal)
  end

  class <emptyTree>::<C NoMatchTest><<C <todo sym>>> < (<emptyTree>::<C ActiveSupport>::<C TestCase>)
    ::Sorbet::Private::Static.sig(<self>) do ||
      <self>.params(:block, <emptyTree>::<C T>.proc().bind(<emptyTree>::<C T>.attached_class()).void()).void()
    end

    def self.setup<<todo method>>(&block)
      <emptyTree>
    end

    <self>.extend(<emptyTree>::<C T>::<C Sig>)

    ::Sorbet::Private::Static.keep_self_def(<self>, :setup, :normal)

    <self>.setup() do ||
      begin
        @a = <emptyTree>::<C T>.let(1, <emptyTree>::<C Integer>)
        <self>.foo()
      end
    end
  end

  class <emptyTree>::<C NoParentClass><<C <todo sym>>> < (::<todo sym>)
    ::Sorbet::Private::Static.sig(<self>) do ||
      <self>.params(:block, <emptyTree>::<C T>.proc().bind(<emptyTree>::<C T>.attached_class()).void()).void()
    end

    def self.setup<<todo method>>(&block)
      <emptyTree>
    end

    ::Sorbet::Private::Static.sig(<self>) do ||
      <self>.params(:block, <emptyTree>::<C T>.proc().bind(<emptyTree>::<C T>.attached_class()).void()).void()
    end

    def self.teardown<<todo method>>(&block)
      <emptyTree>
    end

    ::Sorbet::Private::Static.sig(<self>) do ||
      <self>.params(:name, <emptyTree>::<C String>, :block, <emptyTree>::<C T>.proc().bind(<emptyTree>::<C T>.attached_class()).void()).void()
    end

    def self.test<<todo method>>(name, &block)
      <emptyTree>
    end

    ::Sorbet::Private::Static.sig(<self>) do ||
      <self>.params(:a, <emptyTree>::<C T>.untyped(), :b, <emptyTree>::<C T>.untyped()).void()
    end

    def assert_equal<<todo method>>(a, b, &<blk>)
      <emptyTree>
    end

    ::Sorbet::Private::Static.sig(::T::Sig::WithoutRuntime) do ||
      <self>.void()
    end

    def initialize<<todo method>>(&<blk>)
      @a = <emptyTree>::<C T>.let(1, <emptyTree>::<C Integer>)
    end

    <self>.extend(<emptyTree>::<C T>::<C Sig>)

    ::Sorbet::Private::Static.keep_self_def(<self>, :setup, :normal)

    ::Sorbet::Private::Static.keep_self_def(<self>, :teardown, :normal)

    ::Sorbet::Private::Static.keep_self_def(<self>, :test, :normal)

    ::Sorbet::Private::Static.keep_def(<self>, :assert_equal, :normal)

    ::Sorbet::Private::Static.keep_def(<self>, :initialize, :normal)
  end
end
