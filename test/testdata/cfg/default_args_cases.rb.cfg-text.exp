method ::<Class:<root>>#<static-init> {

bb0[firstDead=2]():
    <self>: T.class_of(<root>) = cast(<self>: NilClass, T.class_of(<root>));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Test#test1 {

bb0[firstDead=-1]():
    <self>: Test = cast(<self>: NilClass, Test);
    a: Integer = load_arg(a)
    b: Integer = load_arg(b)
    <argPresent>$3: T::Boolean = arg_present(c)
    <argPresent>$3 -> (T::Boolean ? bb2 : bb3)

# backedges
# - bb9
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
bb2[firstDead=-1](a: Integer, b: Integer):
    c: Integer = load_arg(c)
    <argPresent>$6: T::Boolean = arg_present(d)
    <argPresent>$6 -> (T::Boolean ? bb4 : bb5)

# backedges
# - bb0
bb3[firstDead=-1](a: Integer, b: Integer):
    <statTemp>$4: Integer(10) = 10
    <castTemp>$5: Integer = cast(<statTemp>$4: Integer(10), Integer);
    c: Integer(10) = <statTemp>$4
    <unconditional> -> bb5

# backedges
# - bb2
bb4[firstDead=-1](a: Integer, b: Integer, c: Integer):
    d: Integer = load_arg(d)
    <unconditional> -> bb6

# backedges
# - bb2
# - bb3
bb5[firstDead=-1](a: Integer, b: Integer, c: Integer):
    x: Integer(20) = 20
    <statTemp>$7: Integer(20) = x
    <castTemp>$8: Integer = cast(<statTemp>$7: Integer(20), Integer);
    d: Integer(20) = x
    <unconditional> -> bb6

# backedges
# - bb4
# - bb5
bb6[firstDead=-1](a: Integer, b: Integer, c: Integer, d: Integer, x: T.nilable(Integer)):
    e: Integer = load_arg(e)
    <argPresent>$9: T::Boolean = arg_present(f)
    <argPresent>$9 -> (T::Boolean ? bb7 : bb8)

# backedges
# - bb6
bb7[firstDead=-1](a: Integer, b: Integer, c: Integer, d: Integer, x: T.nilable(Integer), e: Integer):
    f: String = load_arg(f)
    <unconditional> -> bb9

# backedges
# - bb6
bb8[firstDead=-1](a: Integer, b: Integer, c: Integer, d: Integer, x: T.nilable(Integer), e: Integer):
    <statTemp>$10: String("foo") = "foo"
    <castTemp>$11: String = cast(<statTemp>$10: String("foo"), String);
    f: String("foo") = <statTemp>$10
    <unconditional> -> bb9

# backedges
# - bb7
# - bb8
bb9[firstDead=19](a: Integer, b: Integer, c: Integer, d: Integer, x: T.nilable(Integer), e: Integer, f: String):
    blk: T.proc.void = load_arg(blk)
    <cfgAlias>$14: T.class_of(T) = alias <C T>
    <statTemp>$12: Integer = <cfgAlias>$14: T.class_of(T).reveal_type(a: Integer)
    <cfgAlias>$18: T.class_of(T) = alias <C T>
    <statTemp>$16: Integer = <cfgAlias>$18: T.class_of(T).reveal_type(b: Integer)
    <cfgAlias>$22: T.class_of(T) = alias <C T>
    <statTemp>$20: Integer = <cfgAlias>$22: T.class_of(T).reveal_type(c: Integer)
    <cfgAlias>$26: T.class_of(T) = alias <C T>
    <statTemp>$24: Integer = <cfgAlias>$26: T.class_of(T).reveal_type(d: Integer)
    <cfgAlias>$30: T.class_of(T) = alias <C T>
    <statTemp>$28: Integer = <cfgAlias>$30: T.class_of(T).reveal_type(e: Integer)
    <cfgAlias>$34: T.class_of(T) = alias <C T>
    <statTemp>$32: String = <cfgAlias>$34: T.class_of(T).reveal_type(f: String)
    <cfgAlias>$38: T.class_of(T) = alias <C T>
    <statTemp>$36: T.proc.void = <cfgAlias>$38: T.class_of(T).reveal_type(blk: T.proc.void)
    <statTemp>$40: Sorbet::Private::Static::Void = blk: T.proc.void.call()
    <cfgAlias>$43: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: T.nilable(Integer) = <cfgAlias>$43: T.class_of(T).reveal_type(x: T.nilable(Integer))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.nilable(Integer)
    <unconditional> -> bb1

}

method ::Test#test2 {

bb0[firstDead=-1]():
    <self>: Test = cast(<self>: NilClass, Test);
    <argPresent>$3: T::Boolean = arg_present(x)
    <argPresent>$3 -> (T::Boolean ? bb2 : bb3)

# backedges
# - bb4
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
bb2[firstDead=-1]():
    x: Integer = load_arg(x)
    <unconditional> -> bb4

# backedges
# - bb0
bb3[firstDead=-1]():
    <statTemp>$4: Integer(10) = 10
    <castTemp>$5: Integer = cast(<statTemp>$4: Integer(10), Integer);
    x: Integer(10) = <statTemp>$4
    <unconditional> -> bb4

# backedges
# - bb2
# - bb3
bb4[firstDead=9](x: Integer):
    rest: T::Array[Integer] = load_arg(rest)
    blk: T.proc.void = load_arg(blk)
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$6: Integer = <cfgAlias>$8: T.class_of(T).reveal_type(x: Integer)
    <cfgAlias>$12: T.class_of(T) = alias <C T>
    <statTemp>$10: T::Array[Integer] = <cfgAlias>$12: T.class_of(T).reveal_type(rest: T::Array[Integer])
    <cfgAlias>$15: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: T.proc.void = <cfgAlias>$15: T.class_of(T).reveal_type(blk: T.proc.void)
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.proc.void
    <unconditional> -> bb1

}

method ::Test#test3 {

bb0[firstDead=-1]():
    <self>: Test = cast(<self>: NilClass, Test);
    <argPresent>$3: T::Boolean = arg_present(x)
    <argPresent>$3 -> (T::Boolean ? bb2 : bb3)

# backedges
# - bb4
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
bb2[firstDead=-1]():
    x: Integer = load_arg(x)
    <unconditional> -> bb4

# backedges
# - bb0
bb3[firstDead=-1]():
    <statTemp>$4: Integer(10) = 10
    <castTemp>$5: Integer = cast(<statTemp>$4: Integer(10), Integer);
    x: Integer(10) = <statTemp>$4
    <unconditional> -> bb4

# backedges
# - bb2
# - bb3
bb4[firstDead=9](x: Integer):
    rest: T::Hash[Symbol, Integer] = load_arg(rest)
    blk: T.proc.void = load_arg(blk)
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$6: Integer = <cfgAlias>$8: T.class_of(T).reveal_type(x: Integer)
    <cfgAlias>$12: T.class_of(T) = alias <C T>
    <statTemp>$10: T::Hash[Symbol, Integer] = <cfgAlias>$12: T.class_of(T).reveal_type(rest: T::Hash[Symbol, Integer])
    <cfgAlias>$15: T.class_of(T) = alias <C T>
    <returnMethodTemp>$2: T.proc.void = <cfgAlias>$15: T.class_of(T).reveal_type(blk: T.proc.void)
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.proc.void
    <unconditional> -> bb1

}

method ::Test#returns_nilable_integer {

bb0[firstDead=3]():
    <self>: Test = cast(<self>: NilClass, Test);
    <returnMethodTemp>$2: Integer(5) = 5
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Integer(5)
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Test#takes_optional_integer {

bb0[firstDead=-1]():
    <self>: Test = cast(<self>: NilClass, Test);
    <argPresent>$3: T::Boolean = arg_present(x)
    <argPresent>$3 -> (T::Boolean ? bb4 : bb3)

# backedges
# - bb4
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
bb3[firstDead=-1](<self>: Test):
    <statTemp>$4: T.nilable(Integer) = <self>: Test.returns_nilable_integer()
    <castTemp>$6: Integer = cast(<statTemp>$4: T.nilable(Integer), Integer);
    <unconditional> -> bb4

# backedges
# - bb0
# - bb3
bb4[firstDead=1]():
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

}

method ::<Class:Test>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(Test) = cast(<self>: NilClass, T.class_of(Test));
    <block-pre-call-temp>$5: Sorbet::Private::Static::Void = <self>: T.class_of(Test).sig()
    <selfRestore>$6: T.class_of(Test) = <self>
    <unconditional> -> bb2

# backedges
# - bb19
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(Test), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Test)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=-1](<block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Test)):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$5, sig>
    <self>: T.class_of(Test) = <selfRestore>$6
    <block-pre-call-temp>$36: Sorbet::Private::Static::Void = <self>: T.class_of(Test).sig()
    <selfRestore>$37: T.class_of(Test) = <self>
    <unconditional> -> bb6

# backedges
# - bb2
bb5[firstDead=20](<self>: T.class_of(Test), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Test)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$10: Symbol(:a) = :a
    <cfgAlias>$12: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$13: Symbol(:b) = :b
    <cfgAlias>$15: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$16: Symbol(:c) = :c
    <cfgAlias>$18: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$19: Symbol(:d) = :d
    <cfgAlias>$21: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$22: Symbol(:e) = :e
    <cfgAlias>$24: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$25: Symbol(:f) = :f
    <cfgAlias>$27: T.class_of(String) = alias <C String>
    <hashTemp>$28: Symbol(:blk) = :blk
    <cfgAlias>$32: T.class_of(T) = alias <C T>
    <statTemp>$30: T.class_of(T.proc) = <cfgAlias>$32: T.class_of(T).proc()
    <hashTemp>$29: Runtime object representing type: T.proc.void = <statTemp>$30: T.class_of(T.proc).void()
    <statTemp>$8: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$10: Symbol(:a), <cfgAlias>$12: T.class_of(Integer), <hashTemp>$13: Symbol(:b), <cfgAlias>$15: T.class_of(Integer), <hashTemp>$16: Symbol(:c), <cfgAlias>$18: T.class_of(Integer), <hashTemp>$19: Symbol(:d), <cfgAlias>$21: T.class_of(Integer), <hashTemp>$22: Symbol(:e), <cfgAlias>$24: T.class_of(Integer), <hashTemp>$25: Symbol(:f), <cfgAlias>$27: T.class_of(String), <hashTemp>$28: Symbol(:blk), <hashTemp>$29: Runtime object representing type: T.proc.void)
    <blockReturnTemp>$7: T::Private::Methods::DeclBuilder = <statTemp>$8: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$33: T.noreturn = blockreturn<sig> <blockReturnTemp>$7: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

# backedges
# - bb3
# - bb9
bb6[firstDead=-1](<self>: T.class_of(Test), <block-pre-call-temp>$36: Sorbet::Private::Static::Void, <selfRestore>$37: T.class_of(Test)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb9 : bb7)

# backedges
# - bb6
bb7[firstDead=-1](<block-pre-call-temp>$36: Sorbet::Private::Static::Void, <selfRestore>$37: T.class_of(Test)):
    <statTemp>$34: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$36, sig>
    <self>: T.class_of(Test) = <selfRestore>$37
    <block-pre-call-temp>$55: Sorbet::Private::Static::Void = <self>: T.class_of(Test).sig()
    <selfRestore>$56: T.class_of(Test) = <self>
    <unconditional> -> bb10

# backedges
# - bb6
bb9[firstDead=12](<self>: T.class_of(Test), <block-pre-call-temp>$36: Sorbet::Private::Static::Void, <selfRestore>$37: T.class_of(Test)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$41: Symbol(:x) = :x
    <cfgAlias>$43: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$44: Symbol(:rest) = :rest
    <cfgAlias>$46: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$47: Symbol(:blk) = :blk
    <cfgAlias>$51: T.class_of(T) = alias <C T>
    <statTemp>$49: T.class_of(T.proc) = <cfgAlias>$51: T.class_of(T).proc()
    <hashTemp>$48: Runtime object representing type: T.proc.void = <statTemp>$49: T.class_of(T.proc).void()
    <statTemp>$39: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$41: Symbol(:x), <cfgAlias>$43: T.class_of(Integer), <hashTemp>$44: Symbol(:rest), <cfgAlias>$46: T.class_of(Integer), <hashTemp>$47: Symbol(:blk), <hashTemp>$48: Runtime object representing type: T.proc.void)
    <blockReturnTemp>$38: T::Private::Methods::DeclBuilder = <statTemp>$39: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$52: T.noreturn = blockreturn<sig> <blockReturnTemp>$38: T::Private::Methods::DeclBuilder
    <unconditional> -> bb6

# backedges
# - bb7
# - bb13
bb10[firstDead=-1](<self>: T.class_of(Test), <block-pre-call-temp>$55: Sorbet::Private::Static::Void, <selfRestore>$56: T.class_of(Test)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb13 : bb11)

# backedges
# - bb10
bb11[firstDead=-1](<block-pre-call-temp>$55: Sorbet::Private::Static::Void, <selfRestore>$56: T.class_of(Test)):
    <statTemp>$53: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$55, sig>
    <self>: T.class_of(Test) = <selfRestore>$56
    <block-pre-call-temp>$74: Sorbet::Private::Static::Void = <self>: T.class_of(Test).sig()
    <selfRestore>$75: T.class_of(Test) = <self>
    <unconditional> -> bb14

# backedges
# - bb10
bb13[firstDead=12](<self>: T.class_of(Test), <block-pre-call-temp>$55: Sorbet::Private::Static::Void, <selfRestore>$56: T.class_of(Test)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$60: Symbol(:x) = :x
    <cfgAlias>$62: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$63: Symbol(:rest) = :rest
    <cfgAlias>$65: T.class_of(Integer) = alias <C Integer>
    <hashTemp>$66: Symbol(:blk) = :blk
    <cfgAlias>$70: T.class_of(T) = alias <C T>
    <statTemp>$68: T.class_of(T.proc) = <cfgAlias>$70: T.class_of(T).proc()
    <hashTemp>$67: Runtime object representing type: T.proc.void = <statTemp>$68: T.class_of(T.proc).void()
    <statTemp>$58: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$60: Symbol(:x), <cfgAlias>$62: T.class_of(Integer), <hashTemp>$63: Symbol(:rest), <cfgAlias>$65: T.class_of(Integer), <hashTemp>$66: Symbol(:blk), <hashTemp>$67: Runtime object representing type: T.proc.void)
    <blockReturnTemp>$57: T::Private::Methods::DeclBuilder = <statTemp>$58: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$71: T.noreturn = blockreturn<sig> <blockReturnTemp>$57: T::Private::Methods::DeclBuilder
    <unconditional> -> bb10

# backedges
# - bb11
# - bb17
bb14[firstDead=-1](<self>: T.class_of(Test), <block-pre-call-temp>$74: Sorbet::Private::Static::Void, <selfRestore>$75: T.class_of(Test)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb17 : bb15)

# backedges
# - bb14
bb15[firstDead=-1](<block-pre-call-temp>$74: Sorbet::Private::Static::Void, <selfRestore>$75: T.class_of(Test)):
    <statTemp>$72: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$74, sig>
    <self>: T.class_of(Test) = <selfRestore>$75
    <block-pre-call-temp>$86: Sorbet::Private::Static::Void = <self>: T.class_of(Test).sig()
    <selfRestore>$87: T.class_of(Test) = <self>
    <unconditional> -> bb18

# backedges
# - bb14
bb17[firstDead=6](<self>: T.class_of(Test), <block-pre-call-temp>$74: Sorbet::Private::Static::Void, <selfRestore>$75: T.class_of(Test)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <cfgAlias>$80: T.class_of(T) = alias <C T>
    <cfgAlias>$82: T.class_of(Integer) = alias <C Integer>
    <statTemp>$78: Runtime object representing type: T.nilable(Integer) = <cfgAlias>$80: T.class_of(T).nilable(<cfgAlias>$82: T.class_of(Integer))
    <blockReturnTemp>$76: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.returns(<statTemp>$78: Runtime object representing type: T.nilable(Integer))
    <blockReturnTemp>$83: T.noreturn = blockreturn<sig> <blockReturnTemp>$76: T::Private::Methods::DeclBuilder
    <unconditional> -> bb14

# backedges
# - bb15
# - bb21
bb18[firstDead=-1](<self>: T.class_of(Test), <block-pre-call-temp>$86: Sorbet::Private::Static::Void, <selfRestore>$87: T.class_of(Test)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb21 : bb19)

# backedges
# - bb18
bb19[firstDead=6](<block-pre-call-temp>$86: Sorbet::Private::Static::Void, <selfRestore>$87: T.class_of(Test)):
    <statTemp>$84: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$86, sig>
    <self>: T.class_of(Test) = <selfRestore>$87
    <cfgAlias>$98: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$100: T.class_of(T) = alias <C T>
    <statTemp>$95: T.class_of(Test) = <self>: T.class_of(Test).extend(<cfgAlias>$98: T.class_of(T::Sig))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb18
bb21[firstDead=6](<self>: T.class_of(Test), <block-pre-call-temp>$86: Sorbet::Private::Static::Void, <selfRestore>$87: T.class_of(Test)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$91: Symbol(:x) = :x
    <cfgAlias>$93: T.class_of(Integer) = alias <C Integer>
    <statTemp>$89: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$91: Symbol(:x), <cfgAlias>$93: T.class_of(Integer))
    <blockReturnTemp>$88: T::Private::Methods::DeclBuilder = <statTemp>$89: T::Private::Methods::DeclBuilder.void()
    <blockReturnTemp>$94: T.noreturn = blockreturn<sig> <blockReturnTemp>$88: T::Private::Methods::DeclBuilder
    <unconditional> -> bb18

}

