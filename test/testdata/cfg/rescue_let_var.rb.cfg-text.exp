method ::Object#mismatched_but_for_effect {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: Object = cast(<self>: NilClass, Object);
    params: T.untyped = load_arg(params)
    <cfgAlias>$6: T.class_of(T::Array) = alias <C Array>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <cfgAlias>$10: T.class_of(String) = alias <C String>
    keep_for_ide$4: Runtime object representing type: T::Array[String] = <cfgAlias>$6: T.class_of(T::Array).[](<cfgAlias>$10: T.class_of(String))
    keep_for_ide$4: T.untyped = <keep-alive> keep_for_ide$4
    <magic>$12: T.class_of(<Magic>) = alias <C <Magic>>
    <castTemp>$11: [] = <magic>$12: T.class_of(<Magic>).<build-array>()
    error_messages: T::Array[String] = cast(<castTemp>$11: [], T::Array[String]);
    <magic>$27: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$14: T.untyped = <get-current-exception>
    <exceptionValue>$14 -> (T.untyped ? bb3 : bb4)

# backedges
# - bb6(rubyRegionId=3)
# - bb10(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb4(rubyRegionId=1)
bb3[rubyRegionId=2, firstDead=-1](error_messages: T::Array[String], <exceptionValue>$14: T.untyped, <magic>$27: T.class_of(<Magic>)):
    <cfgAlias>$30: T.class_of(TypeError) = alias <C TypeError>
    <isaCheckTemp>$31: T.untyped = <exceptionValue>$14: T.untyped.is_a?(<cfgAlias>$30: T.class_of(TypeError))
    <isaCheckTemp>$31 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb0(rubyRegionId=0)
bb4[rubyRegionId=1, firstDead=-1](params: T.untyped, error_messages: T::Array[String], <magic>$27: T.class_of(<Magic>)):
    <cfgAlias>$17: T.class_of(T::Hash) = alias <C Hash>
    <cfgAlias>$19: T.class_of(T) = alias <C T>
    <cfgAlias>$21: T.class_of(String) = alias <C String>
    <cfgAlias>$23: T.class_of(String) = alias <C String>
    keep_for_ide$15: Runtime object representing type: T::Hash[String, String] = <cfgAlias>$17: T.class_of(T::Hash).[](<cfgAlias>$21: T.class_of(String), <cfgAlias>$23: T.class_of(String))
    keep_for_ide$15: T.untyped = <keep-alive> keep_for_ide$15
    <statTemp>$26: Symbol(:contents) = :contents
    <castTemp>$24: T.untyped = params: T.untyped.[](<statTemp>$26: Symbol(:contents))
    <statTemp>$13: T::Hash[String, String] = cast(<castTemp>$24: T.untyped, T::Hash[String, String]);
    <exceptionValue>$14: T.untyped = <get-current-exception>
    <exceptionValue>$14 -> (T.untyped ? bb3 : bb5)

# backedges
# - bb4(rubyRegionId=1)
bb5[rubyRegionId=4, firstDead=-1]():
    <unconditional> -> bb6

# backedges
# - bb5(rubyRegionId=4)
# - bb7(rubyRegionId=2)
# - bb8(rubyRegionId=2)
bb6[rubyRegionId=3, firstDead=-1](<gotoDeadTemp>$35: T.nilable(TrueClass)):
    <gotoDeadTemp>$35 -> (T.nilable(TrueClass) ? bb1 : bb10)

# backedges
# - bb3(rubyRegionId=2)
bb7[rubyRegionId=2, firstDead=-1](error_messages: T::Array[String], <magic>$27: T.class_of(<Magic>)):
    <exceptionValue>$14: NilClass = nil
    <keepForCfgTemp>$28: Sorbet::Private::Static::Void = <magic>$27: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$14: NilClass)
    <statTemp>$34: String("contents must be a hash of {path : contents}") = "contents must be a hash of {path : contents}"
    <statTemp>$32: T::Array[String] = error_messages: T::Array[String].<<(<statTemp>$34: String("contents must be a hash of {path : contents}"))
    <unconditional> -> bb6

# backedges
# - bb3(rubyRegionId=2)
bb8[rubyRegionId=2, firstDead=-1]():
    <gotoDeadTemp>$35: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6(rubyRegionId=3)
bb10[rubyRegionId=0, firstDead=2]():
    <returnMethodTemp>$2: NilClass = nil
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

}

method ::Object#mismatched_return_value {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: Object = cast(<self>: NilClass, Object);
    params: T.untyped = load_arg(params)
    <cfgAlias>$6: T.class_of(T::Array) = alias <C Array>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <cfgAlias>$10: T.class_of(String) = alias <C String>
    keep_for_ide$4: Runtime object representing type: T::Array[String] = <cfgAlias>$6: T.class_of(T::Array).[](<cfgAlias>$10: T.class_of(String))
    keep_for_ide$4: T.untyped = <keep-alive> keep_for_ide$4
    <magic>$12: T.class_of(<Magic>) = alias <C <Magic>>
    <castTemp>$11: [] = <magic>$12: T.class_of(<Magic>).<build-array>()
    error_messages: T::Array[String] = cast(<castTemp>$11: [], T::Array[String]);
    <magic>$26: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$13: T.untyped = <get-current-exception>
    <exceptionValue>$13 -> (T.untyped ? bb3 : bb4)

# backedges
# - bb6(rubyRegionId=3)
# - bb10(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb4(rubyRegionId=1)
bb3[rubyRegionId=2, firstDead=-1](<returnMethodTemp>$2: T.nilable(T::Hash[String, String]), error_messages: T::Array[String], <exceptionValue>$13: T.untyped, <magic>$26: T.class_of(<Magic>)):
    <cfgAlias>$29: T.class_of(TypeError) = alias <C TypeError>
    <isaCheckTemp>$30: T.untyped = <exceptionValue>$13: T.untyped.is_a?(<cfgAlias>$29: T.class_of(TypeError))
    <isaCheckTemp>$30 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb0(rubyRegionId=0)
bb4[rubyRegionId=1, firstDead=-1](params: T.untyped, error_messages: T::Array[String], <magic>$26: T.class_of(<Magic>)):
    <cfgAlias>$16: T.class_of(T::Hash) = alias <C Hash>
    <cfgAlias>$18: T.class_of(T) = alias <C T>
    <cfgAlias>$20: T.class_of(String) = alias <C String>
    <cfgAlias>$22: T.class_of(String) = alias <C String>
    keep_for_ide$14: Runtime object representing type: T::Hash[String, String] = <cfgAlias>$16: T.class_of(T::Hash).[](<cfgAlias>$20: T.class_of(String), <cfgAlias>$22: T.class_of(String))
    keep_for_ide$14: T.untyped = <keep-alive> keep_for_ide$14
    <statTemp>$25: Symbol(:contents) = :contents
    <castTemp>$23: T.untyped = params: T.untyped.[](<statTemp>$25: Symbol(:contents))
    <returnMethodTemp>$2: T::Hash[String, String] = cast(<castTemp>$23: T.untyped, T::Hash[String, String]);
    <exceptionValue>$13: T.untyped = <get-current-exception>
    <exceptionValue>$13 -> (T.untyped ? bb3 : bb5)

# backedges
# - bb4(rubyRegionId=1)
bb5[rubyRegionId=4, firstDead=-1](<returnMethodTemp>$2: T::Hash[String, String]):
    <unconditional> -> bb6

# backedges
# - bb5(rubyRegionId=4)
# - bb7(rubyRegionId=2)
# - bb8(rubyRegionId=2)
bb6[rubyRegionId=3, firstDead=-1](<returnMethodTemp>$2: T.nilable(T::Hash[String, String]), <gotoDeadTemp>$34: T.nilable(TrueClass)):
    <gotoDeadTemp>$34 -> (T.nilable(TrueClass) ? bb1 : bb10)

# backedges
# - bb3(rubyRegionId=2)
bb7[rubyRegionId=2, firstDead=-1](<returnMethodTemp>$2: T.nilable(T::Hash[String, String]), error_messages: T::Array[String], <magic>$26: T.class_of(<Magic>)):
    <exceptionValue>$13: NilClass = nil
    <keepForCfgTemp>$27: Sorbet::Private::Static::Void = <magic>$26: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$13: NilClass)
    <statTemp>$33: String("contents must be a hash of {path : contents}") = "contents must be a hash of {path : contents}"
    <statTemp>$31: T::Array[String] = error_messages: T::Array[String].<<(<statTemp>$33: String("contents must be a hash of {path : contents}"))
    <returnMethodTemp>$2: T::Hash[String, String] = <statTemp>$31
    <unconditional> -> bb6

# backedges
# - bb3(rubyRegionId=2)
bb8[rubyRegionId=2, firstDead=-1](<returnMethodTemp>$2: T.nilable(T::Hash[String, String])):
    <gotoDeadTemp>$34: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6(rubyRegionId=3)
bb10[rubyRegionId=0, firstDead=1](<returnMethodTemp>$2: T::Hash[String, String]):
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T::Hash[String, String]
    <unconditional> -> bb1

}

method ::<Class:<root>>#<static-init> {

bb0[rubyRegionId=0, firstDead=-1]():
    <self>: T.class_of(<root>) = cast(<self>: NilClass, T.class_of(<root>));
    <cfgAlias>$6: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$8: T.class_of(T) = alias <C T>
    <statTemp>$3: T.class_of(<root>) = <self>: T.class_of(<root>).extend(<cfgAlias>$6: T.class_of(T::Sig))
    <cfgAlias>$14: T.class_of(T::Array) = alias <C Array>
    <cfgAlias>$16: T.class_of(T) = alias <C T>
    <cfgAlias>$18: T.class_of(String) = alias <C String>
    keep_for_ide$12: Runtime object representing type: T::Array[String] = <cfgAlias>$14: T.class_of(T::Array).[](<cfgAlias>$18: T.class_of(String))
    keep_for_ide$12: T.untyped = <keep-alive> keep_for_ide$12
    <magic>$20: T.class_of(<Magic>) = alias <C <Magic>>
    <castTemp>$19: [] = <magic>$20: T.class_of(<Magic>).<build-array>()
    error_messages: T::Array[String] = cast(<castTemp>$19: [], T::Array[String]);
    <hashTemp>$22: Symbol(:contents) = :contents
    <hashTemp>$23: String("thing") = "thing"
    <magic>$24: T.class_of(<Magic>) = alias <C <Magic>>
    params: {contents: String("thing")} = <magic>$24: T.class_of(<Magic>).<build-hash>(<hashTemp>$22: Symbol(:contents), <hashTemp>$23: String("thing"))
    <magic>$39: T.class_of(<Magic>) = alias <C <Magic>>
    <exceptionValue>$26: T.untyped = <get-current-exception>
    <exceptionValue>$26 -> (T.untyped ? bb3 : bb4)

# backedges
# - bb6(rubyRegionId=3)
# - bb10(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb4(rubyRegionId=1)
bb3[rubyRegionId=2, firstDead=-1](error_messages: T::Array[String], <exceptionValue>$26: T.untyped, <magic>$39: T.class_of(<Magic>)):
    <cfgAlias>$42: T.class_of(TypeError) = alias <C TypeError>
    <isaCheckTemp>$43: T.untyped = <exceptionValue>$26: T.untyped.is_a?(<cfgAlias>$42: T.class_of(TypeError))
    <isaCheckTemp>$43 -> (T.untyped ? bb7 : bb8)

# backedges
# - bb0(rubyRegionId=0)
bb4[rubyRegionId=1, firstDead=-1](error_messages: T::Array[String], params: {contents: String("thing")}, <magic>$39: T.class_of(<Magic>)):
    <cfgAlias>$29: T.class_of(T::Hash) = alias <C Hash>
    <cfgAlias>$31: T.class_of(T) = alias <C T>
    <cfgAlias>$33: T.class_of(String) = alias <C String>
    <cfgAlias>$35: T.class_of(String) = alias <C String>
    keep_for_ide$27: Runtime object representing type: T::Hash[String, String] = <cfgAlias>$29: T.class_of(T::Hash).[](<cfgAlias>$33: T.class_of(String), <cfgAlias>$35: T.class_of(String))
    keep_for_ide$27: T.untyped = <keep-alive> keep_for_ide$27
    <statTemp>$38: Symbol(:contents) = :contents
    <castTemp>$36: T.untyped = params: {contents: String("thing")}.[](<statTemp>$38: Symbol(:contents))
    <statTemp>$25: T::Hash[String, String] = cast(<castTemp>$36: T.untyped, T::Hash[String, String]);
    <exceptionValue>$26: T.untyped = <get-current-exception>
    <exceptionValue>$26 -> (T.untyped ? bb3 : bb5)

# backedges
# - bb4(rubyRegionId=1)
bb5[rubyRegionId=4, firstDead=-1]():
    <unconditional> -> bb6

# backedges
# - bb5(rubyRegionId=4)
# - bb7(rubyRegionId=2)
# - bb8(rubyRegionId=2)
bb6[rubyRegionId=3, firstDead=-1](<gotoDeadTemp>$47: T.nilable(TrueClass)):
    <gotoDeadTemp>$47 -> (T.nilable(TrueClass) ? bb1 : bb10)

# backedges
# - bb3(rubyRegionId=2)
bb7[rubyRegionId=2, firstDead=-1](error_messages: T::Array[String], <magic>$39: T.class_of(<Magic>)):
    <exceptionValue>$26: NilClass = nil
    <keepForCfgTemp>$40: Sorbet::Private::Static::Void = <magic>$39: T.class_of(<Magic>).<keep-for-cfg>(<exceptionValue>$26: NilClass)
    <statTemp>$46: String("contents must be a hash of {path : contents}") = "contents must be a hash of {path : contents}"
    <statTemp>$44: T::Array[String] = error_messages: T::Array[String].<<(<statTemp>$46: String("contents must be a hash of {path : contents}"))
    <unconditional> -> bb6

# backedges
# - bb3(rubyRegionId=2)
bb8[rubyRegionId=2, firstDead=-1]():
    <gotoDeadTemp>$47: TrueClass = true
    <unconditional> -> bb6

# backedges
# - bb6(rubyRegionId=3)
bb10[rubyRegionId=0, firstDead=1]():
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

}

