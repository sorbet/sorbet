class ::<root> < ::Object ()
  class ::<Class:<root>>[<AttachedClass>] < ::<Class:Object> ()
    method ::<Class:<root>>#<static-init> (<blk>) @ test/testdata/lsp/requires_ancestor_ab.rb:4
      argument <blk><block> @ Loc {file=test/testdata/lsp/requires_ancestor_ab.rb start=??? end=???}
  module ::A < ::Sorbet::Private::Static::ImplicitModuleSuperclass () @ test/testdata/lsp/requires_ancestor_ab.rb:4
    method ::A#on_both_a_and_b (<blk>) -> Integer @ test/testdata/lsp/requires_ancestor_ab.rb:10
      argument <blk><block> -> T.noreturn @ Loc {file=test/testdata/lsp/requires_ancestor_ab.rb start=??? end=???}
    method ::A#only_on_a (<blk>) @ test/testdata/lsp/requires_ancestor_ab.rb:7
      argument <blk><block> @ Loc {file=test/testdata/lsp/requires_ancestor_ab.rb start=??? end=???}
  class ::<Class:A>[<AttachedClass>] < ::Module (Sig) @ test/testdata/lsp/requires_ancestor_ab.rb:4
    type-member(+) ::<Class:A>::<AttachedClass> -> T.attached_class (of A) @ test/testdata/lsp/requires_ancestor_ab.rb:4
    method ::<Class:A>#<static-init> (<blk>) @ test/testdata/lsp/requires_ancestor_ab.rb:4
      argument <blk><block> @ Loc {file=test/testdata/lsp/requires_ancestor_ab.rb start=??? end=???}
  module ::B < ::Sorbet::Private::Static::ImplicitModuleSuperclass () @ test/testdata/lsp/requires_ancestor_ab.rb:13
    method ::B#on_both_a_and_b (<blk>) -> String @ test/testdata/lsp/requires_ancestor_ab.rb:19
      argument <blk><block> -> T.noreturn @ Loc {file=test/testdata/lsp/requires_ancestor_ab.rb start=??? end=???}
    method ::B#only_on_b (<blk>) @ test/testdata/lsp/requires_ancestor_ab.rb:16
      argument <blk><block> @ Loc {file=test/testdata/lsp/requires_ancestor_ab.rb start=??? end=???}
  class ::<Class:B>[<AttachedClass>] < ::Module (Sig) @ test/testdata/lsp/requires_ancestor_ab.rb:13
    type-member(+) ::<Class:B>::<AttachedClass> -> T.attached_class (of B) @ test/testdata/lsp/requires_ancestor_ab.rb:13
    method ::<Class:B>#<static-init> (<blk>) @ test/testdata/lsp/requires_ancestor_ab.rb:13
      argument <blk><block> @ Loc {file=test/testdata/lsp/requires_ancestor_ab.rb start=??? end=???}
  class ::C < ::Object (Target) @ test/testdata/lsp/requires_ancestor_ab.rb:35
  class ::<Class:C>[<AttachedClass>] < ::<Class:Object> () @ test/testdata/lsp/requires_ancestor_ab.rb:35
    type-member(+) ::<Class:C>::<AttachedClass> -> T.attached_class (of C) @ test/testdata/lsp/requires_ancestor_ab.rb:35
    method ::<Class:C>#<static-init> (<blk>) @ test/testdata/lsp/requires_ancestor_ab.rb:35
      argument <blk><block> @ Loc {file=test/testdata/lsp/requires_ancestor_ab.rb start=??? end=???}
  module ::Target < ::Sorbet::Private::Static::ImplicitModuleSuperclass () @ test/testdata/lsp/requires_ancestor_ab.rb:22
    method ::Target#foo_b (<blk>) @ test/testdata/lsp/requires_ancestor_ab.rb:27
      argument <blk><block> @ Loc {file=test/testdata/lsp/requires_ancestor_ab.rb start=??? end=???}
  class ::<Class:Target>[<AttachedClass>] < ::Module (Helpers) @ test/testdata/lsp/requires_ancestor_ab.rb:22
    type-member(+) ::<Class:Target>::<AttachedClass> -> T.attached_class (of Target) @ test/testdata/lsp/requires_ancestor_ab.rb:22
    method ::<Class:Target>#<static-init> (<blk>) @ test/testdata/lsp/requires_ancestor_ab.rb:22
      argument <blk><block> @ Loc {file=test/testdata/lsp/requires_ancestor_ab.rb start=??? end=???}

