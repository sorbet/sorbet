method ::<Class:<root>>#<static-init> {

bb0[rubyRegionId=0, firstDead=4]():
    <self>: T.class_of(<root>) = cast(<self>: NilClass, T.class_of(<root>));
    <cfgAlias>$4: T.class_of(Main) = alias <C Main>
    <returnMethodTemp>$2: T.untyped = <cfgAlias>$4: T.class_of(Main).main()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:A>#each {

bb0[rubyRegionId=0, firstDead=15]():
    <self>: T.class_of(A) = cast(<self>: NilClass, T.class_of(A));
    blk: T.untyped = load_arg(blk)
    <statTemp>$5: Integer(1) = 1
    <statTemp>$6: Integer(2) = 2
    <statTemp>$7: Integer(3) = 3
    <statTemp>$8: Integer(4) = 4
    <statTemp>$9: Integer(5) = 5
    <statTemp>$3: T.untyped = blk: T.untyped.call(<statTemp>$5: Integer(1), <statTemp>$6: Integer(2), <statTemp>$7: Integer(3), <statTemp>$8: Integer(4), <statTemp>$9: Integer(5))
    <statTemp>$11: Integer(6) = 6
    <statTemp>$12: Integer(7) = 7
    <statTemp>$13: Integer(8) = 8
    <statTemp>$14: Integer(9) = 9
    <statTemp>$15: Integer(0) = 0
    <returnMethodTemp>$2: T.untyped = blk: T.untyped.call(<statTemp>$11: Integer(6), <statTemp>$12: Integer(7), <statTemp>$13: Integer(8), <statTemp>$14: Integer(9), <statTemp>$15: Integer(0))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:A>#<static-init> {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: T.class_of(A) = cast(<self>: NilClass, T.class_of(A));
    <returnMethodTemp>$2: Symbol(:each) = :each
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:each)
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:E>#e= {

bb0[rubyRegionId=0, firstDead=10]():
    @e$3: T.untyped = alias <C <undeclared-field-stub>> (@e)
    <self>: T.class_of(E) = cast(<self>: NilClass, T.class_of(E));
    e: T.untyped = load_arg(e)
    <cfgAlias>$5: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$7: String("singleton class instance") = "singleton class instance"
    <statTemp>$8: String("e=") = "e="
    <statTemp>$9: Symbol(:@e) = :@e
    @e$3: T.untyped = <cfgAlias>$5: T.class_of(<Magic>).<suggest-field-type>(e: T.untyped, <statTemp>$7: String("singleton class instance"), <statTemp>$8: String("e="), <statTemp>$9: Symbol(:@e))
    <returnMethodTemp>$2: T.untyped = @e$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:E>#e {

bb0[rubyRegionId=0, firstDead=4]():
    @e$3: T.untyped = alias <C <undeclared-field-stub>> (@e)
    <self>: T.class_of(E) = cast(<self>: NilClass, T.class_of(E));
    <returnMethodTemp>$2: T.untyped = @e$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:E>#<static-init> {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(E) = cast(<self>: NilClass, T.class_of(E));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Main>#main {

bb0[rubyRegionId=0, firstDead=-1]():
    @a$114: T.untyped = alias <C <undeclared-field-stub>> (@a)
    @@b$124: T.untyped = alias <C <undeclared-field-stub>> (@@b)
    $c$134: T.untyped = alias <C <undeclared-field-stub>> ($c)
    <self>: T.class_of(Main) = cast(<self>: NilClass, T.class_of(Main));
    <cfgAlias>$5: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$6: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(A).each()
    <selfRestore>$7: T.class_of(Main) = <self>
    <unconditional> -> bb2

# backedges
# - bb23(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Main), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=-1](<block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    <statTemp>$3: T.untyped = Solve<<block-pre-call-temp>$6, each>
    <self>: T.class_of(Main) = <selfRestore>$7
    <cfgAlias>$16: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$17: Sorbet::Private::Static::Void = <cfgAlias>$16: T.class_of(A).each()
    <selfRestore>$18: T.class_of(Main) = <self>
    <unconditional> -> bb6

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=6](<self>: T.class_of(Main), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <blk>$8: T.untyped = load_yield_params(each)
    a$1: T.untyped = yield_load_arg(0, <blk>$8: T.untyped)
    <statTemp>$11: T.untyped = a$1: T.untyped.inspect()
    <blockReturnTemp>$9: NilClass = <self>: T.class_of(Main).puts(<statTemp>$11: T.untyped)
    <blockReturnTemp>$13: T.noreturn = blockreturn<each> <blockReturnTemp>$9: NilClass
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
# - bb9(rubyRegionId=2)
bb6[rubyRegionId=2, firstDead=-1](<self>: T.class_of(Main), <block-pre-call-temp>$17: Sorbet::Private::Static::Void, <selfRestore>$18: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb9 : bb7)

# backedges
# - bb6(rubyRegionId=2)
bb7[rubyRegionId=0, firstDead=-1](<block-pre-call-temp>$17: Sorbet::Private::Static::Void, <selfRestore>$18: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    <statTemp>$14: T.untyped = Solve<<block-pre-call-temp>$17, each>
    <self>: T.class_of(Main) = <selfRestore>$18
    <cfgAlias>$46: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$47: Sorbet::Private::Static::Void = <cfgAlias>$46: T.class_of(A).each()
    <selfRestore>$48: T.class_of(Main) = <self>
    <unconditional> -> bb10

# backedges
# - bb6(rubyRegionId=2)
bb9[rubyRegionId=2, firstDead=17](<self>: T.class_of(Main), <block-pre-call-temp>$17: Sorbet::Private::Static::Void, <selfRestore>$18: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <blk>$19: T.untyped = load_yield_params(each)
    forTemp$2: T.untyped = yield_load_arg(0, <blk>$19: T.untyped)
    <cfgAlias>$24: T.class_of(<Magic>) = alias <C <Magic>>
    <assignTemp>$2$2: T.untyped = <cfgAlias>$24: T.class_of(<Magic>).<splat>(forTemp$2: T.untyped)
    <cfgAlias>$28: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$30: Integer(1) = 1
    <statTemp>$31: Integer(0) = 0
    <assignTemp>$3$2: T.untyped = <cfgAlias>$28: T.class_of(<Magic>).<expand-splat>(<assignTemp>$2$2: T.untyped, <statTemp>$30: Integer(1), <statTemp>$31: Integer(0))
    <statTemp>$34: Integer(0) = 0
    a$2: T.untyped = <assignTemp>$3$2: T.untyped.[](<statTemp>$34: Integer(0))
    <cfgAlias>$37: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$39: Integer(1) = 1
    <statTemp>$35: T.untyped = <cfgAlias>$37: T.class_of(<Magic>).<mlhs use all>(<assignTemp>$2$2: T.untyped, <statTemp>$39: Integer(1))
    <statTemp>$41: T.untyped = a$2: T.untyped.inspect()
    <blockReturnTemp>$20: NilClass = <self>: T.class_of(Main).puts(<statTemp>$41: T.untyped)
    <blockReturnTemp>$43: T.noreturn = blockreturn<each> <blockReturnTemp>$20: NilClass
    <unconditional> -> bb6

# backedges
# - bb7(rubyRegionId=0)
# - bb13(rubyRegionId=3)
bb10[rubyRegionId=3, firstDead=-1](<self>: T.class_of(Main), <block-pre-call-temp>$47: Sorbet::Private::Static::Void, <selfRestore>$48: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb13 : bb11)

# backedges
# - bb10(rubyRegionId=3)
bb11[rubyRegionId=0, firstDead=-1](<block-pre-call-temp>$47: Sorbet::Private::Static::Void, <selfRestore>$48: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    <statTemp>$44: T.untyped = Solve<<block-pre-call-temp>$47, each>
    <self>: T.class_of(Main) = <selfRestore>$48
    <cfgAlias>$61: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$62: Sorbet::Private::Static::Void = <cfgAlias>$61: T.class_of(A).each()
    <selfRestore>$63: T.class_of(Main) = <self>
    <unconditional> -> bb14

# backedges
# - bb10(rubyRegionId=3)
bb13[rubyRegionId=3, firstDead=9](<self>: T.class_of(Main), <block-pre-call-temp>$47: Sorbet::Private::Static::Void, <selfRestore>$48: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <blk>$49: T.untyped = load_yield_params(each)
    a$3: T.untyped = yield_load_arg(0, <blk>$49: T.untyped)
    b$3: T.untyped = yield_load_arg(1, <blk>$49: T.untyped)
    <statTemp>$53: T.untyped = a$3: T.untyped.inspect()
    <statTemp>$51: NilClass = <self>: T.class_of(Main).puts(<statTemp>$53: T.untyped)
    <statTemp>$56: T.untyped = b$3: T.untyped.inspect()
    <blockReturnTemp>$50: NilClass = <self>: T.class_of(Main).puts(<statTemp>$56: T.untyped)
    <blockReturnTemp>$58: T.noreturn = blockreturn<each> <blockReturnTemp>$50: NilClass
    <unconditional> -> bb10

# backedges
# - bb11(rubyRegionId=0)
# - bb17(rubyRegionId=4)
bb14[rubyRegionId=4, firstDead=-1](<self>: T.class_of(Main), <block-pre-call-temp>$62: Sorbet::Private::Static::Void, <selfRestore>$63: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb17 : bb15)

# backedges
# - bb14(rubyRegionId=4)
bb15[rubyRegionId=0, firstDead=-1](<block-pre-call-temp>$62: Sorbet::Private::Static::Void, <selfRestore>$63: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    <statTemp>$59: T.untyped = Solve<<block-pre-call-temp>$62, each>
    <self>: T.class_of(Main) = <selfRestore>$63
    <statTemp>$98: String("main") = "main"
    <statTemp>$96: NilClass = <self>: T.class_of(Main).puts(<statTemp>$98: String("main"))
    <cfgAlias>$101: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$102: Sorbet::Private::Static::Void = <cfgAlias>$101: T.class_of(A).each()
    <selfRestore>$103: T.class_of(Main) = <self>
    <unconditional> -> bb18

# backedges
# - bb14(rubyRegionId=4)
bb17[rubyRegionId=4, firstDead=21](<self>: T.class_of(Main), <block-pre-call-temp>$62: Sorbet::Private::Static::Void, <selfRestore>$63: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <blk>$64: T.untyped = load_yield_params(each)
    forTemp$4: T.untyped = yield_load_arg(0, <blk>$64: T.untyped)
    <cfgAlias>$69: T.class_of(<Magic>) = alias <C <Magic>>
    <assignTemp>$4$4: T.untyped = <cfgAlias>$69: T.class_of(<Magic>).<splat>(forTemp$4: T.untyped)
    <cfgAlias>$73: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$75: Integer(2) = 2
    <statTemp>$76: Integer(0) = 0
    <assignTemp>$5$4: T.untyped = <cfgAlias>$73: T.class_of(<Magic>).<expand-splat>(<assignTemp>$4$4: T.untyped, <statTemp>$75: Integer(2), <statTemp>$76: Integer(0))
    <statTemp>$79: Integer(0) = 0
    a$4: T.untyped = <assignTemp>$5$4: T.untyped.[](<statTemp>$79: Integer(0))
    <statTemp>$82: Integer(1) = 1
    b$4: T.untyped = <assignTemp>$5$4: T.untyped.[](<statTemp>$82: Integer(1))
    <cfgAlias>$85: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$87: Integer(2) = 2
    <statTemp>$83: T.untyped = <cfgAlias>$85: T.class_of(<Magic>).<mlhs use all>(<assignTemp>$4$4: T.untyped, <statTemp>$87: Integer(2))
    <statTemp>$90: T.untyped = a$4: T.untyped.inspect()
    <statTemp>$88: NilClass = <self>: T.class_of(Main).puts(<statTemp>$90: T.untyped)
    <statTemp>$93: T.untyped = b$4: T.untyped.inspect()
    <blockReturnTemp>$65: NilClass = <self>: T.class_of(Main).puts(<statTemp>$93: T.untyped)
    <blockReturnTemp>$95: T.noreturn = blockreturn<each> <blockReturnTemp>$65: NilClass
    <unconditional> -> bb14

# backedges
# - bb15(rubyRegionId=0)
# - bb21(rubyRegionId=5)
bb18[rubyRegionId=5, firstDead=-1](<self>: T.class_of(Main), <block-pre-call-temp>$102: Sorbet::Private::Static::Void, <selfRestore>$103: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb21 : bb19)

# backedges
# - bb18(rubyRegionId=5)
bb19[rubyRegionId=0, firstDead=-1](<block-pre-call-temp>$102: Sorbet::Private::Static::Void, <selfRestore>$103: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    <statTemp>$99: T.untyped = Solve<<block-pre-call-temp>$102, each>
    <self>: T.class_of(Main) = <selfRestore>$103
    <cfgAlias>$174: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$175: Sorbet::Private::Static::Void = <cfgAlias>$174: T.class_of(A).each()
    <selfRestore>$176: T.class_of(Main) = <self>
    <unconditional> -> bb22

# backedges
# - bb18(rubyRegionId=5)
bb21[rubyRegionId=5, firstDead=43](<self>: T.class_of(Main), <block-pre-call-temp>$102: Sorbet::Private::Static::Void, <selfRestore>$103: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <cfgAlias>$109: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$111: Integer(5) = 5
    <statTemp>$112: Integer(0) = 0
    <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass] = <cfgAlias>$109: T.class_of(<Magic>).<expand-splat>(forTemp$6$5: NilClass, <statTemp>$111: Integer(5), <statTemp>$112: Integer(0))
    <cfgAlias>$116: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$119: Integer(0) = 0
    <statTemp>$117: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$119: Integer(0))
    <statTemp>$120: String("singleton class instance") = "singleton class instance"
    <statTemp>$121: String("main") = "main"
    <statTemp>$122: Symbol(:@a) = :@a
    @a$114: NilClass = <cfgAlias>$116: T.class_of(<Magic>).<suggest-field-type>(<statTemp>$117: NilClass, <statTemp>$120: String("singleton class instance"), <statTemp>$121: String("main"), <statTemp>$122: Symbol(:@a))
    <cfgAlias>$126: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$129: Integer(1) = 1
    <statTemp>$127: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$129: Integer(1))
    <statTemp>$130: String("class") = "class"
    <statTemp>$131: String("main") = "main"
    <statTemp>$132: Symbol(:@@b) = :@@b
    @@b$124: NilClass = <cfgAlias>$126: T.class_of(<Magic>).<suggest-field-type>(<statTemp>$127: NilClass, <statTemp>$130: String("class"), <statTemp>$131: String("main"), <statTemp>$132: Symbol(:@@b))
    <statTemp>$136: Integer(2) = 2
    $c$134: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$136: Integer(2))
    <statTemp>$139: Integer(3) = 3
    d$5: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$139: Integer(3))
    <cfgAlias>$142: T.class_of(E) = alias <C E>
    <statTemp>$145: Integer(4) = 4
    <statTemp>$143: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$145: Integer(4))
    <statTemp>$140: NilClass = <cfgAlias>$142: T.class_of(E).e=(<statTemp>$143: NilClass)
    <cfgAlias>$148: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$150: Integer(5) = 5
    <statTemp>$146: T.untyped = <cfgAlias>$148: T.class_of(<Magic>).<mlhs use all>(forTemp$6$5: NilClass, <statTemp>$150: Integer(5))
    <statTemp>$153: T.untyped = @a$114: NilClass.inspect()
    <statTemp>$151: NilClass = <self>: T.class_of(Main).puts(<statTemp>$153: T.untyped)
    <statTemp>$157: T.untyped = @@b$124: NilClass.inspect()
    <statTemp>$155: NilClass = <self>: T.class_of(Main).puts(<statTemp>$157: T.untyped)
    <statTemp>$161: T.untyped = $c$134: NilClass.inspect()
    <statTemp>$159: NilClass = <self>: T.class_of(Main).puts(<statTemp>$161: T.untyped)
    <statTemp>$165: T.untyped = d$5: NilClass.inspect()
    <statTemp>$163: NilClass = <self>: T.class_of(Main).puts(<statTemp>$165: T.untyped)
    <cfgAlias>$171: T.class_of(E) = alias <C E>
    <statTemp>$169: T.untyped = <cfgAlias>$171: T.class_of(E).e()
    <statTemp>$168: T.untyped = <statTemp>$169: T.untyped.inspect()
    <blockReturnTemp>$104: NilClass = <self>: T.class_of(Main).puts(<statTemp>$168: T.untyped)
    <blockReturnTemp>$172: T.noreturn = blockreturn<each> <blockReturnTemp>$104: NilClass
    <unconditional> -> bb18

# backedges
# - bb19(rubyRegionId=0)
# - bb25(rubyRegionId=6)
bb22[rubyRegionId=6, firstDead=-1](<self>: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped, <block-pre-call-temp>$175: Sorbet::Private::Static::Void, <selfRestore>$176: T.class_of(Main)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb25 : bb23)

# backedges
# - bb22(rubyRegionId=6)
bb23[rubyRegionId=0, firstDead=2](<block-pre-call-temp>$175: Sorbet::Private::Static::Void, <selfRestore>$176: T.class_of(Main)):
    <returnMethodTemp>$2: T.untyped = Solve<<block-pre-call-temp>$175, each>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb22(rubyRegionId=6)
bb25[rubyRegionId=6, firstDead=47](<self>: T.class_of(Main), @a$114: T.untyped, @@b$124: T.untyped, $c$134: T.untyped, <block-pre-call-temp>$175: Sorbet::Private::Static::Void, <selfRestore>$176: T.class_of(Main)):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <blk>$177: T.untyped = load_yield_params(each)
    forTemp$6: T.untyped = yield_load_arg(0, <blk>$177: T.untyped)
    <cfgAlias>$182: T.class_of(<Magic>) = alias <C <Magic>>
    <assignTemp>$9$6: T.untyped = <cfgAlias>$182: T.class_of(<Magic>).<splat>(forTemp$6: T.untyped)
    <cfgAlias>$186: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$188: Integer(5) = 5
    <statTemp>$189: Integer(0) = 0
    <assignTemp>$10$6: T.untyped = <cfgAlias>$186: T.class_of(<Magic>).<expand-splat>(<assignTemp>$9$6: T.untyped, <statTemp>$188: Integer(5), <statTemp>$189: Integer(0))
    <cfgAlias>$192: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$195: Integer(0) = 0
    <statTemp>$193: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$195: Integer(0))
    <statTemp>$196: String("singleton class instance") = "singleton class instance"
    <statTemp>$197: String("main") = "main"
    <statTemp>$198: Symbol(:@a) = :@a
    @a$114: T.untyped = <cfgAlias>$192: T.class_of(<Magic>).<suggest-field-type>(<statTemp>$193: T.untyped, <statTemp>$196: String("singleton class instance"), <statTemp>$197: String("main"), <statTemp>$198: Symbol(:@a))
    <cfgAlias>$201: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$204: Integer(1) = 1
    <statTemp>$202: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$204: Integer(1))
    <statTemp>$205: String("class") = "class"
    <statTemp>$206: String("main") = "main"
    <statTemp>$207: Symbol(:@@b) = :@@b
    @@b$124: T.untyped = <cfgAlias>$201: T.class_of(<Magic>).<suggest-field-type>(<statTemp>$202: T.untyped, <statTemp>$205: String("class"), <statTemp>$206: String("main"), <statTemp>$207: Symbol(:@@b))
    <statTemp>$210: Integer(2) = 2
    $c$134: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$210: Integer(2))
    <statTemp>$213: Integer(3) = 3
    d$6: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$213: Integer(3))
    <cfgAlias>$216: T.class_of(E) = alias <C E>
    <statTemp>$219: Integer(4) = 4
    <statTemp>$217: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$219: Integer(4))
    <statTemp>$214: T.untyped = <cfgAlias>$216: T.class_of(E).e=(<statTemp>$217: T.untyped)
    <cfgAlias>$222: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$224: Integer(5) = 5
    <statTemp>$220: T.untyped = <cfgAlias>$222: T.class_of(<Magic>).<mlhs use all>(<assignTemp>$9$6: T.untyped, <statTemp>$224: Integer(5))
    <statTemp>$227: T.untyped = @a$114: T.untyped.inspect()
    <statTemp>$225: NilClass = <self>: T.class_of(Main).puts(<statTemp>$227: T.untyped)
    <statTemp>$231: T.untyped = @@b$124: T.untyped.inspect()
    <statTemp>$229: NilClass = <self>: T.class_of(Main).puts(<statTemp>$231: T.untyped)
    <statTemp>$235: T.untyped = $c$134: T.untyped.inspect()
    <statTemp>$233: NilClass = <self>: T.class_of(Main).puts(<statTemp>$235: T.untyped)
    <statTemp>$239: T.untyped = d$6: T.untyped.inspect()
    <statTemp>$237: NilClass = <self>: T.class_of(Main).puts(<statTemp>$239: T.untyped)
    <cfgAlias>$245: T.class_of(E) = alias <C E>
    <statTemp>$243: T.untyped = <cfgAlias>$245: T.class_of(E).e()
    <statTemp>$242: T.untyped = <statTemp>$243: T.untyped.inspect()
    <blockReturnTemp>$178: NilClass = <self>: T.class_of(Main).puts(<statTemp>$242: T.untyped)
    <blockReturnTemp>$246: T.noreturn = blockreturn<each> <blockReturnTemp>$178: NilClass
    <unconditional> -> bb22

}

method ::<Class:Main>#<static-init> {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: T.class_of(Main) = cast(<self>: NilClass, T.class_of(Main));
    <returnMethodTemp>$2: Symbol(:main) = :main
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:main)
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

