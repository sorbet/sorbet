method ::<Class:<root>>#<static-init> {

bb0[rubyRegionId=0, firstDead=13]():
    <self>: T.class_of(<root>) = cast(<self>: NilClass, T.class_of(<root>));
    <cfgAlias>$7: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$9: T.class_of(A) = alias <C A>
    <statTemp>$5: Sorbet::Private::Static::Void = <cfgAlias>$7: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$9: T.class_of(A))
    <cfgAlias>$14: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$16: T.class_of(E) = alias <C E>
    <statTemp>$12: Sorbet::Private::Static::Void = <cfgAlias>$14: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$16: T.class_of(E))
    <cfgAlias>$21: T.class_of(Sorbet::Private::Static) = alias <C Static>
    <cfgAlias>$23: T.class_of(Main) = alias <C Main>
    <statTemp>$19: Sorbet::Private::Static::Void = <cfgAlias>$21: T.class_of(Sorbet::Private::Static).keep_for_ide(<cfgAlias>$23: T.class_of(Main))
    <cfgAlias>$26: T.class_of(Main) = alias <C Main>
    <statTemp>$24: T.untyped = <cfgAlias>$26: T.class_of(Main).main()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:A>#each {

bb0[rubyRegionId=0, firstDead=15]():
    <self>: T.class_of(A) = cast(<self>: NilClass, T.class_of(A));
    blk: T.untyped = load_arg(blk)
    <statTemp>$5: Integer(1) = 1
    <statTemp>$6: Integer(2) = 2
    <statTemp>$7: Integer(3) = 3
    <statTemp>$8: Integer(4) = 4
    <statTemp>$9: Integer(5) = 5
    <statTemp>$3: T.untyped = blk: T.untyped.call(<statTemp>$5: Integer(1), <statTemp>$6: Integer(2), <statTemp>$7: Integer(3), <statTemp>$8: Integer(4), <statTemp>$9: Integer(5))
    <statTemp>$11: Integer(6) = 6
    <statTemp>$12: Integer(7) = 7
    <statTemp>$13: Integer(8) = 8
    <statTemp>$14: Integer(9) = 9
    <statTemp>$15: Integer(0) = 0
    <returnMethodTemp>$2: T.untyped = blk: T.untyped.call(<statTemp>$11: Integer(6), <statTemp>$12: Integer(7), <statTemp>$13: Integer(8), <statTemp>$14: Integer(9), <statTemp>$15: Integer(0))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:A>#<static-init> {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: T.class_of(A) = cast(<self>: NilClass, T.class_of(A));
    <returnMethodTemp>$2: Symbol(:each) = :each
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:each)
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:E>#e= {

bb0[rubyRegionId=0, firstDead=6]():
    @e$3: T.untyped = alias <C <undeclared-field-stub>> (@e)
    <self>: T.class_of(E) = cast(<self>: NilClass, T.class_of(E));
    e: T.untyped = load_arg(e)
    @e$3: T.untyped = e
    <returnMethodTemp>$2: T.untyped = @e$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:E>#e {

bb0[rubyRegionId=0, firstDead=4]():
    @e$3: T.untyped = alias <C <undeclared-field-stub>> (@e)
    <self>: T.class_of(E) = cast(<self>: NilClass, T.class_of(E));
    <returnMethodTemp>$2: T.untyped = @e$3
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:E>#<static-init> {

bb0[rubyRegionId=0, firstDead=2]():
    <self>: T.class_of(E) = cast(<self>: NilClass, T.class_of(E));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Main>#main {

bb0[rubyRegionId=0, firstDead=-1]():
    @a$105: T.untyped = alias <C <undeclared-field-stub>> (@a)
    @@b$109: T.untyped = alias <C <undeclared-field-stub>> (@@b)
    $c$113: T.untyped = alias <C <undeclared-field-stub>> ($c)
    <self>: T.class_of(Main) = cast(<self>: NilClass, T.class_of(Main));
    <cfgAlias>$5: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$6: Sorbet::Private::Static::Void = <cfgAlias>$5: T.class_of(A).each()
    <selfRestore>$7: T.class_of(Main) = <self>
    <unconditional> -> bb2

# backedges
# - bb23(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
# - bb5(rubyRegionId=1)
bb2[rubyRegionId=1, firstDead=-1](<self>: T.class_of(Main), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2(rubyRegionId=1)
bb3[rubyRegionId=0, firstDead=-1](<block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    <statTemp>$3: T.untyped = Solve<<block-pre-call-temp>$6, each>
    <self>: T.class_of(Main) = <selfRestore>$7
    <cfgAlias>$16: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$17: Sorbet::Private::Static::Void = <cfgAlias>$16: T.class_of(A).each()
    <selfRestore>$18: T.class_of(Main) = <self>
    <unconditional> -> bb6

# backedges
# - bb2(rubyRegionId=1)
bb5[rubyRegionId=1, firstDead=6](<self>: T.class_of(Main), <block-pre-call-temp>$6: Sorbet::Private::Static::Void, <selfRestore>$7: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <blk>$8: T.untyped = load_yield_params(each)
    a$1: T.untyped = yield_load_arg(0, <blk>$8: T.untyped)
    <statTemp>$11: T.untyped = a$1: T.untyped.inspect()
    <blockReturnTemp>$9: NilClass = <self>: T.class_of(Main).puts(<statTemp>$11: T.untyped)
    <blockReturnTemp>$13: T.noreturn = blockreturn<each> <blockReturnTemp>$9: NilClass
    <unconditional> -> bb2

# backedges
# - bb3(rubyRegionId=0)
# - bb9(rubyRegionId=2)
bb6[rubyRegionId=2, firstDead=-1](<self>: T.class_of(Main), <block-pre-call-temp>$17: Sorbet::Private::Static::Void, <selfRestore>$18: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb9 : bb7)

# backedges
# - bb6(rubyRegionId=2)
bb7[rubyRegionId=0, firstDead=-1](<block-pre-call-temp>$17: Sorbet::Private::Static::Void, <selfRestore>$18: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    <statTemp>$14: T.untyped = Solve<<block-pre-call-temp>$17, each>
    <self>: T.class_of(Main) = <selfRestore>$18
    <cfgAlias>$41: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$42: Sorbet::Private::Static::Void = <cfgAlias>$41: T.class_of(A).each()
    <selfRestore>$43: T.class_of(Main) = <self>
    <unconditional> -> bb10

# backedges
# - bb6(rubyRegionId=2)
bb9[rubyRegionId=2, firstDead=14](<self>: T.class_of(Main), <block-pre-call-temp>$17: Sorbet::Private::Static::Void, <selfRestore>$18: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <blk>$19: T.untyped = load_yield_params(each)
    forTemp$2: T.untyped = yield_load_arg(0, <blk>$19: T.untyped)
    <cfgAlias>$24: T.class_of(<Magic>) = alias <C <Magic>>
    <assignTemp>$2$2: T.untyped = <cfgAlias>$24: T.class_of(<Magic>).<splat>(forTemp$2: T.untyped)
    <cfgAlias>$28: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$30: Integer(1) = 1
    <statTemp>$31: Integer(0) = 0
    <assignTemp>$3$2: T.untyped = <cfgAlias>$28: T.class_of(<Magic>).<expand-splat>(<assignTemp>$2$2: T.untyped, <statTemp>$30: Integer(1), <statTemp>$31: Integer(0))
    <statTemp>$34: Integer(0) = 0
    a$2: T.untyped = <assignTemp>$3$2: T.untyped.[](<statTemp>$34: Integer(0))
    <statTemp>$36: T.untyped = a$2: T.untyped.inspect()
    <blockReturnTemp>$20: NilClass = <self>: T.class_of(Main).puts(<statTemp>$36: T.untyped)
    <blockReturnTemp>$38: T.noreturn = blockreturn<each> <blockReturnTemp>$20: NilClass
    <unconditional> -> bb6

# backedges
# - bb7(rubyRegionId=0)
# - bb13(rubyRegionId=3)
bb10[rubyRegionId=3, firstDead=-1](<self>: T.class_of(Main), <block-pre-call-temp>$42: Sorbet::Private::Static::Void, <selfRestore>$43: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb13 : bb11)

# backedges
# - bb10(rubyRegionId=3)
bb11[rubyRegionId=0, firstDead=-1](<block-pre-call-temp>$42: Sorbet::Private::Static::Void, <selfRestore>$43: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    <statTemp>$39: T.untyped = Solve<<block-pre-call-temp>$42, each>
    <self>: T.class_of(Main) = <selfRestore>$43
    <cfgAlias>$56: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$57: Sorbet::Private::Static::Void = <cfgAlias>$56: T.class_of(A).each()
    <selfRestore>$58: T.class_of(Main) = <self>
    <unconditional> -> bb14

# backedges
# - bb10(rubyRegionId=3)
bb13[rubyRegionId=3, firstDead=9](<self>: T.class_of(Main), <block-pre-call-temp>$42: Sorbet::Private::Static::Void, <selfRestore>$43: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <blk>$44: T.untyped = load_yield_params(each)
    a$3: T.untyped = yield_load_arg(0, <blk>$44: T.untyped)
    b$3: T.untyped = yield_load_arg(1, <blk>$44: T.untyped)
    <statTemp>$48: T.untyped = a$3: T.untyped.inspect()
    <statTemp>$46: NilClass = <self>: T.class_of(Main).puts(<statTemp>$48: T.untyped)
    <statTemp>$51: T.untyped = b$3: T.untyped.inspect()
    <blockReturnTemp>$45: NilClass = <self>: T.class_of(Main).puts(<statTemp>$51: T.untyped)
    <blockReturnTemp>$53: T.noreturn = blockreturn<each> <blockReturnTemp>$45: NilClass
    <unconditional> -> bb10

# backedges
# - bb11(rubyRegionId=0)
# - bb17(rubyRegionId=4)
bb14[rubyRegionId=4, firstDead=-1](<self>: T.class_of(Main), <block-pre-call-temp>$57: Sorbet::Private::Static::Void, <selfRestore>$58: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb17 : bb15)

# backedges
# - bb14(rubyRegionId=4)
bb15[rubyRegionId=0, firstDead=-1](<block-pre-call-temp>$57: Sorbet::Private::Static::Void, <selfRestore>$58: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    <statTemp>$54: T.untyped = Solve<<block-pre-call-temp>$57, each>
    <self>: T.class_of(Main) = <selfRestore>$58
    <statTemp>$88: String("main") = "main"
    <statTemp>$86: NilClass = <self>: T.class_of(Main).puts(<statTemp>$88: String("main"))
    <cfgAlias>$91: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$92: Sorbet::Private::Static::Void = <cfgAlias>$91: T.class_of(A).each()
    <selfRestore>$93: T.class_of(Main) = <self>
    <unconditional> -> bb18

# backedges
# - bb14(rubyRegionId=4)
bb17[rubyRegionId=4, firstDead=18](<self>: T.class_of(Main), <block-pre-call-temp>$57: Sorbet::Private::Static::Void, <selfRestore>$58: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <blk>$59: T.untyped = load_yield_params(each)
    forTemp$4: T.untyped = yield_load_arg(0, <blk>$59: T.untyped)
    <cfgAlias>$64: T.class_of(<Magic>) = alias <C <Magic>>
    <assignTemp>$4$4: T.untyped = <cfgAlias>$64: T.class_of(<Magic>).<splat>(forTemp$4: T.untyped)
    <cfgAlias>$68: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$70: Integer(2) = 2
    <statTemp>$71: Integer(0) = 0
    <assignTemp>$5$4: T.untyped = <cfgAlias>$68: T.class_of(<Magic>).<expand-splat>(<assignTemp>$4$4: T.untyped, <statTemp>$70: Integer(2), <statTemp>$71: Integer(0))
    <statTemp>$74: Integer(0) = 0
    a$4: T.untyped = <assignTemp>$5$4: T.untyped.[](<statTemp>$74: Integer(0))
    <statTemp>$77: Integer(1) = 1
    b$4: T.untyped = <assignTemp>$5$4: T.untyped.[](<statTemp>$77: Integer(1))
    <statTemp>$80: T.untyped = a$4: T.untyped.inspect()
    <statTemp>$78: NilClass = <self>: T.class_of(Main).puts(<statTemp>$80: T.untyped)
    <statTemp>$83: T.untyped = b$4: T.untyped.inspect()
    <blockReturnTemp>$60: NilClass = <self>: T.class_of(Main).puts(<statTemp>$83: T.untyped)
    <blockReturnTemp>$85: T.noreturn = blockreturn<each> <blockReturnTemp>$60: NilClass
    <unconditional> -> bb14

# backedges
# - bb15(rubyRegionId=0)
# - bb21(rubyRegionId=5)
bb18[rubyRegionId=5, firstDead=-1](<self>: T.class_of(Main), <block-pre-call-temp>$92: Sorbet::Private::Static::Void, <selfRestore>$93: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb21 : bb19)

# backedges
# - bb18(rubyRegionId=5)
bb19[rubyRegionId=0, firstDead=-1](<block-pre-call-temp>$92: Sorbet::Private::Static::Void, <selfRestore>$93: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    <statTemp>$89: T.untyped = Solve<<block-pre-call-temp>$92, each>
    <self>: T.class_of(Main) = <selfRestore>$93
    <cfgAlias>$148: T.class_of(A) = alias <C A>
    <block-pre-call-temp>$149: Sorbet::Private::Static::Void = <cfgAlias>$148: T.class_of(A).each()
    <selfRestore>$150: T.class_of(Main) = <self>
    <unconditional> -> bb22

# backedges
# - bb18(rubyRegionId=5)
bb21[rubyRegionId=5, firstDead=30](<self>: T.class_of(Main), <block-pre-call-temp>$92: Sorbet::Private::Static::Void, <selfRestore>$93: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <cfgAlias>$100: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$102: Integer(5) = 5
    <statTemp>$103: Integer(0) = 0
    <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass] = <cfgAlias>$100: T.class_of(<Magic>).<expand-splat>(forTemp$6$5: NilClass, <statTemp>$102: Integer(5), <statTemp>$103: Integer(0))
    <statTemp>$107: Integer(0) = 0
    @a$105: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$107: Integer(0))
    <statTemp>$111: Integer(1) = 1
    @@b$109: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$111: Integer(1))
    <statTemp>$115: Integer(2) = 2
    $c$113: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$115: Integer(2))
    <statTemp>$118: Integer(3) = 3
    d$5: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$118: Integer(3))
    <cfgAlias>$121: T.class_of(E) = alias <C E>
    <statTemp>$124: Integer(4) = 4
    <statTemp>$122: NilClass = <assignTemp>$8$5: [NilClass, NilClass, NilClass, NilClass, NilClass].[](<statTemp>$124: Integer(4))
    <statTemp>$119: NilClass = <cfgAlias>$121: T.class_of(E).e=(<statTemp>$122: NilClass)
    <statTemp>$127: T.untyped = @a$105: NilClass.inspect()
    <statTemp>$125: NilClass = <self>: T.class_of(Main).puts(<statTemp>$127: T.untyped)
    <statTemp>$131: T.untyped = @@b$109: NilClass.inspect()
    <statTemp>$129: NilClass = <self>: T.class_of(Main).puts(<statTemp>$131: T.untyped)
    <statTemp>$135: T.untyped = $c$113: NilClass.inspect()
    <statTemp>$133: NilClass = <self>: T.class_of(Main).puts(<statTemp>$135: T.untyped)
    <statTemp>$139: T.untyped = d$5: NilClass.inspect()
    <statTemp>$137: NilClass = <self>: T.class_of(Main).puts(<statTemp>$139: T.untyped)
    <cfgAlias>$145: T.class_of(E) = alias <C E>
    <statTemp>$143: T.untyped = <cfgAlias>$145: T.class_of(E).e()
    <statTemp>$142: T.untyped = <statTemp>$143: T.untyped.inspect()
    <blockReturnTemp>$95: NilClass = <self>: T.class_of(Main).puts(<statTemp>$142: T.untyped)
    <blockReturnTemp>$146: T.noreturn = blockreturn<each> <blockReturnTemp>$95: NilClass
    <unconditional> -> bb18

# backedges
# - bb19(rubyRegionId=0)
# - bb25(rubyRegionId=6)
bb22[rubyRegionId=6, firstDead=-1](<self>: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped, <block-pre-call-temp>$149: Sorbet::Private::Static::Void, <selfRestore>$150: T.class_of(Main)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb25 : bb23)

# backedges
# - bb22(rubyRegionId=6)
bb23[rubyRegionId=0, firstDead=2](<block-pre-call-temp>$149: Sorbet::Private::Static::Void, <selfRestore>$150: T.class_of(Main)):
    <returnMethodTemp>$2: T.untyped = Solve<<block-pre-call-temp>$149, each>
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb22(rubyRegionId=6)
bb25[rubyRegionId=6, firstDead=34](<self>: T.class_of(Main), @a$105: T.untyped, @@b$109: T.untyped, $c$113: T.untyped, <block-pre-call-temp>$149: Sorbet::Private::Static::Void, <selfRestore>$150: T.class_of(Main)):
    # outerLoops: 1
    <self>: T.class_of(Main) = loadSelf(each)
    <blk>$151: T.untyped = load_yield_params(each)
    forTemp$6: T.untyped = yield_load_arg(0, <blk>$151: T.untyped)
    <cfgAlias>$156: T.class_of(<Magic>) = alias <C <Magic>>
    <assignTemp>$9$6: T.untyped = <cfgAlias>$156: T.class_of(<Magic>).<splat>(forTemp$6: T.untyped)
    <cfgAlias>$160: T.class_of(<Magic>) = alias <C <Magic>>
    <statTemp>$162: Integer(5) = 5
    <statTemp>$163: Integer(0) = 0
    <assignTemp>$10$6: T.untyped = <cfgAlias>$160: T.class_of(<Magic>).<expand-splat>(<assignTemp>$9$6: T.untyped, <statTemp>$162: Integer(5), <statTemp>$163: Integer(0))
    <statTemp>$166: Integer(0) = 0
    @a$105: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$166: Integer(0))
    <statTemp>$169: Integer(1) = 1
    @@b$109: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$169: Integer(1))
    <statTemp>$172: Integer(2) = 2
    $c$113: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$172: Integer(2))
    <statTemp>$175: Integer(3) = 3
    d$6: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$175: Integer(3))
    <cfgAlias>$178: T.class_of(E) = alias <C E>
    <statTemp>$181: Integer(4) = 4
    <statTemp>$179: T.untyped = <assignTemp>$10$6: T.untyped.[](<statTemp>$181: Integer(4))
    <statTemp>$176: T.untyped = <cfgAlias>$178: T.class_of(E).e=(<statTemp>$179: T.untyped)
    <statTemp>$184: T.untyped = @a$105: T.untyped.inspect()
    <statTemp>$182: NilClass = <self>: T.class_of(Main).puts(<statTemp>$184: T.untyped)
    <statTemp>$188: T.untyped = @@b$109: T.untyped.inspect()
    <statTemp>$186: NilClass = <self>: T.class_of(Main).puts(<statTemp>$188: T.untyped)
    <statTemp>$192: T.untyped = $c$113: T.untyped.inspect()
    <statTemp>$190: NilClass = <self>: T.class_of(Main).puts(<statTemp>$192: T.untyped)
    <statTemp>$196: T.untyped = d$6: T.untyped.inspect()
    <statTemp>$194: NilClass = <self>: T.class_of(Main).puts(<statTemp>$196: T.untyped)
    <cfgAlias>$202: T.class_of(E) = alias <C E>
    <statTemp>$200: T.untyped = <cfgAlias>$202: T.class_of(E).e()
    <statTemp>$199: T.untyped = <statTemp>$200: T.untyped.inspect()
    <blockReturnTemp>$152: NilClass = <self>: T.class_of(Main).puts(<statTemp>$199: T.untyped)
    <blockReturnTemp>$203: T.noreturn = blockreturn<each> <blockReturnTemp>$152: NilClass
    <unconditional> -> bb22

}

method ::<Class:Main>#<static-init> {

bb0[rubyRegionId=0, firstDead=3]():
    <self>: T.class_of(Main) = cast(<self>: NilClass, T.class_of(Main));
    <returnMethodTemp>$2: Symbol(:main) = :main
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol(:main)
    <unconditional> -> bb1

# backedges
# - bb0(rubyRegionId=0)
bb1[rubyRegionId=0, firstDead=-1]():
    <unconditional> -> bb1

}

