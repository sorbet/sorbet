begin
  class <emptyTree><<C <U <root>>>> < ()
    <emptyTree>

    <emptyTree>

    def <U main><<U main>>(<blk>)
      begin
        self(<C <U Object>>).<U puts>(::A.<U a>())
        self(<C <U Object>>).<U puts>(::B.<U b>())
        self(<C <U Object>>).<U puts>(#$c.<U c>())
        self(<C <U Object>>).<U puts>(::D.<U singleton_class>().<U d>())
        self(<C <U Object>>).<U puts>(::E.<U e>())
        self(<C <U Object>>).<U puts>(::F.<U f=>(91))
        self(<C <U Object>>).<U puts>(::G.<U new>().<U wrapper>())
        self(<C <U Object>>).<U puts>(::T.untyped.<U h>())
      end
    end

    def self.<U <static-init>><<N <U <static-init>> $3>>(<blk>)
      begin
        begin
          ::RubyTyper.<U keep_for_ide>(::A)
          <emptyTree>
        end
        begin
          ::RubyTyper.<U keep_for_ide>(::B)
          <emptyTree>
        end
        #$c = ::Object.<U new>()
        begin
          ::RubyTyper.<U keep_for_ide>(::D)
          <emptyTree>
        end
        begin
          ::RubyTyper.<U keep_for_ide>(::E)
          <emptyTree>
        end
        begin
          ::RubyTyper.<U keep_for_ide>(::F)
          <emptyTree>
        end
        begin
          ::RubyTyper.<U keep_for_ide>(::G)
          <emptyTree>
        end
        begin
          ::RubyTyper.<U keep_for_ide>(::H)
          <emptyTree>
        end
        self(<S <C <U <root>>> $1>).<U main>()
        <emptyTree>
      end
    end
  end
  class ::A<<C <U A>>> < (::<todo sym>)  end
  class ::B<<C <U B>>> < (::<todo sym>)
    <emptyTree>
  end
  class <U <singleton class>><<S <C <U B>> $1>> < ()
    def <U b><<U b>>(<blk>)
      "b"
    end
  end
  class ::D<<C <U D>>> < (::<todo sym>)
    <emptyTree>
  end
  class <U <singleton class>><<S <C <U D>> $1>> < ()
    <emptyTree>
  end
  class <U <singleton class>><<S <S <C <U D>> $1> $1>> < ()
    def <U d><<U d>>(<blk>)
      "d"
    end
  end
  class ::E<<C <U E>>> < (::<todo sym>)
    <emptyTree>

    <emptyTree>

    def self.<U <static-init>><<U <static-init>>>(<blk>)
      self(<S <C <U E>> $1>).<U wrapper>()
    end
  end
  class <U <singleton class>><<S <C <U E>> $1>> < ()
    <emptyTree>

    def <U wrapper><<U wrapper>>(<blk>)
      <emptyTree>
    end

    def <U e><<U e>>(<blk>)
      "e"
    end
  end
  class ::F<<C <U F>>> < (::<todo sym>)
    <emptyTree>
  end
  class <U <singleton class>><<S <C <U F>> $1>> < ()
    <emptyTree>

    <emptyTree>

    <emptyTree>

    def <U initialize><<U initialize>>(<blk>)
      <U @f> = begin
        ::RubyTyper.<U keep_for_typechecking>(::Integer)
        T.<U let>(0, Integer)
      end
    end

    def <U f=><<U f=>>(f, <blk>)
      <U @f> = <U f>
    end

    def self.<U <static-init>><<U <static-init>>>(<blk>)
      self(<S <S <C <U F>> $1> $1>).<U sig>() do ||
        self(<C <U Builder>>).<U params>({:"f" => ::Integer}).<U returns>(::Integer)
      end
    end
  end
  class ::G<<C <U G>>> < (::<todo sym>)
    <emptyTree>

    <emptyTree>

    def <U wrapper><<U wrapper>>(<blk>)
      begin
        <emptyTree>
        self(<C <U G>>).<U inner>()
      end
    end

    def self.<U g><<U g>>(<blk>)
      "g"
    end
  end
  class <U <singleton class>><<S <C <U G>> $1>> < ()
    def <U inner><<U inner>>(<blk>)
      ::T.<U reveal_type>(self(<S <C <U G>> $1>))
    end
  end
  class ::H<<C <U H>>> < (::<todo sym>)
    <emptyTree>
  end
  class <U <singleton class>><<S <C <U H>> $1>> < ()
    def self.<U <static-init>><<U <static-init>>>(<blk>)
      begin
        ::RubyTyper.<U keep_for_ide>(::<Class:H>::H2)
        <emptyTree>
      end
    end
  end
  class ::<Class:H>::H2<<C <U H2>>> < (::<todo sym>)
    def self.<U h><<U h>>(<blk>)
      "h"
    end
  end
  <emptyTree>
end
