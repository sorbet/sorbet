method ::<Class:<root>>#<static-init> {

bb0[firstDead=2]():
    <self>: T.class_of(<root>) = cast(<self>: NilClass, T.class_of(<root>));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Funcs#f {

bb0[firstDead=4]():
    <self>: Funcs = cast(<self>: NilClass, Funcs);
    x: Integer = load_arg(x)
    <returnMethodTemp>$2: Integer = x
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Integer
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Funcs>#f {

bb0[firstDead=2]():
    <self>: T.class_of(Funcs) = cast(<self>: NilClass, T.class_of(Funcs));
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Funcs#g {

bb0[firstDead=4]():
    <self>: Funcs = cast(<self>: NilClass, Funcs);
    s: Symbol = load_arg(s)
    <returnMethodTemp>$2: Symbol = s
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Funcs>#g {

bb0[firstDead=4]():
    <self>: T.class_of(Funcs) = cast(<self>: NilClass, T.class_of(Funcs));
    s: Symbol = load_arg(s)
    <returnMethodTemp>$2: Symbol = s
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: Symbol
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::Funcs#h {

bb0[firstDead=4]():
    <self>: Funcs = cast(<self>: NilClass, Funcs);
    s: String = load_arg(s)
    <returnMethodTemp>$2: String = s
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Funcs>#h {

bb0[firstDead=4]():
    <self>: T.class_of(Funcs) = cast(<self>: NilClass, T.class_of(Funcs));
    s: String = load_arg(s)
    <returnMethodTemp>$2: String = s
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: String
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:Funcs>#<static-init> {

bb0[firstDead=-1]():
    <self>: T.class_of(Funcs) = cast(<self>: NilClass, T.class_of(Funcs));
    <block-pre-call-temp>$5: Sorbet::Private::Static::Void = <self>: T.class_of(Funcs).sig()
    <selfRestore>$6: T.class_of(Funcs) = <self>
    <unconditional> -> bb2

# backedges
# - bb19
bb1[firstDead=-1]():
    <unconditional> -> bb1

# backedges
# - bb0
# - bb5
bb2[firstDead=-1](<self>: T.class_of(Funcs), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Funcs)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb5 : bb3)

# backedges
# - bb2
bb3[firstDead=-1](<block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Funcs)):
    <statTemp>$3: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$5, sig>
    <self>: T.class_of(Funcs) = <selfRestore>$6
    <block-pre-call-temp>$18: Sorbet::Private::Static::Void = <self>: T.class_of(Funcs).sig()
    <selfRestore>$19: T.class_of(Funcs) = <self>
    <unconditional> -> bb6

# backedges
# - bb2
bb5[firstDead=7](<self>: T.class_of(Funcs), <block-pre-call-temp>$5: Sorbet::Private::Static::Void, <selfRestore>$6: T.class_of(Funcs)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$10: Symbol(:x) = :x
    <cfgAlias>$12: T.class_of(Integer) = alias <C Integer>
    <statTemp>$8: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$10: Symbol(:x), <cfgAlias>$12: T.class_of(Integer))
    <cfgAlias>$14: T.class_of(Integer) = alias <C Integer>
    <blockReturnTemp>$7: T::Private::Methods::DeclBuilder = <statTemp>$8: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$14: T.class_of(Integer))
    <blockReturnTemp>$15: T.noreturn = blockreturn<sig> <blockReturnTemp>$7: T::Private::Methods::DeclBuilder
    <unconditional> -> bb2

# backedges
# - bb3
# - bb9
bb6[firstDead=-1](<self>: T.class_of(Funcs), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Funcs)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb9 : bb7)

# backedges
# - bb6
bb7[firstDead=-1](<block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Funcs)):
    <statTemp>$16: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$18, sig>
    <self>: T.class_of(Funcs) = <selfRestore>$19
    <block-pre-call-temp>$31: Sorbet::Private::Static::Void = <self>: T.class_of(Funcs).sig()
    <selfRestore>$32: T.class_of(Funcs) = <self>
    <unconditional> -> bb10

# backedges
# - bb6
bb9[firstDead=7](<self>: T.class_of(Funcs), <block-pre-call-temp>$18: Sorbet::Private::Static::Void, <selfRestore>$19: T.class_of(Funcs)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$23: Symbol(:s) = :s
    <cfgAlias>$25: T.class_of(Symbol) = alias <C Symbol>
    <statTemp>$21: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$23: Symbol(:s), <cfgAlias>$25: T.class_of(Symbol))
    <cfgAlias>$27: T.class_of(Symbol) = alias <C Symbol>
    <blockReturnTemp>$20: T::Private::Methods::DeclBuilder = <statTemp>$21: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$27: T.class_of(Symbol))
    <blockReturnTemp>$28: T.noreturn = blockreturn<sig> <blockReturnTemp>$20: T::Private::Methods::DeclBuilder
    <unconditional> -> bb6

# backedges
# - bb7
# - bb13
bb10[firstDead=-1](<self>: T.class_of(Funcs), <block-pre-call-temp>$31: Sorbet::Private::Static::Void, <selfRestore>$32: T.class_of(Funcs)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb13 : bb11)

# backedges
# - bb10
bb11[firstDead=-1](<block-pre-call-temp>$31: Sorbet::Private::Static::Void, <selfRestore>$32: T.class_of(Funcs)):
    <statTemp>$29: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$31, sig>
    <self>: T.class_of(Funcs) = <selfRestore>$32
    <block-pre-call-temp>$44: Sorbet::Private::Static::Void = <self>: T.class_of(Funcs).sig()
    <selfRestore>$45: T.class_of(Funcs) = <self>
    <unconditional> -> bb14

# backedges
# - bb10
bb13[firstDead=7](<self>: T.class_of(Funcs), <block-pre-call-temp>$31: Sorbet::Private::Static::Void, <selfRestore>$32: T.class_of(Funcs)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$36: Symbol(:s) = :s
    <cfgAlias>$38: T.class_of(Symbol) = alias <C Symbol>
    <statTemp>$34: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$36: Symbol(:s), <cfgAlias>$38: T.class_of(Symbol))
    <cfgAlias>$40: T.class_of(Symbol) = alias <C Symbol>
    <blockReturnTemp>$33: T::Private::Methods::DeclBuilder = <statTemp>$34: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$40: T.class_of(Symbol))
    <blockReturnTemp>$41: T.noreturn = blockreturn<sig> <blockReturnTemp>$33: T::Private::Methods::DeclBuilder
    <unconditional> -> bb10

# backedges
# - bb11
# - bb17
bb14[firstDead=-1](<self>: T.class_of(Funcs), <block-pre-call-temp>$44: Sorbet::Private::Static::Void, <selfRestore>$45: T.class_of(Funcs)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb17 : bb15)

# backedges
# - bb14
bb15[firstDead=-1](<block-pre-call-temp>$44: Sorbet::Private::Static::Void, <selfRestore>$45: T.class_of(Funcs)):
    <statTemp>$42: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$44, sig>
    <self>: T.class_of(Funcs) = <selfRestore>$45
    <block-pre-call-temp>$57: Sorbet::Private::Static::Void = <self>: T.class_of(Funcs).sig()
    <selfRestore>$58: T.class_of(Funcs) = <self>
    <unconditional> -> bb18

# backedges
# - bb14
bb17[firstDead=7](<self>: T.class_of(Funcs), <block-pre-call-temp>$44: Sorbet::Private::Static::Void, <selfRestore>$45: T.class_of(Funcs)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$49: Symbol(:s) = :s
    <cfgAlias>$51: T.class_of(String) = alias <C String>
    <statTemp>$47: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$49: Symbol(:s), <cfgAlias>$51: T.class_of(String))
    <cfgAlias>$53: T.class_of(String) = alias <C String>
    <blockReturnTemp>$46: T::Private::Methods::DeclBuilder = <statTemp>$47: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$53: T.class_of(String))
    <blockReturnTemp>$54: T.noreturn = blockreturn<sig> <blockReturnTemp>$46: T::Private::Methods::DeclBuilder
    <unconditional> -> bb14

# backedges
# - bb15
# - bb21
bb18[firstDead=-1](<self>: T.class_of(Funcs), <block-pre-call-temp>$57: Sorbet::Private::Static::Void, <selfRestore>$58: T.class_of(Funcs)):
    # outerLoops: 1
    <block-call> -> (NilClass ? bb21 : bb19)

# backedges
# - bb18
bb19[firstDead=12](<block-pre-call-temp>$57: Sorbet::Private::Static::Void, <selfRestore>$58: T.class_of(Funcs)):
    <statTemp>$55: Sorbet::Private::Static::Void = Solve<<block-pre-call-temp>$57, sig>
    <self>: T.class_of(Funcs) = <selfRestore>$58
    <cfgAlias>$71: T.class_of(T::Sig) = alias <C Sig>
    <cfgAlias>$73: T.class_of(T) = alias <C T>
    <statTemp>$68: T.class_of(Funcs) = <self>: T.class_of(Funcs).extend(<cfgAlias>$71: T.class_of(T::Sig))
    <statTemp>$77: Symbol(:f) = :f
    <statTemp>$75: T.class_of(Funcs) = <self>: T.class_of(Funcs).private(<statTemp>$77: Symbol(:f))
    <statTemp>$81: Symbol(:g) = :g
    <statTemp>$79: T.class_of(Funcs) = <self>: T.class_of(Funcs).private(<statTemp>$81: Symbol(:g))
    <statTemp>$85: Symbol(:h) = :h
    <statTemp>$83: T.class_of(Funcs) = <self>: T.class_of(Funcs).private(<statTemp>$85: Symbol(:h))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb18
bb21[firstDead=7](<self>: T.class_of(Funcs), <block-pre-call-temp>$57: Sorbet::Private::Static::Void, <selfRestore>$58: T.class_of(Funcs)):
    # outerLoops: 1
    <self>: T::Private::Methods::DeclBuilder = loadSelf(sig)
    <hashTemp>$62: Symbol(:s) = :s
    <cfgAlias>$64: T.class_of(String) = alias <C String>
    <statTemp>$60: T::Private::Methods::DeclBuilder = <self>: T::Private::Methods::DeclBuilder.params(<hashTemp>$62: Symbol(:s), <cfgAlias>$64: T.class_of(String))
    <cfgAlias>$66: T.class_of(String) = alias <C String>
    <blockReturnTemp>$59: T::Private::Methods::DeclBuilder = <statTemp>$60: T::Private::Methods::DeclBuilder.returns(<cfgAlias>$66: T.class_of(String))
    <blockReturnTemp>$67: T.noreturn = blockreturn<sig> <blockReturnTemp>$59: T::Private::Methods::DeclBuilder
    <unconditional> -> bb18

}

method ::C#test_calls {

bb0[firstDead=19]():
    <self>: C = cast(<self>: NilClass, C);
    <statTemp>$5: Integer(0) = 0
    <statTemp>$3: Integer = <self>: C.f(<statTemp>$5: Integer(0))
    <cfgAlias>$8: T.class_of(Funcs) = alias <C Funcs>
    <statTemp>$9: Integer(0) = 0
    <statTemp>$6: T.untyped = <cfgAlias>$8: T.class_of(Funcs).f(<statTemp>$9: Integer(0))
    <statTemp>$12: Symbol(:f) = :f
    <statTemp>$10: Symbol = <self>: C.g(<statTemp>$12: Symbol(:f))
    <cfgAlias>$15: T.class_of(Funcs) = alias <C Funcs>
    <statTemp>$16: Symbol(:f) = :f
    <statTemp>$13: Symbol = <cfgAlias>$15: T.class_of(Funcs).g(<statTemp>$16: Symbol(:f))
    <statTemp>$19: String("hello") = "hello"
    <statTemp>$17: String = <self>: C.h(<statTemp>$19: String("hello"))
    <cfgAlias>$22: T.class_of(Funcs) = alias <C Funcs>
    <statTemp>$23: String("world") = "world"
    <statTemp>$20: String = <cfgAlias>$22: T.class_of(Funcs).h(<statTemp>$23: String("world"))
    <cfgAlias>$25: T.class_of(C) = alias <C C>
    <returnMethodTemp>$2: T.untyped = <cfgAlias>$25: T.class_of(C).f()
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: T.untyped
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

method ::<Class:C>#<static-init> {

bb0[firstDead=4]():
    <self>: T.class_of(C) = cast(<self>: NilClass, T.class_of(C));
    <cfgAlias>$6: T.class_of(Funcs) = alias <C Funcs>
    <statTemp>$3: T.class_of(C) = <self>: T.class_of(C).include(<cfgAlias>$6: T.class_of(Funcs))
    <finalReturn>: T.noreturn = return <returnMethodTemp>$2: NilClass
    <unconditional> -> bb1

# backedges
# - bb0
bb1[firstDead=-1]():
    <unconditional> -> bb1

}

