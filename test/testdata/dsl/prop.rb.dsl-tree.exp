class <emptyTree><<C <U <root>>>> < ()
  class <emptyTree>::<C <U NotAODM>><<C <U <todo sym>>>> < (::<todo sym>)
    def self.<U prop><<C <U <todo sym>>>>(*<U args>, &<U <blk>>)
      <emptyTree>
    end

    self(<C <U <todo sym>>>).<U prop>()

    self(<C <U <todo sym>>>).<U prop>(:"foo", :"not_a_string")

    self(<C <U <todo sym>>>).<U prop>("not_a_symbol", <emptyTree>::<C <U String>>)

    self(<C <U <todo sym>>>).<U prop>(:"foo", <emptyTree>::<C <U String>>, "not_a_hash")

    self(<C <U <todo sym>>>).<U prop>("too", <emptyTree>::<C <U String>>, {}, "many")

    self(<C <U <todo sym>>>).<U optional>(:"company_name", <emptyTree>::<C <U String>>, :"nonempty_string")

    self(<C <U <todo sym>>>).<U optional>(:"day", <emptyTree>::<C <U IntegerParam>>.<U new>({:"min" => 1, :"max" => 31}))

    self(<C <U <todo sym>>>).<U optional>(:"name", <emptyTree>::<C <U StringParam>>.<U alphanumeric>())

    self(<C <U <todo sym>>>).<U optional>(:"how_many", <emptyTree>::<C <U Opus>>::<C <U Param>>::<C <U CaseParam>>.<U new>(self(<C <U <todo sym>>>).<U how_many_cases>(), <emptyTree>::<C <U Opus>>::<C <U Param>>::<C <U ParamSpecsParam>>.<U new>(<emptyTree>::<C <U Default>>)))

    self(<C <U <todo sym>>>).<U optional>(:"optional_param", <emptyTree>::<C <U IntegerParam>>.<U new>())
  end

  class <emptyTree>::<C <U SomeODM>><<C <U <todo sym>>>> < (::<todo sym>)
    self(<C <U <todo sym>>>).<U extend>(<emptyTree>::<C <U T>>::<C <U Sig>>)

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foo><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    self(<C <U <todo sym>>>).<U sig>() do ||
      self(<C <U <todo sym>>>).<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U foo2><<C <U <todo sym>>>>(&<U <blk>>)
      <emptyTree>::<C <U T>>.<U cast>(<emptyTree>::<C <U T>>.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    self(<C <U <todo sym>>>).<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foo2=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      <emptyTree>::<C <U T>>.<U cast>(nil, <emptyTree>::<C <U String>>)
    end
  end

  class <emptyTree>::<C <U ForeignClass>><<C <U <todo sym>>>> < (::<todo sym>)
    <emptyTree>
  end

  class <emptyTree>::<C <U AdvancedODM>><<C <U <todo sym>>>> < (::<todo sym>)
    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U default_without_optional_false><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U default_without_optional_false=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U optional_false><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U optional_false=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U nodefault><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U nodefault=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U t_nilable><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U t_nilable=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U type><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U type=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::Object)
    end

    def <U object><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::Object)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => ::Object}).<U returns>(::Object)
    end

    def <U object=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::Object)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U Array>>)
    end

    def <U array><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U Array>>}).<U returns>(<emptyTree>::<C <U Array>>)
    end

    def <U array=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
    end

    class <emptyTree>::<C <U Mutator>><<C <U <todo sym>>>> < ()
      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U Array>>}).<U returns>(<emptyTree>::<C <U Array>>)
      end

      def <U array=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
      end

      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U returns>(::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end

      def <U array><<C <U <todo sym>>>>(&<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), ::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::T::Array.<U []>(<emptyTree>::<C <U String>>))
    end

    def <U array_of><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T::Array.<U []>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => ::T::Array.<U []>(<emptyTree>::<C <U String>>)}).<U returns>(::T::Array.<U []>(<emptyTree>::<C <U String>>))
    end

    def <U array_of=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T::Array.<U []>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U Array>>)
    end

    def <U array_of_explicit><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U Array>>}).<U returns>(<emptyTree>::<C <U Array>>)
    end

    def <U array_of_explicit=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
    end

    class <emptyTree>::<C <U Mutator>><<C <U <todo sym>>>> < ()
      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U Array>>}).<U returns>(<emptyTree>::<C <U Array>>)
      end

      def <U array_of_explicit=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
      end

      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U returns>(::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end

      def <U array_of_explicit><<C <U <todo sym>>>>(&<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), ::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
    end

    def <U t_array><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
    end

    def <U t_array=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
    end

    class <emptyTree>::<C <U Mutator>><<C <U <todo sym>>>> < ()
      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
      end

      def <U t_array=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
      end

      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U returns>(::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(<emptyTree>::<C <U String>>))
      end

      def <U t_array><<C <U <todo sym>>>>(&<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), ::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(<emptyTree>::<C <U String>>))
      end
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
    end

    def <U hash_of><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
    end

    def <U hash_of=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
    end

    class <emptyTree>::<C <U Mutator>><<C <U <todo sym>>>> < ()
      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
      end

      def <U hash_of=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
      end

      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U returns>(::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U HashMutator>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
      end

      def <U hash_of><<C <U <todo sym>>>>(&<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), ::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U HashMutator>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
      end
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U optional_explicit><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U optional_explicit=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U optional_existing><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U optional_existing=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U optional><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => ::T.<U nilable>(<emptyTree>::<C <U String>>)}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U optional=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U optional_nilable><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => ::T.<U nilable>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>)))
    end

    def <U optional_nilable=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>)))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U const_explicit><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U const><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U Array>>)
    end

    def <U no_class_arg><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
    end

    class <emptyTree>::<C <U Mutator>><<C <U <todo sym>>>> < ()
      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U Array>>}).<U returns>(<emptyTree>::<C <U Array>>)
      end

      def <U no_class_arg=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
      end

      ::Sorbet.<U sig>() do ||
        self(<C <U <todo sym>>>).<U returns>(::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end

      def <U no_class_arg><<C <U <todo sym>>>>(&<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), ::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::T.<U untyped>())
    end

    def <U enum_prop><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U ForeignClass>>))
    end

    def <U foreign_><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_lazy><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_lazy=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U ForeignClass>>))
    end

    def <U foreign_lazy_><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_proc><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_proc=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U ForeignClass>>))
    end

    def <U foreign_proc_><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_invalid><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_invalid=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(::T.<U untyped>())
    end

    def <U foreign_invalid_><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U ifunset><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U ifunset=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U ifunset_nilable><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U ifunset_nilable=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end
  end

  class <emptyTree>::<C <U PropHelpers>><<C <U <todo sym>>>> < (::<todo sym>)
    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::String)
    end

    def <U token><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::String)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => ::String}).<U returns>(::String)
    end

    def <U token=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::String)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::Float)
    end

    def <U created><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::Float)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => ::Float}).<U returns>(::Float)
    end

    def <U created=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::Float)
    end
  end

  class <emptyTree>::<C <U PropHelpers2>><<C <U <todo sym>>>> < (::<todo sym>)
    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::String)
    end

    def <U token><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::String)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => ::String}).<U returns>(::String)
    end

    def <U token=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::String)
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::Float)
    end

    def <U created><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::Float)
    end
  end

  class <emptyTree>::<C <U ShardingProp>><<C <U <todo sym>>>> < (::<todo sym>)
    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::String)
    end

    def <U merchant><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::String)
    end
  end

  class <emptyTree>::<C <U EncryptedProp>><<C <U <todo sym>>>> < (::<todo sym>)
    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::T.<U nilable>(::String))
    end

    def <U foo><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(::String))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end

    def <U encrypted_foo><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => ::T.<U nilable>(::String)}).<U returns>(::T.<U nilable>(::String))
    end

    def <U foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(::String))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({:"arg0" => ::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>)}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end

    def <U encrypted_foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::T.<U nilable>(::String))
    end

    def <U bar><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(::String))
    end

    ::Sorbet.<U sig>() do ||
      self(<C <U <todo sym>>>).<U params>({}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end

    def <U encrypted_bar><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end
  end

  def <U main><<C <U <todo sym>>>>(&<U <blk>>)
    begin
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U SomeODM>>.<U new>().<U foo>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U SomeODM>>.<U new>().<U foo>(), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U SomeODM>>.<U new>().<U foo=>("b"), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U SomeODM>>.<U new>().<U foo2>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U SomeODM>>.<U new>().<U foo2>(), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U SomeODM>>.<U new>().<U foo2=>("b"), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U default_without_optional_false>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U optional_false>(), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U nodefault>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U nodefault>(), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U t_nilable>())
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U type>(), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U object>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U Object>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U array>(), <emptyTree>::<C <U Array>>)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U array_of>(), <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U array_of_explicit>(), <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U t_array>(), <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U hash_of>(), <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U optional_explicit>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U optional_existing>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U optional_existing=>("b")
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U optional_existing=>(nil)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U optional_false>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U optional>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U optional=>("b")
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U optional=>(nil)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U optional_nilable>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U const_explicit>(), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U const_explicit=>("b")
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U const>(), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U const=>("b")
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U no_class_arg>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>)))
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U no_class_arg=>(["b"])
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U enum_prop=>("hello")
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U foreign_>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U ForeignClass>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U foreign_>(), <emptyTree>::<C <U ForeignClass>>)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U foreign_lazy_>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U ForeignClass>>))
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U foreign_invalid_>()
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U PropHelpers>>.<U new>().<U token>(), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U PropHelpers>>.<U new>().<U token=>("tok_token")
      <emptyTree>::<C <U PropHelpers>>.<U new>().<U token=>(nil)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U PropHelpers>>.<U new>().<U created>(), <emptyTree>::<C <U Float>>)
      <emptyTree>::<C <U PropHelpers>>.<U new>().<U created=>(0.000000)
      <emptyTree>::<C <U PropHelpers>>.<U new>().<U created=>(nil)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U PropHelpers2>>.<U new>().<U token>(), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U PropHelpers2>>.<U new>().<U token=>("tok_token")
      <emptyTree>::<C <U PropHelpers2>>.<U new>().<U token=>(nil)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U PropHelpers2>>.<U new>().<U created>(), <emptyTree>::<C <U Float>>)
      <emptyTree>::<C <U PropHelpers2>>.<U new>().<U created=>(0.000000)
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U ShardingProp>>.<U new>().<U merchant>(), <emptyTree>::<C <U String>>)
      <emptyTree>::<C <U ShardingProp>>.<U new>().<U merchant=>("hi")
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U EncryptedProp>>.<U new>().<U foo>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
      <emptyTree>::<C <U T>>.<U assert_type!>(<emptyTree>::<C <U EncryptedProp>>.<U new>().<U encrypted_foo>(), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
      <emptyTree>::<C <U EncryptedProp>>.<U new>().<U foo=>("hello")
      <emptyTree>::<C <U EncryptedProp>>.<U new>().<U foo=>(nil)
      <emptyTree>::<C <U EncryptedProp>>.<U new>().<U bar=>("hello")
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U ifunset>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U ifunset_nilable>())
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U ifunset=>(nil)
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U ifunset_nilable=>(nil)
    end
  end
end
