--- parse-tree start ---
Integer {
  val = "1"
}
--- parse-tree end ---
--- parse-tree-json start ---
{
  "type" : "Integer",
  "val" : "1"
}
--- parse-tree-json end ---
--- desugar-tree start ---
class <emptyTree><<C <root>>> < (::<todo sym>)
  1
end
--- desugar-tree end ---
--- desugar-tree-raw start ---
ClassDef{
  kind = class
  name = EmptyTree<<C <U <root>>>>
  ancestors = [ConstantLit{
      orig = nullptr
      symbol = (class ::<todo sym>)
    }]
  rhs = [
    Literal{ value = 1 }
  ]
}
--- desugar-tree-raw end ---
--- rewrite-tree start ---
class <emptyTree><<C <root>>> < (::<todo sym>)
  1
end
--- rewrite-tree end ---
--- rewrite-tree-raw start ---
ClassDef{
  kind = class
  name = EmptyTree<<C <U <root>>>>
  ancestors = [ConstantLit{
      orig = nullptr
      symbol = (class ::<todo sym>)
    }]
  rhs = [
    Literal{ value = 1 }
  ]
}
--- rewrite-tree-raw end ---
--- index-tree start ---
class <emptyTree><<C <root>>> < (::<todo sym>)
  1
end
--- index-tree end ---
--- index-tree-raw start ---
ClassDef{
  kind = class
  name = EmptyTree<<C <U <root>>>>
  ancestors = [ConstantLit{
      orig = nullptr
      symbol = (class ::<todo sym>)
    }]
  rhs = [
    Literal{ value = 1 }
  ]
}
--- index-tree-raw end ---
--- name-tree start ---
begin
  class <emptyTree><<C <root>>> < (::<todo sym>)
    1
  end
  <emptyTree>
end
--- name-tree end ---
--- name-tree-raw start ---
InsSeq{
  stats = [
    ClassDef{
      kind = class
      name = EmptyTree<<C <U <root>>>>
      ancestors = [ConstantLit{
          orig = nullptr
          symbol = (class ::<todo sym>)
        }]
      rhs = [
        Literal{ value = 1 }
      ]
    }
  ],
  expr = EmptyTree
}
--- name-tree-raw end ---
--- resolve-tree start ---
begin
  class <emptyTree><<C <root>>> < (::<todo sym>)
    1
  end
  <emptyTree>
end
--- resolve-tree end ---
--- resolve-tree-raw start ---
InsSeq{
  stats = [
    ClassDef{
      kind = class
      name = EmptyTree<<C <U <root>>>>
      ancestors = [ConstantLit{
          orig = nullptr
          symbol = (class ::<todo sym>)
        }]
      rhs = [
        Literal{ value = 1 }
      ]
    }
  ],
  expr = EmptyTree
}
--- resolve-tree-raw end ---
--- flatten-tree start ---
begin
  <emptyTree>
  class <emptyTree><<C <root>>> < (::<todo sym>)
    def self.<static-init><<static-init>$CENSORED>(<blk>)
      1
    end
  end
  <emptyTree>
end
--- flatten-tree end ---
--- flatten-tree-raw start ---
InsSeq{
  stats = [
    EmptyTree
    ClassDef{
      kind = class
      name = EmptyTree<<C <U <root>>>>
      ancestors = [ConstantLit{
          orig = nullptr
          symbol = (class ::<todo sym>)
        }]
      rhs = [
        MethodDef{
          flags = {self}
          name = <U <static-init>><<N <U <static-init>> $CENSORED>>
          args = [Local{
              localVariable = <U <blk>>
            }]
          rhs = Literal{ value = 1 }
        }
      ]
    }
  ],
  expr = EmptyTree
}
--- flatten-tree-raw end ---
--- ast start ---
begin
  <emptyTree>
  class <emptyTree><<C <root>>> < (::<todo sym>)
    def self.<static-init><<static-init>$CENSORED>(<blk>)
      1
    end
  end
  <emptyTree>
end
--- ast end ---
--- ast-raw start ---
InsSeq{
  stats = [
    EmptyTree
    ClassDef{
      kind = class
      name = EmptyTree<<C <U <root>>>>
      ancestors = [ConstantLit{
          orig = nullptr
          symbol = (class ::<todo sym>)
        }]
      rhs = [
        MethodDef{
          flags = {self}
          name = <U <static-init>><<N <U <static-init>> $CENSORED>>
          args = [Local{
              localVariable = <U <blk>>
            }]
          rhs = Literal{ value = 1 }
        }
      ]
    }
  ],
  expr = EmptyTree
}
--- ast-raw end ---
--- cfg start ---
digraph "-e" {
subgraph "cluster_::<Class:<root>>#<static-init>" {
    label = "::<Class:<root>>#<static-init>";
    color = blue;

    "bb::<Class:<root>>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0, rubyBlockId=0]()\l<self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {\l  klass = <S <C <U <root>>> $1>\l  targs = [\l    <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)\l  ]\l});\l<returnMethodTemp>$2: Integer(1) = 1\l<returnMethodTemp>$2: T.noreturn = return <returnMethodTemp>$2: Integer(1)\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_0" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
    "bb::<Class:<root>>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1, rubyBlockId=0](<returnMethodTemp>$2)\l<finalReturn> = return <returnMethodTemp>$2\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_1" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
}

}

--- cfg end ---
--- cfg-raw start ---
digraph "-e" {
  graph [fontname = "Courier"];
  node [fontname = "Courier"];
  edge [fontname = "Courier"];
subgraph "cluster_::<Class:<root>>#<static-init>" {
    label = "::<Class:<root>>#<static-init>";
    color = blue;

    "bb::<Class:<root>>#<static-init>_0" [
        shape = invhouse;
        color = black;
        label = "block[id=0]()\lBinding {\l&nbsp;bind = VariableUseSite {\l&nbsp;&nbsp;variable = <U <self>>,\l&nbsp;&nbsp;type = T.class_of(<root>),\l&nbsp;},\l&nbsp;value = Cast {\l&nbsp;&nbsp;cast = T.cast,\l&nbsp;&nbsp;value = VariableUseSite {\l&nbsp;&nbsp;&nbsp;variable = <U <self>>,\l&nbsp;&nbsp;&nbsp;type = NilClass,\l&nbsp;&nbsp;},\l&nbsp;&nbsp;type = T.class_of(<root>),\l&nbsp;},\l}\lBinding {\l&nbsp;bind = VariableUseSite {\l&nbsp;&nbsp;variable = <U <returnMethodTemp>>$2,\l&nbsp;&nbsp;type = Integer(1),\l&nbsp;},\l&nbsp;value = Literal { value = Integer(1) },\l}\lBinding {\l&nbsp;bind = VariableUseSite {\l&nbsp;&nbsp;variable = <U <returnMethodTemp>>$2,\l&nbsp;&nbsp;type = T.noreturn,\l&nbsp;},\l&nbsp;value = Return {\l&nbsp;&nbsp;what = VariableUseSite {\l&nbsp;&nbsp;&nbsp;variable = <U <returnMethodTemp>>$2,\l&nbsp;&nbsp;&nbsp;type = Integer(1),\l&nbsp;&nbsp;},\l&nbsp;},\l}\lVariableUseSite { variable = <U <unconditional>> }\l"
    ];

    "bb::<Class:<root>>#<static-init>_0" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
    "bb::<Class:<root>>#<static-init>_1" [
        shape = parallelogram;
        color = black;
        label = "block[id=1](VariableUseSite { variable = <U <returnMethodTemp>>$2 })\lBinding {\l&nbsp;bind = VariableUseSite { variable = <U <finalReturn>> },\l&nbsp;value = Return {\l&nbsp;&nbsp;what = VariableUseSite { variable = <U <returnMethodTemp>>$2 },\l&nbsp;},\l}\lVariableUseSite { variable = <U <unconditional>> }\l"
    ];

    "bb::<Class:<root>>#<static-init>_1" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
}

}

--- cfg-raw end ---
--- cfg-text start ---
method ::<Class:<root>>#<static-init> {

bb0(rubyBlockId=0):
    blockargs=()
    <self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {
      klass = <S <C <U <root>>> $1>
      targs = [
        <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)
      ]
    });
    <returnMethodTemp>$2: Integer(1) = 1
    <returnMethodTemp>$2: T.noreturn = return <returnMethodTemp>$2: Integer(1)
    <unconditional>(bb0 -> bb1)

# backedges
#  bb0(rubyBlockId=0)
bb1(rubyBlockId=0):
    blockargs=(<returnMethodTemp>$2)
    <finalReturn> = return <returnMethodTemp>$2
    <unconditional>(bb1 -> bb1)

}

--- cfg-text end ---
--- symbol-table start ---
class ::<root> < ::Object ()
  class ::<Class:<root>>[<AttachedClass>] < ::<Class:Object> ()
    method ::<Class:<root>>#<static-init> (<blk>) @ -e:1
      argument <blk><block> @ Loc {file=-e start=??? end=???}

--- symbol-table end ---
--- symbol-table-raw start ---
class <C <U <root>>> < <C <U Object>> ()
  class <S <C <U <root>>> $1>[<C <U <AttachedClass>>>] < <S <C <U Object>> $1> ()
    method <S <C <U <root>>> $1><N <U <static-init>> $CENSORED> (<blk>) @ Loc {file=-e start=1:1 end=1:2}
      argument <blk><block> @ Loc {file=-e start=??? end=???}

--- symbol-table-raw end ---
--- checking diff ---
1,23d0
1,24d0
1,9d0
< 
< 
< 
< 
<               localVariable = <U <blk>>
<             }]
<           args = [Local{
<           flags = {self}
<           name = <U <static-init>><<N <U <static-init>> $CENSORED>>
<           orig = nullptr
<           rhs = Literal{ value = 1 }
<           symbol = (class ::<todo sym>)
<         <C <U <AttachedClass>>> = SelfTypeParam(<S <C <U <root>>> $1><C <U <AttachedClass>>>)
<         MethodDef{
<         }
<         }]
<       1
<       ]
<       ]
<       ancestors = [ConstantLit{
<       kind = class
<       klass = <S <C <U <root>>> $1>
<       name = EmptyTree<<C <U <root>>>>
<       rhs = [
<       targs = [
<     <finalReturn> = return <returnMethodTemp>$2
<     <returnMethodTemp>$2: Integer(1) = 1
<     <returnMethodTemp>$2: T.noreturn = return <returnMethodTemp>$2: Integer(1)
<     <self>: T.class_of(<root>) = cast(<self>: NilClass, AppliedType {
<     <unconditional>(bb0 -> bb1)
<     <unconditional>(bb1 -> bb1)
<     ClassDef{
<     EmptyTree
<     blockargs=()
<     blockargs=(<returnMethodTemp>$2)
<     def self.<static-init><<static-init>$CENSORED>(<blk>)
<     end
<     }
<     });
<   <emptyTree>
<   <emptyTree>
<   ],
<   class <emptyTree><<C <root>>> < (::<todo sym>)
<   end
<   expr = EmptyTree
<   stats = [
< #  bb0(rubyBlockId=0)
< # backedges
< InsSeq{
< bb0(rubyBlockId=0):
< bb1(rubyBlockId=0):
< begin
< end
< method ::<Class:<root>>#<static-init> {
< }
< }
diff -r out/ast fileout/ast
diff -r out/ast-raw fileout/ast-raw
diff -r out/cfg-text fileout/cfg-text
--- checking crashes ---
--- checking crashes end ---
