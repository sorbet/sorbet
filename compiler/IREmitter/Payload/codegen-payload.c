#include "sorbet_version/sorbet_version.h"

// These are public Ruby headers. Feel free to add more from the include/ruby
// directory
#include "ruby/encoding.h" // for rb_encoding

// These are special "public" headers which don't live in include/ruby for some
// reason
#include "internal.h"
#include "ruby.h"

// This is probably a bad idea but is needed for so many things
#include "vm_core.h"

#define SORBET_ATTRIBUTE(...) __attribute__((__VA_ARGS__))
#define SORBET_INLINE __attribute__((always_inline))

typedef VALUE (*BlockFFIType)(VALUE firstYieldedArg, VALUE closure, int argCount, const VALUE *args, VALUE blockArg);
typedef VALUE (*ExceptionFFIType)(VALUE **pc, VALUE closure, rb_control_frame_t *);
typedef VALUE (*BlockConsumerFFIType)(VALUE recv, ID fun, int argc, VALUE *argv, BlockFFIType blk,
                                      const struct rb_captured_block *captured, VALUE closure, int numPositionalArgs);

// compiler is closely aware of layout of this struct
struct FunctionInlineCache {
    struct rb_kwarg_call_data cd;
};

struct sorbet_iterMethodArg {
    VALUE recv;
    ID func;
    int argc;
    const VALUE *argv;
    int kw_splat;
    struct FunctionInlineCache *cache;
};

struct SorbetLineNumberInfo {
    int iseq_size;
    struct iseq_insn_info_entry *insns_info;
    VALUE *iseq_encoded;
};

// Define a function that uses a name, keeping it in scope. The payload post-processing step will detect these functions
// and keep them as externally visible, which will allow functions used with this macro to avoid being garbage collected
// The functions generated by this macro will be explicitly pruned late in the pipeline allowing functions mentioned to
// survive to the lowerings passes.
#define KEEP_ALIVE(name)                                                  \
    VALUE sorbet_exists_to_keep_alive_##name() __attribute__((optnone)) { \
        return (long)&name;                                               \
    }

// Functions known to the compiler.
//
// We have to be a little tricky here, as LLVM will eliminate declarations that are unused from the emitted IR.  So we
// use the following macro to ensure that our declarations are "used"; the placeholder function will be eliminated by
// other optimizations.
#define SORBET_ALIVE(rettype, name, rest) \
    extern rettype name rest;             \
    KEEP_ALIVE(name)

SORBET_ALIVE(VALUE, rb_id2sym, (ID));
SORBET_ALIVE(VALUE, rb_errinfo, ());
SORBET_ALIVE(VALUE, rb_obj_is_kind_of, (VALUE, VALUE) __attribute__((const)));

SORBET_ALIVE(const char *, sorbet_dbg_p, (VALUE obj));
SORBET_ALIVE(void, sorbet_stopInDebugger, (void));

SORBET_ALIVE(void, sorbet_cast_failure,
             (VALUE value, char *castMethod, char *type) __attribute__((__cold__, __noreturn__)));
SORBET_ALIVE(void, sorbet_raiseArity, (int argc, int min, int max) __attribute__((__noreturn__)));
SORBET_ALIVE(void, sorbet_raiseMissingKeywords, (VALUE missing) __attribute__((__noreturn__)));
SORBET_ALIVE(void, sorbet_raiseExtraKeywords, (VALUE hash) __attribute__((__noreturn__)));
SORBET_ALIVE(VALUE, sorbet_t_absurd, (VALUE val) __attribute__((__cold__)));

SORBET_ALIVE(VALUE, sorbet_addMissingKWArg, (VALUE missing, VALUE sym));

SORBET_ALIVE(rb_iseq_t *, sorbet_allocateRubyStackFrame,
             (VALUE funcName, ID func, VALUE filename, VALUE realpath, rb_iseq_t *parent, int iseqType, int startLine,
              struct SorbetLineNumberInfo *info, ID *locals, int numLocals, int stackMax));
SORBET_ALIVE(void, sorbet_initLineNumberInfo, (struct SorbetLineNumberInfo * info, VALUE *, int numLines));
SORBET_ALIVE(VALUE, sorbet_getConstant, (const char *path, long pathLen));
SORBET_ALIVE(VALUE, sorbet_setConstant, (VALUE mod, const char *name, long nameLen, VALUE value));

SORBET_ALIVE(const VALUE, sorbet_readRealpath, (void));
SORBET_ALIVE(rb_control_frame_t *, sorbet_pushCfuncFrame, (struct FunctionInlineCache *, VALUE, const rb_iseq_t *));
SORBET_ALIVE(rb_control_frame_t *, sorbet_pushStaticInitFrame, (VALUE));
SORBET_ALIVE(void, sorbet_pushBlockFrame, (const struct rb_captured_block *));
SORBET_ALIVE(void, sorbet_popFrame, (void));

SORBET_ALIVE(void, sorbet_vm_env_write_slowpath, (const VALUE *, int, VALUE));
SORBET_ALIVE(void, sorbet_setupFunctionInlineCache,
             (struct FunctionInlineCache * cache, ID mid, unsigned int flags, int argc, int num_kwargs, VALUE *keys));
SORBET_ALIVE(VALUE, sorbet_callFuncWithCache, (struct FunctionInlineCache * cache, VALUE bh));
SORBET_ALIVE(void, sorbet_vmMethodSearch, (struct FunctionInlineCache * cache, VALUE recv));
SORBET_ALIVE(VALUE, sorbet_getPassedBlockHandler, ());

SORBET_ALIVE(void, sorbet_setMethodStackFrame,
             (rb_execution_context_t * ec, rb_control_frame_t *cfp, const rb_iseq_t *iseq));
SORBET_ALIVE(void, sorbet_setExceptionStackFrame,
             (rb_execution_context_t * ec, rb_control_frame_t *cfp, const rb_iseq_t *iseq));

SORBET_ALIVE(VALUE, sorbet_blockReturnUndef, (VALUE * *pc, VALUE closure, rb_control_frame_t *));

SORBET_ALIVE(VALUE, sorbet_vm_expandSplatIntrinsic, (VALUE thing, VALUE before, VALUE after));
SORBET_ALIVE(VALUE, sorbet_vm_check_match_array, (rb_execution_context_t * ec, VALUE target, VALUE pattern));
SORBET_ALIVE(VALUE, sorbet_vm_splatIntrinsic, (VALUE thing));
SORBET_ALIVE(VALUE, sorbet_definedIntrinsic,
             (VALUE recv, ID fun, int argc, const VALUE *const restrict, BlockFFIType blk, VALUE closure));
SORBET_ALIVE(VALUE, sorbet_stringInterpolate,
             (VALUE recv, ID fun, int argc, const VALUE *const restrict, BlockFFIType blk, VALUE closure));

SORBET_ALIVE(VALUE, sorbet_rb_array_square_br_slowpath,
             (VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk, VALUE closure));
SORBET_ALIVE(VALUE, rb_ary_compact_bang_forwarder, (VALUE recv));

SORBET_ALIVE(void, sorbet_hashUpdate, (VALUE hash, VALUE other));

SORBET_ALIVE(VALUE, sorbet_rb_int_plus_slowpath, (VALUE, VALUE));
SORBET_ALIVE(VALUE, sorbet_rb_int_minus_slowpath, (VALUE, VALUE));

SORBET_ALIVE(VALUE, sorbet_rb_int_lt_slowpath, (VALUE, VALUE));
SORBET_ALIVE(VALUE, sorbet_rb_int_gt_slowpath, (VALUE, VALUE));
SORBET_ALIVE(VALUE, sorbet_rb_int_le_slowpath, (VALUE, VALUE));
SORBET_ALIVE(VALUE, sorbet_rb_int_ge_slowpath, (VALUE, VALUE));

SORBET_ALIVE(VALUE, sorbet_i_getRubyClass, (const char *const className, long classNameLen) __attribute__((const)));
SORBET_ALIVE(VALUE, sorbet_i_getRubyConstant, (const char *const className, long classNameLen) __attribute__((const)));
SORBET_ALIVE(VALUE, sorbet_i_objIsKindOf, (VALUE, VALUE));
SORBET_ALIVE(VALUE, sorbet_i_send,
             (struct FunctionInlineCache *, _Bool blkUsesBreak, BlockFFIType blk, int blkMinArgs, int blkMaxArgs, VALUE,
              rb_control_frame_t *, ...));

SORBET_ALIVE(_Bool, sorbet_i_isa_Integer, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_TrueClass, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_FalseClass, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_NilClass, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_Symbol, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_Float, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_Untyped, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_Hash, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_Array, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_Regexp, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_String, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_Proc, (VALUE) __attribute__((const)));
SORBET_ALIVE(_Bool, sorbet_i_isa_RootSingleton, (VALUE) __attribute__((const)));

SORBET_ALIVE(long, sorbet_globalConstRegister, (VALUE val));
SORBET_ALIVE(VALUE, sorbet_globalConstDupHash, (long index));
SORBET_ALIVE(VALUE, sorbet_magic_mergeHashHelper, (VALUE, VALUE));

SORBET_ALIVE(VALUE, sorbet_vm_getivar, (VALUE obj, ID id, struct iseq_inline_iv_cache_entry *cache));
SORBET_ALIVE(void, sorbet_vm_setivar, (VALUE obj, ID id, VALUE val, struct iseq_inline_iv_cache_entry *cache));

SORBET_ALIVE(void, sorbet_vm_register_sig,
             (VALUE isSelf, VALUE method, VALUE self, VALUE arg, rb_block_call_func_t block));
SORBET_ALIVE(void, sorbet_vm_define_method,
             (VALUE klass, const char *name, rb_sorbet_func_t methodPtr, void *paramp, rb_iseq_t *iseq, bool isSelf));

SORBET_ALIVE(VALUE, sorbet_vm_fstring_new, (const char *ptr, long len));

extern void sorbet_throwReturn(rb_execution_context_t *ec, VALUE retval) __attribute__((noreturn));
KEEP_ALIVE(sorbet_throwReturn);
SORBET_ALIVE(VALUE, sorbet_vm_callBlock,
             (rb_control_frame_t * cfp, int argc, SORBET_ATTRIBUTE(noescape) const VALUE *const restrict argv,
              int kw_splat));

SORBET_ALIVE(int, rb_cvar_lookup, (VALUE klass, ID id, VALUE *v));

struct rfb_status {
    // The return value from the function.
    VALUE return_value;

    // Whether the value was returned via return-from-block.
    bool was_thrown;
};
SORBET_ALIVE(struct rfb_status, sorbet_vm_return_from_block_wrapper,
             (int argc, VALUE *argv, VALUE recv, rb_control_frame_t *cfp, rb_sorbet_func_t wrapped));
SORBET_ALIVE(VALUE, sorbet_run_exception_handling,
             (rb_execution_context_t * ec, ExceptionFFIType body, VALUE **volatile pc,
              // The locals offset for the body.
              VALUE methodClosure, rb_control_frame_t *volatile cfp,
              // May be nullptr.
              ExceptionFFIType handlers,
              // May be nullptr.
              ExceptionFFIType elseClause,
              // May be nullptr.
              ExceptionFFIType ensureClause,
              // The special value indicating that we need to retry.
              VALUE retrySingleton, long exceptionValueIndex, long exceptionValueLevel));

SORBET_ALIVE(VALUE, sorbet_rb_iterate,
             (VALUE(*body)(VALUE), VALUE data1, rb_block_call_func_t bl_proc, int minArgs, int maxArgs, VALUE data2));

// The next several functions exist to convert Ruby definitions into LLVM IR, and
// are always inlined as a consequence.

// ****
// ****                       Singletons
// ****

SORBET_INLINE
VALUE sorbet_rubyTrue() {
    return RUBY_Qtrue;
}
KEEP_ALIVE(sorbet_rubyTrue);

SORBET_INLINE
VALUE sorbet_rubyFalse() {
    return RUBY_Qfalse;
}

SORBET_INLINE
VALUE sorbet_rubyNil() {
    return RUBY_Qnil;
}

// use this undefined value when you have a variable that should _never_ escape to ruby.
SORBET_INLINE
VALUE sorbet_rubyUndef() {
    return RUBY_Qundef;
}

SORBET_INLINE
SORBET_ATTRIBUTE(pure)
VALUE sorbet_rubyTopSelf() {
    return GET_VM()->top_self;
}

SORBET_INLINE
rb_execution_context_t *sorbet_getEC() {
    return GET_EC();
}

SORBET_INLINE
rb_control_frame_t *sorbet_getCFP() {
    return GET_EC()->cfp;
}

SORBET_INLINE
VALUE sorbet_getSelfFromFrame() {
    return GET_EC()->cfp->self;
}

// ****
// ****                       Implementation helpers for type tests
// ****

SORBET_INLINE
VALUE sorbet_getVoidSingleton() {
    static const char name[] = "T::Private::Types::Void::VOID";
    return sorbet_getConstant(name, sizeof(name));
}

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_Integer(VALUE obj) {
    if (LIKELY(RB_FIXNUM_P(obj))) {
        return true;
    }
    return RB_TYPE_P(obj, T_BIGNUM);
}
KEEP_ALIVE(sorbet_isa_Integer);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_TrueClass(VALUE obj) {
    return obj == RUBY_Qtrue;
}
KEEP_ALIVE(sorbet_isa_TrueClass);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_FalseClass(VALUE obj) {
    return obj == RUBY_Qfalse;
}
KEEP_ALIVE(sorbet_isa_FalseClass);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_NilClass(VALUE obj) {
    return obj == RUBY_Qnil;
}
KEEP_ALIVE(sorbet_isa_NilClass);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_Symbol(VALUE obj) {
    return RB_SYMBOL_P(obj);
}
KEEP_ALIVE(sorbet_isa_Symbol);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_Float(VALUE obj) {
    return RB_FLOAT_TYPE_P(obj);
}
KEEP_ALIVE(sorbet_isa_Float);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_Untyped(VALUE obj) {
    return 1;
}
KEEP_ALIVE(sorbet_isa_Untyped);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_Hash(VALUE obj) {
    return RB_TYPE_P(obj, T_HASH);
}
KEEP_ALIVE(sorbet_isa_Hash);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_Array(VALUE obj) {
    return RB_TYPE_P(obj, T_ARRAY);
}
KEEP_ALIVE(sorbet_isa_Array);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_Regexp(VALUE obj) {
    return RB_TYPE_P(obj, T_REGEXP);
}
KEEP_ALIVE(sorbet_isa_Regexp);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_Rational(VALUE obj) {
    return RB_TYPE_P(obj, T_RATIONAL);
}

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_String(VALUE obj) {
    return RB_TYPE_P(obj, T_STRING);
}
KEEP_ALIVE(sorbet_isa_String);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_Proc(VALUE obj) {
    return rb_obj_is_proc(obj) == Qtrue;
}
KEEP_ALIVE(sorbet_isa_Proc);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_RootSingleton(VALUE obj) {
    return obj == GET_VM()->top_self;
}
KEEP_ALIVE(sorbet_isa_RootSingleton);

SORBET_ATTRIBUTE(const) VALUE rb_class_inherited_p(VALUE, VALUE);

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa(VALUE obj, VALUE class) {
    return sorbet_i_objIsKindOf(obj, class) == Qtrue;
}

SORBET_ATTRIBUTE(const)
_Bool sorbet_isa_class_of(VALUE obj, VALUE class) {
    return (obj == class) || (sorbet_i_objIsKindOf(obj, rb_cModule) && rb_class_inherited_p(obj, class));
}

SORBET_INLINE
int sorbet_rubyIseqTypeMethod() {
    return ISEQ_TYPE_METHOD;
}

SORBET_INLINE
int sorbet_rubyIseqTypeTop() {
    return ISEQ_TYPE_TOP;
}

SORBET_INLINE
int sorbet_rubyIseqTypeClass() {
    return ISEQ_TYPE_CLASS;
}

SORBET_INLINE
int sorbet_rubyIseqTypeBlock() {
    return ISEQ_TYPE_BLOCK;
}

SORBET_INLINE
int sorbet_rubyIseqTypeRescue() {
    return ISEQ_TYPE_RESCUE;
}

SORBET_INLINE
int sorbet_rubyIseqTypeEnsure() {
    return ISEQ_TYPE_ENSURE;
}

RUBY_EXTERN rb_serial_t ruby_vm_global_constant_state;

SORBET_INLINE
rb_serial_t sorbet_getConstantEpoch() {
    return ruby_vm_global_constant_state;
}
KEEP_ALIVE(sorbet_getConstantEpoch);

SORBET_INLINE
VALUE sorbet_getMethodBlockAsProc() {
    if (rb_block_given_p()) {
        return rb_block_proc();
    }
    return Qnil;
}

SORBET_INLINE
_Bool sorbet_block_isa_proc() {
    /* If we get here, we know that we're checking the block handler for proc-ness.
     *
     * If we don't have a block handler, then we know that the block handler cannot
     * be a proc.  If we do have a block handler, pretty much all the different
     * kinds of block handlers can be procs (i.e. rb_block_proc always returns a
     * proc-like thing: https://github.com/ruby/ruby/blob/7332b3f367ce61089bf571fa1c458fde06a11eab/proc.c#L743-L808).
     *
     * Since we're only checking for proc-ness and not arity (or even "can this thing be called?"
     * in the case of a symbol-as-proc), the only thing we can do is make sure that
     * we have a block handler.
     */
    return rb_block_given_p();
}

SORBET_INLINE
VALUE sorbet_defineTopLevelModule(const char *name) {
    return rb_define_module(name);
}

SORBET_INLINE
VALUE sorbet_defineNestedModule(VALUE owner, const char *name) {
    return rb_define_module_under(owner, name);
}

SORBET_INLINE
VALUE sorbet_defineTopClassOrModule(const char *name, VALUE super) {
    return rb_define_class(name, super);
}

SORBET_INLINE
VALUE sorbet_defineNestedClass(VALUE owner, const char *name, VALUE super) {
    return rb_define_class_under(owner, name, super);
}

// this DOES override existing methods
SORBET_INLINE
void sorbet_defineMethod(VALUE klass, const char *name, rb_sorbet_func_t methodPtr, void *paramp, rb_iseq_t *iseq) {
    sorbet_vm_define_method(klass, name, methodPtr, paramp, iseq, false);
}

// this DOES override existing methods
SORBET_INLINE
void sorbet_defineMethodSingleton(VALUE klass, const char *name, rb_sorbet_func_t methodPtr, void *paramp,
                                  rb_iseq_t *iseq) {
    sorbet_vm_define_method(klass, name, methodPtr, paramp, iseq, true);
}

SORBET_INLINE
void sorbet_defineIvarMethod(VALUE klass, const char *name) {
    // https://github.com/ruby/ruby/blob/5445e0435260b449decf2ac16f9d09bae3cafe72/vm_method.c#L1190-L1193
    ID mid = rb_intern(name);
    ID attriv = rb_intern_str(rb_sprintf("@%" PRIsVALUE, rb_id2str(mid)));
    rb_add_method(klass, mid, VM_METHOD_TYPE_IVAR, (void *)attriv, METHOD_VISI_PUBLIC);
}

SORBET_INLINE
void sorbet_defineIvarMethodSingleton(VALUE klass, const char *name) {
    sorbet_defineIvarMethod(rb_singleton_class(klass), name);
}

VALUE sorbet_singleton_class(VALUE klass) {
    return rb_singleton_class(klass);
}

// ****
// ****                       Variables
// ****

SORBET_INLINE
VALUE sorbet_globalVariableGet(ID name) {
    return rb_gvar_get(rb_global_entry(name));
}

SORBET_INLINE
void sorbet_globalVariableSet(ID name, VALUE newValue) {
    rb_gvar_set(rb_global_entry(name), newValue);
}

SORBET_INLINE
VALUE sorbet_instanceVariableGet(VALUE receiver, ID name, struct iseq_inline_iv_cache_entry *cache) {
    return sorbet_vm_getivar(receiver, name, cache);
}

SORBET_INLINE
void sorbet_instanceVariableSet(VALUE receiver, ID name, VALUE newValue, struct iseq_inline_iv_cache_entry *cache) {
    sorbet_vm_setivar(receiver, name, newValue, cache);
}

SORBET_INLINE
VALUE sorbet_instanceVariableDefined(VALUE recv, VALUE name) {
    return rb_ivar_defined(recv, SYM2ID(name));
}

SORBET_INLINE
VALUE sorbet_classVariableGet(VALUE _class, ID name) {
    return rb_cvar_get(_class, name);
}

SORBET_INLINE
void sorbet_classVariableSet(VALUE _class, ID name, VALUE newValue) {
    rb_cvar_set(_class, name, newValue);
}

SORBET_INLINE
VALUE sorbet_classVariableDefined(VALUE klass, VALUE name) {
    return rb_cvar_defined(klass, SYM2ID(name));
}

SORBET_INLINE
_Bool sorbet_classVariableDefinedAndTruthy(VALUE klass, ID name) {
    VALUE val = Qundef;
    if (!rb_cvar_lookup(klass, name, &val)) {
        return false;
    }
    return RTEST(val);
}

// ****
// ****                       Operations on Ruby ID's
// ****

SORBET_INLINE
ID sorbet_idIntern(const char *value, long length) {
    return rb_intern2(value, length);
}

SORBET_INLINE
ID sorbet_symToID(VALUE sym) {
    return SYM2ID(sym);
}

SORBET_INLINE
VALUE sorbet_IDToSym(ID id) {
    return ID2SYM(id);
}

SORBET_INLINE
VALUE sorbet_getRubyClassOf(VALUE value) {
    return CLASS_OF(value);
}

SORBET_INLINE
const char *sorbet_getRubyClassName(VALUE object) {
    return rb_obj_classname(object);
}

// ****
// ****                       Conversions between Ruby values and C values
// ****

SORBET_INLINE
long sorbet_rubyValueToLong(VALUE val) {
    return FIX2LONG(val);
}

SORBET_INLINE
VALUE sorbet_longToRubyValue(long i) {
    return LONG2FIX(i);
}

SORBET_INLINE
double sorbet_rubyValueToDouble(VALUE val) {
    return RFLOAT_VALUE(val);
}

SORBET_INLINE
VALUE sorbet_doubleToRubyValue(double u) {
    return DBL2NUM(u);
}

// ****
// ****                       Operations on Arrays
// ****

SORBET_INLINE
int sorbet_rubyArrayLen(VALUE array) {
    return RARRAY_LEN(array);
}

SORBET_INLINE
const VALUE *sorbet_rubyArrayInnerPtr(VALUE array) {
    // there's also a transient version of this function if we ever decide to want more speed. transient stands for that
    // we _should not_ allow to execute any code between getting these pointers and reading elements from
    return RARRAY_CONST_PTR(array);
}

SORBET_INLINE
VALUE sorbet_newRubyArray(long size) {
    return rb_ary_new2(size);
}

SORBET_INLINE
VALUE sorbet_newRubyArrayWithElems(long size, const VALUE *elems) {
    return rb_ary_new4(size, elems);
}

SORBET_INLINE
void sorbet_arrayPush(VALUE array, VALUE element) {
    rb_ary_push(array, element);
}

SORBET_INLINE
VALUE sorbet_arrayDup(VALUE array) {
    return rb_ary_dup(array);
}

SORBET_INLINE
VALUE sorbet_arrayPop(VALUE array) {
    return rb_ary_pop(array);
}

SORBET_INLINE
VALUE sorbet_arrayNewFromValues(int argc, VALUE *argv) {
    return rb_ary_new_from_values(argc, argv);
}

// ****
// ****                       Operations on Hashes
// ****

SORBET_INLINE
VALUE sorbet_newRubyHash() {
    return rb_hash_new();
}

SORBET_INLINE
VALUE sorbet_hashBuild(int argc, const VALUE *argv) {
    VALUE ret = rb_hash_new_with_size(argc / 2);
    if (argc > 0) {
        // We can use rb_hash_bulk_insert here because rb_hash_new_with_size freshly allocates.
        // We have tried in the past to use rb_hash_bulk_insert after clearing an existing hash,
        // and things broke wonderfully, because Ruby Hash objects are either backed by a small (<8 element)
        // or large hash table implementation, and neither Hash#clear nor rb_hash_bulk_insert changes
        // what kind of Hash object it is.
        rb_hash_bulk_insert(argc, argv, ret);
    }
    return ret;
}

SORBET_INLINE
long sorbet_literalHashBuild(int argc, const VALUE *argv) {
    VALUE ret = sorbet_hashBuild(argc, argv);
    long index = sorbet_globalConstRegister(ret);
    return index;
}

SORBET_INLINE
VALUE sorbet_hashDup(VALUE hash) {
    return rb_hash_dup(hash);
}

SORBET_INLINE
void sorbet_hashStore(VALUE hash, VALUE key, VALUE value) {
    rb_hash_aset(hash, key, value);
}

SORBET_INLINE
VALUE sorbet_hashGet(VALUE hash, VALUE key) {
    return rb_hash_aref(hash, key);
}

// possible return values for `func`:
//  - ST_CONTINUE, then the rest of the hash is processed as normal.
//  - ST_STOP, then no further processing of the hash is done.
//  - ST_DELETE, then the current hash key is deleted from the hash and the rest
//  of the hash is processed
//  - ST_CHECK, then the hash is checked to see if it has been modified during
//  this operation. If so, processing of the hash stops.
/*
void sorbet_hashEach(VALUE hash, int(*func)(VALUE key, VALUE val,
VALUE in), VALUE closure) { return rb_hash_foreach(hash, func, closure);
}
*/

// ****
// ****                       Operations on Strings
// ****

SORBET_INLINE
const char *sorbet_rubyStringToCPtr(VALUE value) {
    return RSTRING_PTR(value);
}

SORBET_INLINE
long sorbet_rubyStringLength(VALUE value) {
    return RSTRING_LEN(value);
}

SORBET_INLINE
VALUE sorbet_cPtrToRubyString(const char *ptr, long length) {
    return rb_str_new(ptr, length);
}

SORBET_INLINE
VALUE sorbet_cPtrToRubyStringFrozen(const char *ptr, long length) {
    VALUE ret = sorbet_vm_fstring_new(ptr, length);
    rb_gc_register_mark_object(ret);
    return ret;
}

SORBET_INLINE
VALUE sorbet_cPtrToRubyRegexpFrozen(const char *ptr, long length, int options) {
    VALUE ret = rb_reg_new(ptr, length, options);
    rb_gc_register_mark_object(ret);
    return ret;
}

SORBET_INLINE
VALUE sorbet_stringPlus(VALUE str1, VALUE str2) {
    return rb_str_plus(str1, str2);
}

// ****
// ****                       Tests
// ****

SORBET_INLINE
_Bool sorbet_testIsTruthy(VALUE value) {
    return RB_TEST(value);
}

SORBET_INLINE
_Bool sorbet_testIsUndef(VALUE value) {
    return value == RUBY_Qundef;
}

// https://ruby-doc.org/core-2.6.3/Object.html#method-i-eql-3F
SORBET_INLINE
_Bool sorbet_testObjectEqual_p(VALUE obj1, VALUE obj2) {
    return obj1 == obj2;
}

SORBET_INLINE
void sorbet_ensure_arity(int argc, int expected) {
    if (UNLIKELY(argc != expected)) {
        sorbet_raiseArity(argc, expected, expected);
    }
}

SORBET_INLINE
void sorbet_checkStack() {
    // This is actually pretty slow. We should probably use guard pages instead.
    ruby_stack_check();
}

SORBET_INLINE
VALUE sorbet_boolToRuby(_Bool b) {
    if (b) {
        return RUBY_Qtrue;
    }
    return RUBY_Qfalse;
}

// TODO: add many from https://github.com/ruby/ruby/blob/ruby_2_6/include/ruby/intern.h#L55
SORBET_INLINE
VALUE sorbet_T_unsafe(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk, VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    return argv[0];
}

SORBET_INLINE
VALUE sorbet_T_must(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk, VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    if (UNLIKELY(argv[0] == Qnil)) {
        rb_raise(rb_eTypeError, "Passed `nil` into T.must");
    } else {
        return argv[0];
    }
}

SORBET_INLINE
VALUE sorbet_rb_sym_equal(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                          VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    return sorbet_boolToRuby(recv == argv[0]);
}

SORBET_INLINE
VALUE sorbet_Thread_current(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                            VALUE closure) {
    return rb_thread_current();
}

// https://github.com/ruby/ruby/blob/5445e0435260b449decf2ac16f9d09bae3cafe72/thread.c#L3281-L3287
SORBET_INLINE
VALUE sorbet_Thread_square_br(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                              VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    VALUE key = argv[0];
    ID id = rb_check_id(&key);
    if (!id) {
        return Qnil;
    }
    return rb_thread_local_aref(recv, id);
}

// https://github.com/ruby/ruby/blob/5445e0435260b449decf2ac16f9d09bae3cafe72/thread.c#L3386-L3390
SORBET_INLINE
VALUE sorbet_Thread_square_br_eq(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                 VALUE closure) {
    sorbet_ensure_arity(argc, 2);
    VALUE id = argv[0];
    VALUE val = argv[1];
    return rb_thread_local_aset(recv, rb_to_id(id), val);
}

// https://github.com/ruby/ruby/blob/5445e0435260b449decf2ac16f9d09bae3cafe72/thread.c#L3386-L3390
SORBET_INLINE
VALUE sorbet_rb_obj_is_kind_of(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                               VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    VALUE klass = argv[0];
    return rb_obj_is_kind_of(recv, klass);
}

VALUE sorbet_rb_array_len(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                          VALUE closure) {
    sorbet_ensure_arity(argc, 0);
    return LONG2FIX(rb_array_len(recv));
}

SORBET_INLINE
VALUE sorbet_rb_array_square_br(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                VALUE closure) {
    VALUE ary = recv;
    rb_check_arity(argc, 1, 2);
    if (LIKELY(argc == 1)) {
        VALUE arg = argv[0];
        if (LIKELY(FIXNUM_P(arg))) {
            return rb_ary_entry(ary, FIX2LONG(arg));
        }
    }
    return sorbet_rb_array_square_br_slowpath(recv, fun, argc, argv, blk, closure);
}

static VALUE sorbet_array_enum_length(VALUE recv, VALUE args, VALUE eobj) {
    long len = RARRAY_LEN(recv);
    return LONG2NUM(len);
}

// This is the no-block version of rb_ary_each: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L2128-L2138
// In that version, the `RETURN_SIZED_ENUMERATOR` macro is what causes the early return when a block is not passed. In
// this case, we know that the block wasn't passed, so we always return an enumerator
SORBET_INLINE
VALUE sorbet_rb_array_each(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                           VALUE closure) {
    rb_check_arity(argc, 0, 0);
    return rb_enumeratorize_with_size(recv, ID2SYM(fun), argc, argv, sorbet_array_enum_length);
}

// This is the block version of rb_ary_each: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L2128-L2138
// In that version the for loop uses `rb_yield`, whereas we call the block function pointer directly.
SORBET_INLINE
VALUE sorbet_rb_array_each_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                     const struct rb_captured_block *captured, VALUE closure, int numPositionalArgs) {
    rb_check_arity(argc, 0, 0);

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    for (int i = 0; i < RARRAY_LEN(recv); ++i) {
        VALUE val = RARRAY_AREF(recv, i);
        blk(val, closure, 1, &val, Qnil);
    }

    sorbet_popFrame();

    return recv;
}

// This is the no-block version of enum_each_with_object for arrays:
// https://github.com/ruby/ruby/blob/b0b7751f3b94e7983d124e43102f76ff598caabd/enum.c#L2749-L2757 In that version, the
// `RETURN_SIZED_ENUMERATOR` macro is what causes the early return when a block is not passed. In this case, we know
// that the block wasn't passed, so we always return an enumerator
SORBET_INLINE
VALUE sorbet_rb_array_each_with_object(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                       VALUE closure) {
    rb_check_arity(argc, 1, 1);
    return rb_enumeratorize_with_size(recv, ID2SYM(fun), argc, argv, sorbet_array_enum_length);
}

// This is the block version of Array#each_with_object -- which doesn't exist as a separate C function in the VM.
// In the no-block version, above, the code uses `rb_yield`, whereas we call the block function pointer directly.
SORBET_INLINE
VALUE sorbet_rb_array_each_with_object_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv,
                                                 BlockFFIType blk, const struct rb_captured_block *captured,
                                                 VALUE closure, int numPositionalArgs) {
    rb_check_arity(argc, 1, 1);

    VALUE object = argv[0];
    VALUE block_argv[2];
    block_argv[1] = object;

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    for (long i = 0; i < RARRAY_LEN(recv); ++i) {
        VALUE val = RARRAY_AREF(recv, i);
        block_argv[0] = val;
        blk(val, closure, 2, &block_argv[0], Qnil);
    }

    sorbet_popFrame();

    return object;
}

// This is the no-block version of rb_ary_select: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L3212-L3226
// In that version, the `RETURN_SIZED_ENUMERATOR` macro is what causes the early return when a block is not passed. In
// this case, we know that the block wasn't passed, so we always return an enumerator
SORBET_INLINE
VALUE sorbet_rb_array_select(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                             VALUE closure) {
    rb_check_arity(argc, 0, 0);
    return rb_enumeratorize_with_size(recv, ID2SYM(fun), argc, argv, sorbet_array_enum_length);
}

// This is the block version of rb_ary_select: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L3212-L3226
// In that version the for loop uses `rb_yield`, whereas we call the block function pointer directly.
SORBET_INLINE
VALUE sorbet_rb_array_select_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                       const struct rb_captured_block *captured, VALUE closure, int numPositionalArgs) {
    rb_check_arity(argc, 0, 0);
    VALUE result = rb_ary_new2(RARRAY_LEN(recv));

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    for (long i = 0; i < RARRAY_LEN(recv); ++i) {
        VALUE val = RARRAY_AREF(recv, i);
        VALUE ret = blk(val, closure, 1, &val, Qnil);
        if (RTEST(ret)) {
            rb_ary_push(result, val);
        }
    }

    sorbet_popFrame();

    return result;
}

// This is the non-block version of rb_enum_find: https://github.com/ruby/ruby/blob/ruby_2_7/enum.c#L292-L309
// In that version, the `RETURN_ENUMERATOR` macro is what causes the early return when a block is not passed. In
// this case, we know that the block wasn't passed, so we always return an enumerator
SORBET_INLINE
VALUE sorbet_rb_array_find(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                           VALUE closure) {
    rb_check_arity(argc, 1, 1);
    return rb_enumeratorize_with_size(recv, ID2SYM(fun), argc, argv, sorbet_array_enum_length);
}

// This is the block version of rb_enum_find: https://github.com/ruby/ruby/blob/ruby_2_7/enum.c#L292-L309
// That version uses `rb_block_call`, whereas we call the block function pointer directly.
SORBET_INLINE
VALUE sorbet_rb_array_find_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                     const struct rb_captured_block *captured, VALUE closure, int numPositionalArgs) {
    rb_check_arity(argc, 0, 1);
    VALUE result = Qnil;
    VALUE if_none = argc == 1 ? argv[0] : Qnil;

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    for (long i = 0; i < RARRAY_LEN(recv); ++i) {
        VALUE val = RARRAY_AREF(recv, i);
        VALUE ret = blk(val, closure, 1, &val, Qnil);
        if (RTEST(ret)) {
            result = val;
            break;
        }
    }

    sorbet_popFrame();

    if (NIL_P(result) && !NIL_P(if_none)) {
        return rb_funcallv(if_none, idCall, 0, 0);
    }

    return result;
}

// This is the no-block version of rb_ary_collect: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L3056-L3068
// In that version, the `RETURN_SIZED_ENUMERATOR` macro is what causes the early return when a block is not passed. In
// this case, we know that the block wasn't passed, so we always return an enumerator
SORBET_INLINE
VALUE sorbet_rb_array_collect(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                              VALUE closure) {
    rb_check_arity(argc, 0, 0);
    return rb_enumeratorize_with_size(recv, ID2SYM(fun), argc, argv, sorbet_array_enum_length);
}

// This is the no-block version of rb_ary_collect: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L3056-L3068
// In that version the for loop uses `rb_yield`, whereas we call the block function pointer directly.
SORBET_INLINE
VALUE sorbet_rb_array_collect_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv,
                                        BlockFFIType blk, const struct rb_captured_block *captured, VALUE closure,
                                        int numPositionalArgs) {
    rb_check_arity(argc, 0, 0);

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    // We can't coalesce the RARRAY_LEN calls because the loop needs to be responsive
    // to changes in the array's length.
    VALUE collect = rb_ary_new2(RARRAY_LEN(recv));

    for (long i = 0; i < RARRAY_LEN(recv); ++i) {
        VALUE val = RARRAY_AREF(recv, i);
        rb_ary_push(collect, blk(val, closure, 1, &val, Qnil));
    }

    sorbet_popFrame();

    return collect;
}

// This is the no-block version of rb_ary_collect_bang: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L3092-L3103
SORBET_INLINE
VALUE sorbet_rb_array_collect_bang(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                   VALUE closure) {
    rb_check_arity(argc, 0, 0);
    return rb_enumeratorize_with_size(recv, ID2SYM(fun), argc, argv, sorbet_array_enum_length);
}

// This is the block version of rb_ary_collect_bang: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L3092-L3103
SORBET_INLINE
VALUE sorbet_rb_array_collect_bang_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv,
                                             BlockFFIType blk, const struct rb_captured_block *captured, VALUE closure,
                                             int numPositionalArgs) {
    rb_check_arity(argc, 0, 0);

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    rb_ary_modify(recv);
    for (long i = 0; i < RARRAY_LEN(recv); i++) {
        VALUE val = RARRAY_AREF(recv, i);
        rb_ary_store(recv, i, blk(val, closure, 1, &val, Qnil));
    }

    sorbet_popFrame();

    return recv;
}

// This is the no-block version of rb_ary_any_p: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L6338-L6364
SORBET_INLINE
VALUE sorbet_rb_array_any(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                          VALUE closure) {
    rb_check_arity(argc, 0, 1);
    long len = RARRAY_LEN(recv);
    if (argc == 1) {
        for (long i = 0; i < len; ++i) {
            if (RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(recv, i)))) {
                return Qtrue;
            }
        }
    } else {
        for (long i = 0; i < len; ++i) {
            if (RTEST(RARRAY_AREF(recv, i))) {
                return Qtrue;
            }
        }
    }
    return Qfalse;
}

// This is the block version of rb_ary_any_p: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L6338-L6364
// In that version the for loop uses `rb_yield`, whereas we call the block function pointer directly.
SORBET_INLINE
VALUE sorbet_rb_array_any_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                    const struct rb_captured_block *captured, VALUE closure, int numPositionalArgs) {
    rb_check_arity(argc, 0, 0);

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    for (long i = 0; i < RARRAY_LEN(recv); ++i) {
        VALUE val = RARRAY_AREF(recv, i);
        VALUE ret = blk(val, closure, 1, &val, Qnil);
        if (RTEST(ret)) {
            sorbet_popFrame();
            return Qtrue;
        }
    }

    sorbet_popFrame();

    return Qfalse;
}

// This is the no-block version of rb_ary_all_p: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L6374-L6400
SORBET_INLINE
VALUE sorbet_rb_array_all(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                          VALUE closure) {
    rb_check_arity(argc, 0, 1);
    long len = RARRAY_LEN(recv);
    if (argc == 1) {
        for (long i = 0; i < len; ++i) {
            if (!RTEST(rb_funcall(argv[0], idEqq, 1, RARRAY_AREF(recv, i)))) {
                return Qfalse;
            }
        }
    } else {
        for (long i = 0; i < len; ++i) {
            if (!RTEST(RARRAY_AREF(recv, i))) {
                return Qfalse;
            }
        }
    }
    return Qtrue;
}

// This is the block version of rb_ary_all_p: https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L6374-L6400
// In that version the for loop uses `rb_yield`, whereas we call the block function pointer directly.
SORBET_INLINE
VALUE sorbet_rb_array_all_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                    const struct rb_captured_block *captured, VALUE closure, int numPositionalArgs) {
    rb_check_arity(argc, 0, 0);

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    for (long i = 0; i < RARRAY_LEN(recv); ++i) {
        VALUE val = RARRAY_AREF(recv, i);
        VALUE ret = blk(val, closure, 1, &val, Qnil);
        if (!RTEST(ret)) {
            sorbet_popFrame();
            return Qfalse;
        }
    }

    sorbet_popFrame();

    return Qtrue;
}

// This is an inlinable version of rb_ary_compact_bang https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L5088-L5094
SORBET_INLINE
VALUE sorbet_rb_array_compact_bang(VALUE ary, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                   VALUE closure) {
    return rb_ary_compact_bang_forwarder(ary);
}

// This is an inlinable version of rb_ary_compact https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L5088-L5094
SORBET_INLINE
VALUE sorbet_rb_array_compact(VALUE ary, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                              VALUE closure) {
    ary = rb_ary_dup(ary);
    rb_ary_compact_bang_forwarder(ary);
    return ary;
}

// This is the no-block version of rb_ary_to_h https://github.com/ruby/ruby/blob/ruby_2_7/array.c#L2496-L2518
SORBET_INLINE
VALUE sorbet_rb_array_to_h(VALUE ary, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                           VALUE closure) {
    // the uses of RARRAY_LEN in rb_ary_to_h can be coalesced because there's no block passed in this case
    long len = RARRAY_LEN(ary);
    VALUE hash = rb_hash_new_with_size(len);

    for (long i = 0; i < len; i++) {
        const VALUE elt = RARRAY_AREF(ary, i);
        const VALUE key_value_pair = rb_check_array_type(elt);
        if (NIL_P(key_value_pair)) {
            rb_raise(rb_eTypeError, "wrong element type %" PRIsVALUE " at %ld (expected array)", rb_obj_class(elt), i);
        }
        if (RARRAY_LEN(key_value_pair) != 2) {
            rb_raise(rb_eArgError, "wrong array length at %ld (expected 2, was %ld)", i, RARRAY_LEN(key_value_pair));
        }
        rb_hash_aset(hash, RARRAY_AREF(key_value_pair, 0), RARRAY_AREF(key_value_pair, 1));
    }

    return hash;
}

// This is an adjusted version of the intrinsic from the ruby vm. The major change is that instead of handling the case
// where a range is used as the key, we defer back to the VM.
// https://github.com/ruby/ruby/blob/ruby_2_6/array.c#L1980-L2005
SORBET_INLINE
VALUE sorbet_rb_array_square_br_eq(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                   VALUE closure) {
    long offset, beg, len;

    if (UNLIKELY(argc == 3)) {
        goto range;
    }
    rb_check_arity(argc, 2, 2);
    rb_check_frozen(recv);
    if (LIKELY(FIXNUM_P(argv[0]))) {
        offset = FIX2LONG(argv[0]);
        goto fixnum;
    }
    if (UNLIKELY(rb_range_beg_len(argv[0], &beg, &len, RARRAY_LEN(recv), 1))) {
    range:
        return rb_funcallv(recv, fun, argc, argv);
    }
    offset = NUM2LONG(argv[0]);
fixnum:
    rb_ary_store(recv, offset, argv[1]);
    return argv[1];
}

SORBET_INLINE
VALUE sorbet_rb_array_empty(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                            VALUE closure) {
    rb_check_arity(argc, 0, 0);
    if (RARRAY_LEN(recv) == 0) {
        return Qtrue;
    }
    return Qfalse;
}

SORBET_INLINE
VALUE sorbet_rb_hash_square_br(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                               VALUE closure) {
    rb_check_arity(argc, 1, 1);
    return rb_hash_aref(recv, argv[0]);
}

SORBET_INLINE
VALUE sorbet_rb_hash_square_br_eq(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                  VALUE closure) {
    rb_check_arity(argc, 2, 2);
    return rb_hash_aset(recv, argv[0], argv[1]);
}

SORBET_INLINE
VALUE sorbet_rb_int_plus(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                         VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    VALUE y = argv[0];
    if (LIKELY(FIXNUM_P(recv))) {
        if (LIKELY(FIXNUM_P(y))) {
            return rb_fix_plus_fix(recv, y);
        }
    }
    return sorbet_rb_int_plus_slowpath(recv, y);
}

SORBET_INLINE
VALUE sorbet_rb_int_minus(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                          VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    // optimized version from numeric.c
    VALUE y = argv[0];
    if (LIKELY(FIXNUM_P(recv))) {
        if (LIKELY(FIXNUM_P(y))) {
            return rb_fix_minus_fix(recv, y);
        }
    }
    return sorbet_rb_int_minus_slowpath(recv, y);
}

SORBET_INLINE
VALUE sorbet_rb_int_mul(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                        VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    return rb_int_mul(recv, argv[0]);
}

SORBET_INLINE
VALUE sorbet_rb_int_div(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                        VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    return rb_int_div(recv, argv[0]);
}

SORBET_INLINE
VALUE sorbet_rb_int_lt(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                       VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    VALUE y = argv[0];
    if (LIKELY(FIXNUM_P(recv))) {
        if (LIKELY(FIXNUM_P(y))) {
            if (FIX2LONG(recv) < FIX2LONG(y)) {
                return Qtrue;
            }
            return Qfalse;
        }
    }
    return sorbet_rb_int_lt_slowpath(recv, y);
}

SORBET_INLINE
VALUE sorbet_rb_int_gt(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                       VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    VALUE y = argv[0];
    if (LIKELY(FIXNUM_P(recv))) {
        if (LIKELY(FIXNUM_P(y))) {
            if (FIX2LONG(recv) > FIX2LONG(y)) {
                return Qtrue;
            }
            return Qfalse;
        }
    }
    return sorbet_rb_int_gt_slowpath(recv, y);
}

SORBET_INLINE
VALUE sorbet_rb_int_le(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                       VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    VALUE y = argv[0];
    if (LIKELY(FIXNUM_P(recv))) {
        if (LIKELY(FIXNUM_P(y))) {
            if (FIX2LONG(recv) <= FIX2LONG(y)) {
                return Qtrue;
            }
            return Qfalse;
        }
    }
    return sorbet_rb_int_le_slowpath(recv, y);
}

SORBET_INLINE
VALUE sorbet_rb_int_ge(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                       VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    VALUE y = argv[0];
    if (LIKELY(FIXNUM_P(recv))) {
        if (LIKELY(FIXNUM_P(y))) {
            if (FIX2LONG(recv) >= FIX2LONG(y)) {
                return Qtrue;
            }
            return Qfalse;
        }
    }
    return sorbet_rb_int_ge_slowpath(recv, y);
}

SORBET_INLINE
VALUE sorbet_rb_int_equal(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                          VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    return rb_int_equal(recv, argv[0]);
}

SORBET_INLINE
VALUE sorbet_rb_int_neq(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                        VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    return sorbet_boolToRuby(rb_int_equal(recv, argv[0]) == RUBY_Qfalse);
}

SORBET_INLINE
VALUE sorbet_rb_int_to_s(VALUE x, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk, VALUE closure) {
    int base;

    rb_check_arity(argc, 0, 1);
    if (argc == 1) {
        base = NUM2INT(argv[0]);
    } else {
        base = 10;
    }
    if (LIKELY(FIXNUM_P(x))) {
        return rb_fix2str(x, base);
    }
    if (RB_TYPE_P(x, T_BIGNUM)) {
        return rb_big2str(x, base);
    }

    return rb_any_to_s(x);
}

static VALUE sorbet_int_dotimes_size(VALUE num, VALUE args, VALUE eobj) {
    if (FIXNUM_P(num)) {
        if (NUM2LONG(num) <= 0)
            return INT2FIX(0);
    } else {
        if (RTEST(rb_funcall(num, '<', 1, INT2FIX(0))))
            return INT2FIX(0);
    }
    return num;
}

// This is the enumerator version of `rb_int_dotimes`: https://github.com/ruby/ruby/blob/ruby_2_7/numeric.c#L5196-L5219
// `RETURN_SIZED_ENUMERATOR` is what causes the early return in that version when no block is passed, but here we know
// that no block is passed and unconditionally make the enumerator.
SORBET_INLINE
VALUE sorbet_rb_int_dotimes(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                            VALUE closure) {
    return rb_enumeratorize_with_size(recv, ID2SYM(fun), argc, argv, sorbet_int_dotimes_size);
}

// This is the looping version of `rb_int_dotimes`: https://github.com/ruby/ruby/blob/ruby_2_7/numeric.c#L5196-L5219
// The implementation is very similar, but we call the block function directly instead of using `rb_yield` to aid
// inlining.
SORBET_INLINE
VALUE sorbet_rb_int_dotimes_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                      const struct rb_captured_block *captured, VALUE closure, int numPositionalArgs) {
    rb_check_arity(argc, 0, 0);

    sorbet_pushBlockFrame(captured);

    if (LIKELY(FIXNUM_P(recv))) {
        long i, end;

        end = FIX2LONG(recv);
        for (i = 0; i < end; i++) {
            VALUE val = LONG2FIX(i);
            blk(val, closure, 1, &val, Qnil);
        }
    } else {
        VALUE i = INT2FIX(0);

        for (;;) {
            if (!RTEST(rb_funcall(i, '<', 1, recv)))
                break;
            VALUE val = LONG2FIX(i);
            blk(val, closure, 1, &val, Qnil);
            i = rb_funcall(i, '+', 1, INT2FIX(1));
        }
    }

    sorbet_popFrame();

    return recv;
}

static VALUE sorbet_hash_enum_size(VALUE recv, VALUE args, VALUE eobj) {
    return rb_hash_size(recv);
}

// This is the no-block version of rb_hash_each_pair: https://github.com/ruby/ruby/blob/ruby_2_7/hash.c#L3088-L3097
// In that version, the `RETURN_SIZED_ENUMERATOR` macro is what causes the early return when a block is not passed. In
// this case, we know that the block wasn't passed, so we always return an enumerator
SORBET_INLINE
VALUE sorbet_rb_hash_each_pair(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                               VALUE closure) {
    rb_check_arity(argc, 0, 0);
    return rb_enumeratorize_with_size(recv, ID2SYM(fun), argc, argv, sorbet_hash_enum_size);
}

struct sorbet_rb_hash_each_closure {
    BlockFFIType fun;
    VALUE toplevel_closure;
};

static int sorbet_rb_hash_each_fun_fast(VALUE key, VALUE value, VALUE closure) {
    VALUE argv[2];
    argv[0] = key;
    argv[1] = value;
    struct sorbet_rb_hash_each_closure *c = (struct sorbet_rb_hash_each_closure *)closure;
    c->fun(key, c->toplevel_closure, 2, &argv[0], Qnil);
    return ST_CONTINUE;
}

static int sorbet_rb_hash_each_fun_slow(VALUE key, VALUE value, VALUE closure) {
    VALUE array = rb_assoc_new(key, value);
    struct sorbet_rb_hash_each_closure *c = (struct sorbet_rb_hash_each_closure *)closure;
    c->fun(key, c->toplevel_closure, 1, &array, Qnil);
    return ST_CONTINUE;
}

// This is the block version of rb_hash_each_pair: https://github.com/ruby/ruby/blob/ruby_2_7/hash.c#L3088-L3097
// In that version the for loop uses `rb_yield`, whereas we call the block function pointer directly.
SORBET_INLINE
VALUE sorbet_rb_hash_each_pair_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv,
                                         BlockFFIType blk, const struct rb_captured_block *captured, VALUE closure,
                                         int numPositionalArgs) {
    rb_check_arity(argc, 0, 0);

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    struct sorbet_rb_hash_each_closure passthrough;
    passthrough.fun = blk;
    passthrough.toplevel_closure = closure;
    rb_hash_foreach(recv, numPositionalArgs > 1 ? sorbet_rb_hash_each_fun_fast : sorbet_rb_hash_each_fun_slow,
                    (VALUE)&passthrough);

    sorbet_popFrame();

    return recv;
}

// This is the no-block version of enum_each_with_object:
// https://github.com/ruby/ruby/blob/b0b7751f3b94e7983d124e43102f76ff598caabd/enum.c#L2749-L2757 In that version, the
// `RETURN_SIZED_ENUMERATOR` macro is what causes the early return when a block is not passed. In this case, we know
// that the block wasn't passed, so we always return an enumerator
SORBET_INLINE
VALUE sorbet_rb_hash_each_with_object(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                      VALUE closure) {
    rb_check_arity(argc, 1, 1);
    return rb_enumeratorize_with_size(recv, ID2SYM(fun), argc, argv, sorbet_hash_enum_size);
}

struct sorbet_rb_hash_each_with_object_closure {
    BlockFFIType fun;
    VALUE toplevel_closure;
    // We use this to pass to the block function; argv[0] is going to be rewritten
    // on each iteration with the [k, v] array.  argv[1] will be written once outside
    // of the iteration with the object to be passed.
    VALUE argv[2];
};

static int sorbet_rb_hash_each_with_object_fun(VALUE key, VALUE value, VALUE closure) {
    // TODO: it would be nice if we could statically analyze the block that each_with_object
    // is being called with and determine that we could safely re-use an array on every
    // iteration,.
    VALUE array = rb_assoc_new(key, value);
    struct sorbet_rb_hash_each_with_object_closure *c = (struct sorbet_rb_hash_each_with_object_closure *)closure;
    c->argv[0] = array;
    c->fun(array, c->toplevel_closure, 2, &c->argv[0], Qnil);
    return ST_CONTINUE;
}

// This is the block version of Hash#each_with_object -- which doesn't exist as a separate C function in the VM.
// In the no-block version, above, the code uses `rb_yield`, whereas we call the block function pointer directly.
SORBET_INLINE
VALUE sorbet_rb_hash_each_with_object_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv,
                                                BlockFFIType blk, const struct rb_captured_block *captured,
                                                VALUE closure, int numPositionalArgs) {
    rb_check_arity(argc, 1, 1);

    VALUE object = argv[0];

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    struct sorbet_rb_hash_each_with_object_closure passthrough;
    passthrough.fun = blk;
    passthrough.toplevel_closure = closure;
    passthrough.argv[1] = object;
    rb_hash_foreach(recv, sorbet_rb_hash_each_with_object_fun, (VALUE)&passthrough);

    sorbet_popFrame();

    return object;
}

struct sorbet_rb_hash_any_closure {
    BlockFFIType fun;
    VALUE toplevel_closure;
    VALUE retval;
};

extern VALUE sorbet_rb_hash_any_forwarder(int argc, VALUE *argv, VALUE hash);

// no-block rb_hash_any_p: https://github.com/ruby/ruby/blob/67f1cd20bfb97ff6e5a15d27c8ef06cdb97ed37a/hash.c#L4354-L4381
SORBET_INLINE
VALUE sorbet_rb_hash_any(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                         VALUE closure) {
    return sorbet_rb_hash_any_forwarder(argc, (VALUE *)argv, recv);
}

static int sorbet_rb_hash_any_fun_fast(VALUE key, VALUE value, VALUE arg) {
    VALUE argv[2];
    argv[0] = key;
    argv[1] = value;
    struct sorbet_rb_hash_any_closure *c = (struct sorbet_rb_hash_any_closure *)arg;
    VALUE ret = c->fun(key, c->toplevel_closure, 2, argv, Qnil);
    if (RTEST(ret)) {
        c->retval = Qtrue;
        return ST_STOP;
    }
    return ST_CONTINUE;
}

static int sorbet_rb_hash_any_fun_slow(VALUE key, VALUE value, VALUE arg) {
    VALUE array = rb_assoc_new(key, value);
    struct sorbet_rb_hash_any_closure *c = (struct sorbet_rb_hash_any_closure *)arg;
    VALUE ret = c->fun(key, c->toplevel_closure, 1, &array, Qnil);
    if (RTEST(ret)) {
        c->retval = Qtrue;
        return ST_STOP;
    }
    return ST_CONTINUE;
}

// block rb_hash_any_p: https://github.com/ruby/ruby/blob/67f1cd20bfb97ff6e5a15d27c8ef06cdb97ed37a/hash.c#L4354-L4381
SORBET_INLINE
VALUE sorbet_rb_hash_any_withBlock(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                   const struct rb_captured_block *captured, VALUE closure, int numPositionalArgs) {
    // TODO: do we need to handle argc == 1?
    rb_check_arity(argc, 0, 1);

    // correctness first
    if (UNLIKELY(argc == 1)) {
        return sorbet_rb_hash_any_forwarder(argc, (VALUE *)argv, recv);
    }

    if (RHASH_EMPTY_P(recv)) {
        return Qfalse;
    }

    // must push a frame for the captured block
    sorbet_pushBlockFrame(captured);

    struct sorbet_rb_hash_any_closure passthrough;
    passthrough.fun = blk;
    passthrough.toplevel_closure = closure;
    passthrough.retval = Qfalse;
    // Hash#any is a little weird: the VM will dynamically check the arity of the
    // block and pass a different number of args as appropriate.  This mimics the
    // array unpacking that blocks would normally do, except that we can do it
    // faster in the caller because we don't have to allocate the array each time.
    rb_hash_foreach(recv, numPositionalArgs > 1 ? sorbet_rb_hash_any_fun_fast : sorbet_rb_hash_any_fun_slow,
                    (VALUE)&passthrough);

    sorbet_popFrame();

    return passthrough.retval;
}

// ****
// ****                       Name Based Intrinsics
// ****

SORBET_INLINE
VALUE sorbet_magic_toHashDup(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                             VALUE closure) {
    sorbet_ensure_arity(argc, 1);

    // if this is too slow, we can inline the type conversion code
    VALUE hash = rb_to_hash_type(argv[0]);

    return rb_hash_dup(hash);
}

SORBET_INLINE
VALUE sorbet_magic_toHashNoDup(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                               VALUE closure) {
    sorbet_ensure_arity(argc, 1);

    // if this is too slow, we can inline the type conversion code
    return rb_to_hash_type(argv[0]);
}

SORBET_INLINE
VALUE sorbet_magic_mergeHash(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                             VALUE closure) {
    sorbet_ensure_arity(argc, 2);

    return sorbet_magic_mergeHashHelper(argv[0], argv[1]);
}

SORBET_INLINE
VALUE sorbet_magic_mergeHashValues(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                   VALUE closure) {
    if (UNLIKELY((argc % 2) != 1)) {
        sorbet_raiseArity(argc, 1, UNLIMITED_ARGUMENTS);
    }

    VALUE hash = argv[0];
    rb_hash_bulk_insert(argc - 1, argv + 1, hash);
    return hash;
}

SORBET_INLINE
VALUE sorbet_splatIntrinsic(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                            VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    return sorbet_vm_splatIntrinsic(argv[0]);
}

SORBET_INLINE
VALUE sorbet_expandSplatIntrinsic(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                  VALUE closure) {
    sorbet_ensure_arity(argc, 3);
    return sorbet_vm_expandSplatIntrinsic(argv[0], argv[1], argv[2]);
}

SORBET_INLINE
VALUE sorbet_buildHashIntrinsic(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                VALUE closure) {
    return sorbet_hashBuild(argc, argv);
}

SORBET_INLINE
VALUE sorbet_buildArrayIntrinsic(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                 VALUE closure) {
    if (argc == 0) {
        return rb_ary_new();
    }
    return rb_ary_new_from_values(argc, argv);
}

SORBET_INLINE
VALUE sorbet_buildRangeIntrinsic(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                                 VALUE closure) {
    sorbet_ensure_arity(argc, 3);

    VALUE start = argv[0];
    VALUE end = argv[1];
    VALUE excludeEnd = argv[2];
    return rb_range_new(start, end, excludeEnd);
}

SORBET_INLINE
VALUE sorbet_check_match_array(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                               VALUE closure) {
    sorbet_ensure_arity(argc, 2);
    return sorbet_vm_check_match_array(GET_EC(), argv[0], argv[1]);
}

SORBET_INLINE
VALUE sorbet_int_bool_true(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                           VALUE closure) {
    return Qtrue;
}

SORBET_INLINE
VALUE sorbet_int_bool_false(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                            VALUE closure) {
    return Qfalse;
}

SORBET_INLINE
VALUE sorbet_int_bool_and(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                          VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    if (argv[0] != Qnil && argv[0] != Qfalse) {
        return Qtrue;
    }
    return Qfalse;
}

SORBET_INLINE
VALUE sorbet_int_bool_nand(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk,
                           VALUE closure) {
    sorbet_ensure_arity(argc, 1);
    if (argv[0] != Qnil && argv[0] != Qfalse) {
        return Qfalse;
    }
    return Qtrue;
}

SORBET_INLINE
VALUE sorbet_bang(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk, VALUE closure) {
    // RTEST is false when the value is Qfalse or Qnil
    if (RTEST(recv)) {
        if (recv == Qtrue) {
            return Qfalse;
        } else {
            // slow path - dispatch via the VM
            return rb_funcallv(recv, fun, argc, argv);
        }
    } else {
        return Qtrue;
    }
}

SORBET_INLINE
VALUE sorbet_nil_p(VALUE recv, ID fun, int argc, const VALUE *const restrict argv, BlockFFIType blk, VALUE closure) {
    return sorbet_isa_NilClass(recv) ? Qtrue : Qfalse;
}

SORBET_INLINE
VALUE sorbet_selfNew(VALUE recv, ID fun, int argc, VALUE *argv, BlockFFIType blk, VALUE closure) {
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    VALUE obj = argv[0];
    return rb_funcallv(obj, rb_intern("new"), argc - 1, argv + 1);
}

// ****
// ****                       Calls
// ****

// When no double-splat is present, only lookup entries in the keyword argument hash, don't delete them.
SORBET_INLINE
VALUE sorbet_getKWArg(VALUE maybeHash, VALUE key) {
    if (maybeHash == RUBY_Qundef) {
        return RUBY_Qundef;
    }

    return rb_hash_lookup2(maybeHash, key, RUBY_Qundef);
}

// When building up a double-splat, reuse the original hash for the double-splat arg by deleting the entries that we
// parse out of it.
SORBET_INLINE
VALUE sorbet_removeKWArg(VALUE maybeHash, VALUE key) {
    if (maybeHash == RUBY_Qundef) {
        return RUBY_Qundef;
    }

    return rb_hash_delete_entry(maybeHash, key);
}

SORBET_INLINE
void sorbet_assertAllRequiredKWArgs(VALUE missing) {
    if (LIKELY(missing == RUBY_Qundef)) {
        return;
    }

    sorbet_raiseMissingKeywords(missing);
}

SORBET_INLINE
VALUE sorbet_assertNoExtraKWArg(VALUE maybeHash, int requiredKwargs, int optionalParsed) {
    if (maybeHash == RUBY_Qundef) {
        return RUBY_Qundef;
    }

    int size = rb_hash_size_num(maybeHash);
    if (LIKELY((size - requiredKwargs) == optionalParsed)) {
        return RUBY_Qundef;
    }

    sorbet_raiseExtraKeywords(maybeHash);
}

SORBET_INLINE
VALUE sorbet_readKWRestArgs(VALUE maybeHash) {
    // This is similar to what the Ruby VM does:
    // https://github.com/ruby/ruby/blob/37c2cd3fa47c709570e22ec4dac723ca211f423a/vm_args.c#L483-L487
    if (maybeHash == RUBY_Qundef) {
        return rb_hash_new();
    }
    return rb_hash_dup(maybeHash);
}

SORBET_INLINE
VALUE sorbet_readRestArgs(int maxPositionalArgCount, int actualArgCount, VALUE *argArray) {
    if (maxPositionalArgCount >= actualArgCount) {
        return rb_ary_new();
    }
    return rb_ary_new_from_values(actualArgCount - maxPositionalArgCount, argArray + maxPositionalArgCount);
}

SORBET_INLINE
const VALUE **sorbet_getPc(rb_control_frame_t *cfp) {
    return &cfp->pc;
}

SORBET_INLINE
void sorbet_setLineNumber(int offset, VALUE *encoded, VALUE **storeLocation) {
    // use pos+1 because PC should point at the next instruction
    (*storeLocation) = encoded + offset + 1;
}

// https://github.com/ruby/ruby/blob/a9a48e6a741f048766a2a287592098c4f6c7b7c7/vm_insnhelper.h#L123
#define GET_PREV_EP(ep) ((VALUE *)((ep)[VM_ENV_DATA_INDEX_SPECVAL] & ~0x03))

// get sp from the cfp
SORBET_INLINE
VALUE **sorbet_get_sp(rb_control_frame_t *cfp) {
    return &(cfp->sp);
}
KEEP_ALIVE(sorbet_get_sp);

// Push an entry to the ruby value stack and return the new sp
SORBET_INLINE
VALUE *sorbet_pushValueStack(VALUE *sp, const VALUE val) {
    *sp = val;
    return (sp + 1);
}
KEEP_ALIVE(sorbet_pushValueStack);

// https://github.com/ruby/ruby/blob/a9a48e6a741f048766a2a287592098c4f6c7b7c7/vm_insnhelper.c#L2919-L2928
static const VALUE *vm_get_ep(const VALUE *const reg_ep, rb_num_t lv) {
    rb_num_t i;
    const VALUE *ep = reg_ep;
    for (i = 0; i < lv; i++) {
        ep = GET_PREV_EP(ep);
    }
    return ep;
}

SORBET_INLINE
static int computeLocalIndex(long index) {
    // Local offset calculation needs to take into account the fixed values that
    // are present on the stack:
    // https://github.com/ruby/ruby/blob/a9a48e6a741f048766a2a287592098c4f6c7b7c7/compile.c#L1509
    return index + VM_ENV_DATA_SIZE;
}

// Read a value from the locals from this stack frame.
//
// * index - local var index
// * level - the number of blocks that need to be crossed to reach the
//           outer-most stack frame.
SORBET_INLINE
VALUE sorbet_readLocal(rb_control_frame_t *cfp, long index, long level) {
    int offset = computeLocalIndex(index);
    return *(vm_get_ep(cfp->ep, level) - offset);
}

// https://github.com/ruby/ruby/blob/a9a48e6a741f048766a2a287592098c4f6c7b7c7/vm_insnhelper.c#L361-L371
SORBET_INLINE
static inline void vm_env_write(const VALUE *ep, int index, VALUE v) {
    VALUE flags = ep[VM_ENV_DATA_INDEX_FLAGS];
    if (LIKELY((flags & VM_ENV_FLAG_WB_REQUIRED) == 0)) {
        VM_STACK_ENV_WRITE(ep, index, v);
    } else {
        sorbet_vm_env_write_slowpath(ep, index, v);
    }
}

// Called after intrinsic implementations to run any cleanup actions that the vm would normally have done.
// TODO: This might be a good candidate for storing in the vm-payload, as RUBY_VM_CHECK_INTS will likely inline.
SORBET_INLINE
void sorbet_afterIntrinsic() {
    rb_execution_context_t *ec = GET_EC();
    RUBY_VM_CHECK_INTS(ec);
}

// Write a value into the locals from this stack frame.
//
// * index - local var index
// * level - the number of blocks that need to be crossed to reach the
//           outer-most stack frame.
// * value - the value to write
SORBET_INLINE
void sorbet_writeLocal(rb_control_frame_t *cfp, long index, long level, VALUE value) {
    int offset = computeLocalIndex(index);
    vm_env_write(vm_get_ep(cfp->ep, level), -offset, value);
}

SORBET_INLINE
VALUE sorbet_vmBlockHandlerNone() {
    return VM_BLOCK_HANDLER_NONE;
}
KEEP_ALIVE(sorbet_vmBlockHandlerNone);

static VALUE sorbet_iterMethod(VALUE obj) {
    struct FunctionInlineCache *cache = (struct FunctionInlineCache *)obj;

    // In this case we know that a block handler was set, as we only emit calls to this payload function from sends that
    // pass a block argument.
    rb_execution_context_t *ec = GET_EC();
    VALUE bh = ec->passed_block_handler;

    // It's important that we clear out the passed block handler state in the execution context:
    // https://github.com/ruby/ruby/blob/ruby_2_7/vm.c#L203-L210
    ec->passed_block_handler = VM_BLOCK_HANDLER_NONE;

    return sorbet_callFuncWithCache(cache, bh);
}

SORBET_INLINE
VALUE sorbet_callFuncBlockWithCache(struct FunctionInlineCache *cache, BlockFFIType blockImpl, int blkMinArgs,
                                    int blkMaxArgs, VALUE closure) {
    return sorbet_rb_iterate(sorbet_iterMethod, (VALUE)cache, blockImpl, blkMinArgs, blkMaxArgs, closure);
}
KEEP_ALIVE(sorbet_callFuncBlockWithCache);

SORBET_INLINE
VALUE sorbet_callFuncBlockWithCache_noBreak(struct FunctionInlineCache *cache, BlockFFIType blockImpl, int blkMinArgs,
                                            int blkMaxArgs, VALUE closure) {
    rb_execution_context_t *ec = GET_EC();
    rb_control_frame_t *cfp = ec->cfp;

    // This is an inlined version of the block handler setup that `rb_iterate` performs. See the following two links for
    // the use of `rb_vm_ifunc_proc_new` and the setup of the captured block handler.
    // * https://github.com/ruby/ruby/blob/ruby_2_7/vm_eval.c#L1448
    // * https://github.com/ruby/ruby/blob/ruby_2_7/vm_eval.c#L1406-L1408
    const struct vm_ifunc *const ifunc = rb_vm_ifunc_new(blockImpl, (void *)closure, blkMinArgs, blkMaxArgs);
    struct rb_captured_block *captured = (struct rb_captured_block *)&cfp->self;
    captured->code.ifunc = ifunc;

    // It's important that we clear out the passed block handler state in the execution context:
    // https://github.com/ruby/ruby/blob/ruby_2_7/vm.c#L203-L210
    ec->passed_block_handler = VM_BLOCK_HANDLER_NONE;

    // We don't need to pass the block handler through ec->passed_block_handler in this case.
    return sorbet_callFuncWithCache(cache, VM_BH_FROM_IFUNC_BLOCK(captured));
}
KEEP_ALIVE(sorbet_callFuncBlockWithCache_noBreak);

SORBET_INLINE
VALUE sorbet_makeBlockHandlerProc(VALUE block) {
    if (block == Qnil) {
        return VM_BLOCK_HANDLER_NONE;
    }
    return rb_funcall(block, rb_intern2("to_proc", 7), 0);
}

SORBET_INLINE
bool sorbet_isCachedMethod(struct FunctionInlineCache *cache, VALUE (*expectedFnPtr)(), VALUE recv) {
    // Assumes that the cache is already up-to-date. If you haven't done this
    // yourself, call: `sorbet_vmMethodSearch(cache, recv)`

    rb_method_definition_t *def = cache->cd.cc.me->def;
    return (def->type == VM_METHOD_TYPE_CFUNC) && (def->body.cfunc.func == expectedFnPtr);
}

SORBET_INLINE
VALUE sorbet_callFuncDirect(struct FunctionInlineCache *cache, rb_sorbet_func_t methodPtr, int argc, VALUE *argv,
                            VALUE recv, rb_iseq_t *iseq) {
    // we need a method entry from the call data to be able to setup the stack correctly.
    if (UNLIKELY(cache->cd.cc.me == NULL)) {
        sorbet_vmMethodSearch(cache, recv);
    }

    rb_control_frame_t *cfp = sorbet_pushCfuncFrame(cache, recv, iseq);
    VALUE res = methodPtr(argc, argv, recv, cfp);
    sorbet_popFrame();
    return res;
}

SORBET_INLINE
VALUE sorbet_callStaticInitDirect(rb_sorbet_func_t methodPtr, int argc, VALUE *argv, VALUE recv) {
    rb_control_frame_t *cfp = sorbet_pushStaticInitFrame(recv);
    VALUE res = methodPtr(argc, argv, recv, cfp);
    sorbet_popFrame();
    return res;
}

struct sorbet_inlineIntrinsicEnv {
    VALUE recv;
    ID fun;
    int argc;
    VALUE *argv;
    VALUE closure;
};

// This function should always inline, as it will be the body of the functions generated by the `CallCMethod`
// symbol-based intrinsic method when a block handling function is provided. The body will always be given the intrinsic
// and block function directly, so this will turn into a direct call to the intrinsic since LLVM will inline this
// function.
SORBET_INLINE
VALUE sorbet_inlineIntrinsicEnv_apply(VALUE value, BlockConsumerFFIType intrinsic, BlockFFIType blk,
                                      int numPositionalArgs) {
    // fetch the captured block so that it's available for the intrinsic to push a frame
    rb_execution_context_t *ec = GET_EC();
    VALUE block_handler = ec->passed_block_handler;
    const struct rb_captured_block *captured = VM_BH_TO_IFUNC_BLOCK(block_handler);

    // It's important that we clear out the passed block handler state in the execution context:
    // https://github.com/ruby/ruby/blob/ruby_2_7/vm.c#L203-L210
    ec->passed_block_handler = VM_BLOCK_HANDLER_NONE;

    struct sorbet_inlineIntrinsicEnv *env = (struct sorbet_inlineIntrinsicEnv *)value;
    return intrinsic(env->recv, env->fun, env->argc, env->argv, blk, captured, env->closure, numPositionalArgs);
}

SORBET_INLINE
VALUE sorbet_callIntrinsicInlineBlock(VALUE (*body)(VALUE), VALUE recv, ID fun, int argc, VALUE *argv, BlockFFIType blk,
                                      int blkMinArgs, int blkMaxArgs, VALUE closure) {
    struct sorbet_inlineIntrinsicEnv env;
    env.recv = recv;
    env.fun = fun;
    env.argc = argc;
    env.argv = argv;
    env.closure = closure;

    // NOTE: we pass the block function to rb_iterate so that we ensure that the block handler is setup correctly.
    // However it won't be called through the vm, as that would hide the direct call to the block function from the
    // inliner.
    return sorbet_rb_iterate(body, (VALUE)&env, blk, blkMinArgs, blkMaxArgs, closure);
}

SORBET_INLINE
VALUE sorbet_callIntrinsicInlineBlock_noBreak(VALUE (*body)(VALUE), VALUE recv, ID fun, int argc, VALUE *argv,
                                              BlockFFIType blk, int blkMinArgs, int blkMaxArgs, VALUE closure) {
    struct sorbet_inlineIntrinsicEnv env;
    env.recv = recv;
    env.fun = fun;
    env.argc = argc;
    env.argv = argv;
    env.closure = closure;

    // In the case that we don't see `break` used in the block, it's OK to skip setting up the tag stack and instead
    // directly allocate the resources needed to setup the block frame. The setup before the call to the `body`
    // function is a combination of the conditional allocation from `rb_iterate` and the setup of the block handler
    // when that allocation was successful.

    rb_execution_context_t *ec = GET_EC();
    rb_control_frame_t *cfp = ec->cfp;

    const struct vm_ifunc *const ifunc = rb_vm_ifunc_new(blk, (void *)closure, blkMinArgs, blkMaxArgs);
    struct rb_captured_block *captured = (struct rb_captured_block *)&cfp->self;
    captured->code.ifunc = ifunc;
    VALUE blockHandler = VM_BH_FROM_IFUNC_BLOCK(captured);
    ec->passed_block_handler = blockHandler;

    return body((VALUE)&env);
}

SORBET_INLINE
unsigned int sorbet_vmCallKwarg() {
    return VM_CALL_KWARG;
}

SORBET_INLINE
unsigned int sorbet_vmCallArgsSimple() {
    return VM_CALL_ARGS_SIMPLE;
}

SORBET_INLINE
unsigned int sorbet_vmCallArgsSplat() {
    return VM_CALL_ARGS_SPLAT;
}

SORBET_INLINE
unsigned int sorbet_vmCallKwSplat() {
    return VM_CALL_KW_SPLAT;
}

SORBET_INLINE
unsigned int sorbet_vmCallFCall() {
    return VM_CALL_FCALL;
}

// static struct rb_kwarg_call_data test_cd = {0};

SORBET_INLINE
const rb_control_frame_t *sorbet_setRubyStackFrame(_Bool isStaticInit, int iseq_type, rb_iseq_t *iseq) {
    rb_execution_context_t *ec = GET_EC();
    rb_control_frame_t *cfp = ec->cfp;

    // Depending on what kind of iseq we're switching to, we need to push a frame on the ruby stack.
    if (iseq_type == ISEQ_TYPE_RESCUE || iseq_type == ISEQ_TYPE_ENSURE) {
        sorbet_setExceptionStackFrame(ec, cfp, iseq);
    } else if (iseq_type == ISEQ_TYPE_BLOCK) {
        cfp->iseq = iseq;
        VM_ENV_FLAGS_UNSET(cfp->ep, VM_FRAME_FLAG_CFRAME);
    } else if (isStaticInit) {
        cfp->iseq = iseq;

        // NOTE: we unset CFRAME here to convince the VM that this is a method that has a valid iseq backing it, that
        // can be used to reconstruct line numbers. This works in concert with setting the iseq for the cfp above, and
        // also with sorbet_setLineNumber.
        //
        // NOTE: we unset FINISH here to avoid issues with exceptions bubbling out of a static-init context.
        // Specifically, we need to ensure that we don't jump to a tag in
        // https://github.com/ruby/ruby/blob/a9a48e6a741f048766a2a287592098c4f6c7b7c7/vm.c#L2112
        // as this context will never have a tag pushed for it, and jumping in the context of this frame would break
        // assumptions that those handlers make about the ruby stacks.
        VM_ENV_FLAGS_UNSET(cfp->ep, VM_FRAME_FLAG_FINISH);

        sorbet_setMethodStackFrame(ec, cfp, iseq);
    }

    return cfp;
}

SORBET_INLINE
VALUE sorbet_callSuper(int argc, SORBET_ATTRIBUTE(noescape) const VALUE *const restrict argv, int kw_splat) {
    // Mostly an implementation of return rb_call_super(argc, argv);
    rb_execution_context_t *ec = GET_EC();
    VALUE recv = ec->cfp->self;
    VALUE klass;
    ID id;
    rb_control_frame_t *cfp = ec->cfp;
    const rb_callable_method_entry_t *me = rb_vm_frame_method_entry(cfp);

    klass = RCLASS_ORIGIN(me->defined_class);
    klass = RCLASS_SUPER(klass);
    id = me->def->original_id;
    me = rb_callable_method_entry(klass, id);

    if (!me) {
        // TODO do something here
        // return rb_method_missing(recv, id, argc, argv, MISSING_SUPER);
        rb_raise(rb_eRuntimeError, "unimplemented super with a missing method");
        return Qnil;
    } else {
        return rb_vm_call_kw(ec, recv, id, argc, argv, me, kw_splat);
    }
}

struct sorbet_iterSuperArg {
    VALUE recv;
    ID func;
    int argc;
    const VALUE *argv;
    const rb_callable_method_entry_t *me;
    int kw_splat;
};

static VALUE sorbet_iterSuper(VALUE obj) {
    struct sorbet_iterSuperArg *arg = (struct sorbet_iterSuperArg *)obj;
    return rb_vm_call_kw(GET_EC(), arg->recv, arg->func, arg->argc, arg->argv, arg->me, arg->kw_splat);
}

SORBET_INLINE
VALUE sorbet_callSuperBlock(int argc, SORBET_ATTRIBUTE(noescape) const VALUE *const restrict argv, int kw_splat,
                            BlockFFIType blockImpl, int blkMinArgs, int blkMaxArgs, VALUE closure) {
    // Mostly an implementation of return rb_call_super(argc, argv);
    rb_execution_context_t *ec = GET_EC();
    VALUE recv = ec->cfp->self;
    VALUE klass;
    ID id;
    rb_control_frame_t *cfp = ec->cfp;
    const rb_callable_method_entry_t *me = rb_vm_frame_method_entry(cfp);

    klass = RCLASS_ORIGIN(me->defined_class);
    klass = RCLASS_SUPER(klass);
    id = me->def->original_id;
    me = rb_callable_method_entry(klass, id);

    if (!me) {
        // TODO do something here
        // return rb_method_missing(recv, id, argc, argv, MISSING_SUPER);
        rb_raise(rb_eRuntimeError, "unimplemented super with a missing method");
        return Qnil;
    }

    struct sorbet_iterSuperArg arg;
    arg.recv = recv;
    arg.func = id;
    arg.argc = argc;
    arg.argv = argv;
    arg.me = me;
    arg.kw_splat = kw_splat;

    return sorbet_rb_iterate(sorbet_iterSuper, (VALUE)&arg, blockImpl, blkMinArgs, blkMaxArgs, closure);
}

SORBET_INLINE
void *sorbet_allocateParamInfo() {
    rb_sorbet_param_t *info = ZALLOC(rb_sorbet_param_t);
    // Make it a type that's easy to deal with in LLVM IR.
    return (void *)info;
}

// It's not worth building this into Ruby; all of these parameters are expected to
// be compile-time constants, and building the arguments for the call into Ruby
// would be about as expensive as doing all the stores below.  Plus the compiler
// can fold the stores into body->param.flags together in this version.
SORBET_INLINE
void sorbet_setParamInfo(void *paramp, bool has_lead, bool has_opt, bool has_rest, bool has_post, bool has_kw,
                         bool has_kwrest, bool has_block, bool accepts_no_kwarg, int lead_num, int opt_num,
                         int rest_start, int post_start, int post_num, int block_start, unsigned int size) {
    rb_sorbet_param_t *param = (rb_sorbet_param_t *)paramp;
    param->flags.has_lead = has_lead;
    param->flags.has_opt = has_opt;
    param->flags.has_rest = has_rest;
    param->flags.has_post = has_post;
    param->flags.has_kw = has_kw;
    param->flags.has_kwrest = has_kwrest;
    param->flags.has_block = has_block;
    param->flags.accepts_no_kwarg = accepts_no_kwarg;

    param->lead_num = lead_num;
    param->opt_num = opt_num;
    param->rest_start = rest_start;
    param->post_start = post_start;
    param->post_num = post_num;
    param->block_start = block_start;

    param->size = size;

    // param->{opt_table, keyword} are set up elsewhere.
}

// TODO(froydnj): we may want to put this in the VM payload.
SORBET_INLINE
void sorbet_setupParamPositional(void *paramp, int n_ids, ID *table) {
    rb_sorbet_param_t *param = (rb_sorbet_param_t *)paramp;

    // This table is never freed.
    ID *installed = ALLOC_N(ID, n_ids);
    MEMCPY(installed, table, ID, n_ids);
    param->pos_table = installed;
}

SORBET_INLINE
void sorbet_setupParamKeywords(void *paramp, int kw_num, int required_num, int n_ids, ID *table) {
    rb_sorbet_param_t *param = (rb_sorbet_param_t *)paramp;

    param->kw_num = kw_num;
    param->kw_required_num = required_num;

    // kw_bits_start (rb_iseq_param_keyword::bits_start) is only cryptically
    // documented as "keyword_bits" in the comment copied from vm_core.h that
    // lives in Payload.cc.  Reverse-engineering compile.c and consulting
    // RubyVM::InstructionSequence.compile("...").to_a suggests that
    // bits_start is the index just after the keyword args end.
    param->kw_bits_start = param->lead_num + param->opt_num + kw_num;
    // And, likewise, kw_rest_start (rb_iseq_param_keyword::rest_start)
    // appears to be one more after that...assuming, of course, that we have
    // **rest.
    if (param->flags.has_kwrest) {
        param->kw_rest_start = param->kw_bits_start + 1;
    }

    // This table is never freed.
    ID *kwtab = ALLOC_N(ID, n_ids);
    MEMCPY(kwtab, table, ID, n_ids);
    param->kw_table = kwtab;
}

// ****
// ****                       Exceptions
// ****

SORBET_INLINE
VALUE sorbet_getTRetry() {
    static const char retry[] = "T::Private::Retry::RETRY";
    return sorbet_getConstant(retry, sizeof(retry));
}

__attribute__((__noreturn__)) VALUE sorbet_block_break(VALUE recv, ID fun, int argc, const VALUE *const restrict argv,
                                                       BlockFFIType blk, VALUE closure) {
    rb_iter_break_value(argv[0]);
}

// Raise the exception value, unless it's nil.
SORBET_INLINE
void sorbet_raiseIfNotNil(VALUE exception) {
    if (exception == RUBY_Qnil) {
        return;
    }

    rb_exc_raise(exception);
}

// Ruby passes the RTLD_LAZY flag to the dlopen(3) call (which is supported by both macOS and Linux).
// That flag says, "Only resolve symbols as the code that references them is executed. If the symbol
// is never referenced, then it is never resolved."
//
// Thus, by putting our version check first before any other code in the C extension runs, and backing
// up the symbols our version check relies on with weak symbols, we can guarantee that the user never
// sees a symbol resolution error from loading a shared object when they shouldn't have.
SORBET_INLINE
void sorbet_ensureSorbetRuby(int compile_time_is_release_build, char *compile_time_build_scm_revision) {
    if (!compile_time_is_release_build) {
        // Skipping version check: This shared object was compiled by a non-release version of SorbetLLVM
        return;
    }

    const int runtime_is_release_build = sorbet_getIsReleaseBuild();
    if (!runtime_is_release_build) {
        // Skipping version check: sorbet_ruby is a non-release version
        return;
    }

    const char *runtime_build_scm_revision = sorbet_getBuildSCMRevision();
    if (strcmp(compile_time_build_scm_revision, runtime_build_scm_revision) != 0) {
        rb_raise(rb_eRuntimeError,
                 "SorbetLLVM runtime version mismatch: sorbet_ruby compiled with %s but shared object compiled with %s",
                 runtime_build_scm_revision, compile_time_build_scm_revision);
    }
}

// ****
// ****                       sorbet_ruby version information fallback
// ****

// A strong version of these functions will be linked into libruby.so when Ruby is built as sorbet_ruby.
// When our compiled C extensions are loaded by sorbet_ruby, calls will resolve to the symbol inside libruby.so.
// When our compiled C extensions are loaded by a system Ruby or an rbenv-built Ruby, these weak symbols act as
// a fallback so that we can gracefully exit (Ruby exception) when not run under sorbet_ruby instead of
// ungracefully exit (dynamic symbol resolution error + corrupt Ruby VM).
const char *sorbet_getBuildSCMRevision() __attribute__((weak)) {
    rb_raise(rb_eRuntimeError,
             "sorbet_getBuildSCMRevision: Shared objects compiled by sorbet_llvm must be run by sorbet_ruby.");
}

const int sorbet_getIsReleaseBuild() __attribute__((weak)) {
    rb_raise(rb_eRuntimeError,
             "sorbet_getIsReleaseBuild: Shared objects compiled by sorbet_llvm must be run by sorbet_ruby.");
}
